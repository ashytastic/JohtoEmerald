#include "global.h"
#include "malloc.h"
#include "apprentice.h"
#include "battle.h"
<<<<<<< HEAD
=======
#include "battle_ai_switch_items.h"
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
#include "battle_anim.h"
#include "battle_controllers.h"
#include "battle_message.h"
#include "battle_pike.h"
#include "battle_pyramid.h"
#include "battle_setup.h"
#include "battle_tower.h"
<<<<<<< HEAD
#include "data.h"
#include "event_data.h"
#include "evolution_scene.h"
#include "field_specials.h"
#include "item.h"
=======
#include "battle_z_move.h"
#include "data.h"
#include "dexnav.h"
#include "event_data.h"
#include "event_object_movement.h"
#include "evolution_scene.h"
#include "field_player_avatar.h"
#include "field_specials.h"
#include "field_weather.h"
#include "follower_npc.h"
#include "graphics.h"
#include "item.h"
#include "caps.h"
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
#include "link.h"
#include "main.h"
#include "overworld.h"
#include "m4a.h"
#include "party_menu.h"
#include "pokedex.h"
#include "pokeblock.h"
#include "pokemon.h"
#include "pokemon_animation.h"
<<<<<<< HEAD
=======
#include "pokemon_icon.h"
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
#include "pokemon_summary_screen.h"
#include "pokemon_storage_system.h"
#include "random.h"
#include "recorded_battle.h"
#include "rtc.h"
#include "sound.h"
#include "string_util.h"
#include "strings.h"
#include "task.h"
<<<<<<< HEAD
=======
#include "test_runner.h"
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
#include "text.h"
#include "trainer_hill.h"
#include "util.h"
#include "constants/abilities.h"
#include "constants/battle_frontier.h"
#include "constants/battle_move_effects.h"
#include "constants/battle_script_commands.h"
<<<<<<< HEAD
=======
#include "constants/battle_partner.h"
#include "constants/battle_string_ids.h"
#include "constants/cries.h"
#include "constants/event_objects.h"
#include "constants/form_change_types.h"
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
#include "constants/hold_effects.h"
#include "constants/item_effects.h"
#include "constants/items.h"
#include "constants/layouts.h"
#include "constants/moves.h"
<<<<<<< HEAD
#include "constants/songs.h"
#include "constants/species.h"
#include "constants/trainers.h"
#include "constants/union_room.h"
#include "wild_encounter.h"
#include "constants/region_map_sections.h"
#include "constants/party_menu.h"
#include "tx_randomizer_and_challenges.h"
#include "constants/party_menu.h" //tx_randomizer_and_challenges

#define DAY_EVO_HOUR_BEGIN       12
#define DAY_EVO_HOUR_END         HOURS_PER_DAY

#define NIGHT_EVO_HOUR_BEGIN     0
#define NIGHT_EVO_HOUR_END       12

#define FRIENDSHIP_EVO_THRESHOLD 220
=======
#include "constants/regions.h"
#include "constants/songs.h"
#include "constants/trainers.h"
#include "constants/union_room.h"
#include "constants/weather.h"
#include "wild_encounter.h"

#define FRIENDSHIP_EVO_THRESHOLD ((P_FRIENDSHIP_EVO_THRESHOLD >= GEN_8) ? 160 : 220)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

struct SpeciesItem
{
    u16 species;
    u16 item;
};

static u16 CalculateBoxMonChecksum(struct BoxPokemon *boxMon);
<<<<<<< HEAD
static union PokemonSubstruct *GetSubstruct(struct BoxPokemon *boxMon, u32 personality, u8 substructType);
static void EncryptBoxMon(struct BoxPokemon *boxMon);
static void DecryptBoxMon(struct BoxPokemon *boxMon);
static void Task_PlayMapChosenOrBattleBGM(u8 taskId);
static bool8 ShouldGetStatBadgeBoost(u16 flagId, u8 battlerId);
static u16 GiveMoveToBoxMon(struct BoxPokemon *boxMon, u16 move);
static bool8 ShouldSkipFriendshipChange(void);
=======
static u16 CalculateBoxMonChecksumDecrypt(struct BoxPokemon *boxMon);
static u16 CalculateBoxMonChecksumReencrypt(struct BoxPokemon *boxMon);
static union PokemonSubstruct *GetSubstruct(struct BoxPokemon *boxMon, u32 personality, enum SubstructType substructType);
static void EncryptBoxMon(struct BoxPokemon *boxMon);
static void DecryptBoxMon(struct BoxPokemon *boxMon);
static void Task_PlayMapChosenOrBattleBGM(u8 taskId);
void TrySpecialOverworldEvo();
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

EWRAM_DATA static u8 sLearningMoveTableID = 0;
EWRAM_DATA u8 gPlayerPartyCount = 0;
EWRAM_DATA u8 gEnemyPartyCount = 0;
EWRAM_DATA struct Pokemon gPlayerParty[PARTY_SIZE] = {0};
<<<<<<< HEAD
EWRAM_DATA struct Pokemon gPlayerPartyBackup[PARTY_SIZE] = {0}; //tx_randomizer_and_challenges
EWRAM_DATA struct Pokemon gEnemyParty[PARTY_SIZE] = {0};
EWRAM_DATA struct SpriteTemplate gMultiuseSpriteTemplate = {0};
EWRAM_DATA static struct MonSpritesGfxManager *sMonSpritesGfxManagers[MON_SPR_GFX_MANAGERS_COUNT] = {NULL};
EWRAM_DATA static u8 sTypeEffectivenessList[NUMBER_OF_MON_TYPES] = {0}; //tx_randomizer_and_challenges

// const rom data
#include "data/battle_moves.h"
=======
EWRAM_DATA struct Pokemon gEnemyParty[PARTY_SIZE] = {0};
EWRAM_DATA struct SpriteTemplate gMultiuseSpriteTemplate = {0};
EWRAM_DATA static struct MonSpritesGfxManager *sMonSpritesGfxManagers[MON_SPR_GFX_MANAGERS_COUNT] = {NULL};
EWRAM_DATA static u8 sTriedEvolving = 0;
EWRAM_DATA u16 gFollowerSteps = 0;

#include "data/abilities.h"
#if P_TUTOR_MOVES_ARRAY
#include "data/tutor_moves.h"
#endif // P_TUTOR_MOVES_ARRAY
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

// Used in an unreferenced function in RS.
// Unreferenced here and in FRLG.
struct CombinedMove
{
    u16 move1;
    u16 move2;
    u16 newMove;
};

static const struct CombinedMove sCombinedMoves[2] =
{
    {MOVE_EMBER, MOVE_GUST, MOVE_HEAT_WAVE},
    {0xFFFF, 0xFFFF, 0xFFFF}
};

<<<<<<< HEAD
// NOTE: The order of the elements in the 3 arrays below is irrelevant.
// To reorder the pokedex, see the values in include/constants/pokedex.h.

#define SPECIES_TO_HOENN(name)      [SPECIES_##name - 1] = HOENN_DEX_##name
#define SPECIES_TO_NATIONAL(name)   [SPECIES_##name - 1] = NATIONAL_DEX_##name
#define HOENN_TO_NATIONAL(name)     [HOENN_DEX_##name - 1] = NATIONAL_DEX_##name

// Assigns all species to the Hoenn Dex Index (Summary No. for Hoenn Dex)
static const u16 sSpeciesToHoennPokedexNum[NUM_SPECIES - 1] =
{
    SPECIES_TO_HOENN(BULBASAUR),
    SPECIES_TO_HOENN(IVYSAUR),
    SPECIES_TO_HOENN(VENUSAUR),
    SPECIES_TO_HOENN(CHARMANDER),
    SPECIES_TO_HOENN(CHARMELEON),
    SPECIES_TO_HOENN(CHARIZARD),
    SPECIES_TO_HOENN(SQUIRTLE),
    SPECIES_TO_HOENN(WARTORTLE),
    SPECIES_TO_HOENN(BLASTOISE),
    SPECIES_TO_HOENN(CATERPIE),
    SPECIES_TO_HOENN(METAPOD),
    SPECIES_TO_HOENN(BUTTERFREE),
    SPECIES_TO_HOENN(WEEDLE),
    SPECIES_TO_HOENN(KAKUNA),
    SPECIES_TO_HOENN(BEEDRILL),
    SPECIES_TO_HOENN(PIDGEY),
    SPECIES_TO_HOENN(PIDGEOTTO),
    SPECIES_TO_HOENN(PIDGEOT),
    SPECIES_TO_HOENN(RATTATA),
    SPECIES_TO_HOENN(RATICATE),
    SPECIES_TO_HOENN(SPEAROW),
    SPECIES_TO_HOENN(FEAROW),
    SPECIES_TO_HOENN(EKANS),
    SPECIES_TO_HOENN(ARBOK),
    SPECIES_TO_HOENN(PIKACHU),
    SPECIES_TO_HOENN(RAICHU),
    SPECIES_TO_HOENN(SANDSHREW),
    SPECIES_TO_HOENN(SANDSLASH),
    SPECIES_TO_HOENN(NIDORAN_F),
    SPECIES_TO_HOENN(NIDORINA),
    SPECIES_TO_HOENN(NIDOQUEEN),
    SPECIES_TO_HOENN(NIDORAN_M),
    SPECIES_TO_HOENN(NIDORINO),
    SPECIES_TO_HOENN(NIDOKING),
    SPECIES_TO_HOENN(CLEFAIRY),
    SPECIES_TO_HOENN(CLEFABLE),
    SPECIES_TO_HOENN(VULPIX),
    SPECIES_TO_HOENN(NINETALES),
    SPECIES_TO_HOENN(JIGGLYPUFF),
    SPECIES_TO_HOENN(WIGGLYTUFF),
    SPECIES_TO_HOENN(ZUBAT),
    SPECIES_TO_HOENN(GOLBAT),
    SPECIES_TO_HOENN(ODDISH),
    SPECIES_TO_HOENN(GLOOM),
    SPECIES_TO_HOENN(VILEPLUME),
    SPECIES_TO_HOENN(PARAS),
    SPECIES_TO_HOENN(PARASECT),
    SPECIES_TO_HOENN(VENONAT),
    SPECIES_TO_HOENN(VENOMOTH),
    SPECIES_TO_HOENN(DIGLETT),
    SPECIES_TO_HOENN(DUGTRIO),
    SPECIES_TO_HOENN(MEOWTH),
    SPECIES_TO_HOENN(PERSIAN),
    SPECIES_TO_HOENN(PSYDUCK),
    SPECIES_TO_HOENN(GOLDUCK),
    SPECIES_TO_HOENN(MANKEY),
    SPECIES_TO_HOENN(PRIMEAPE),
    SPECIES_TO_HOENN(GROWLITHE),
    SPECIES_TO_HOENN(ARCANINE),
    SPECIES_TO_HOENN(POLIWAG),
    SPECIES_TO_HOENN(POLIWHIRL),
    SPECIES_TO_HOENN(POLIWRATH),
    SPECIES_TO_HOENN(ABRA),
    SPECIES_TO_HOENN(KADABRA),
    SPECIES_TO_HOENN(ALAKAZAM),
    SPECIES_TO_HOENN(MACHOP),
    SPECIES_TO_HOENN(MACHOKE),
    SPECIES_TO_HOENN(MACHAMP),
    SPECIES_TO_HOENN(BELLSPROUT),
    SPECIES_TO_HOENN(WEEPINBELL),
    SPECIES_TO_HOENN(VICTREEBEL),
    SPECIES_TO_HOENN(TENTACOOL),
    SPECIES_TO_HOENN(TENTACRUEL),
    SPECIES_TO_HOENN(GEODUDE),
    SPECIES_TO_HOENN(GRAVELER),
    SPECIES_TO_HOENN(GOLEM),
    SPECIES_TO_HOENN(PONYTA),
    SPECIES_TO_HOENN(RAPIDASH),
    SPECIES_TO_HOENN(SLOWPOKE),
    SPECIES_TO_HOENN(SLOWBRO),
    SPECIES_TO_HOENN(MAGNEMITE),
    SPECIES_TO_HOENN(MAGNETON),
    SPECIES_TO_HOENN(FARFETCHD),
    SPECIES_TO_HOENN(DODUO),
    SPECIES_TO_HOENN(DODRIO),
    SPECIES_TO_HOENN(SEEL),
    SPECIES_TO_HOENN(DEWGONG),
    SPECIES_TO_HOENN(GRIMER),
    SPECIES_TO_HOENN(MUK),
    SPECIES_TO_HOENN(SHELLDER),
    SPECIES_TO_HOENN(CLOYSTER),
    SPECIES_TO_HOENN(GASTLY),
    SPECIES_TO_HOENN(HAUNTER),
    SPECIES_TO_HOENN(GENGAR),
    SPECIES_TO_HOENN(ONIX),
    SPECIES_TO_HOENN(DROWZEE),
    SPECIES_TO_HOENN(HYPNO),
    SPECIES_TO_HOENN(KRABBY),
    SPECIES_TO_HOENN(KINGLER),
    SPECIES_TO_HOENN(VOLTORB),
    SPECIES_TO_HOENN(ELECTRODE),
    SPECIES_TO_HOENN(EXEGGCUTE),
    SPECIES_TO_HOENN(EXEGGUTOR),
    SPECIES_TO_HOENN(CUBONE),
    SPECIES_TO_HOENN(MAROWAK),
    SPECIES_TO_HOENN(HITMONLEE),
    SPECIES_TO_HOENN(HITMONCHAN),
    SPECIES_TO_HOENN(LICKITUNG),
    SPECIES_TO_HOENN(KOFFING),
    SPECIES_TO_HOENN(WEEZING),
    SPECIES_TO_HOENN(RHYHORN),
    SPECIES_TO_HOENN(RHYDON),
    SPECIES_TO_HOENN(CHANSEY),
    SPECIES_TO_HOENN(TANGELA),
    SPECIES_TO_HOENN(KANGASKHAN),
    SPECIES_TO_HOENN(HORSEA),
    SPECIES_TO_HOENN(SEADRA),
    SPECIES_TO_HOENN(GOLDEEN),
    SPECIES_TO_HOENN(SEAKING),
    SPECIES_TO_HOENN(STARYU),
    SPECIES_TO_HOENN(STARMIE),
    SPECIES_TO_HOENN(MR_MIME),
    SPECIES_TO_HOENN(SCYTHER),
    SPECIES_TO_HOENN(JYNX),
    SPECIES_TO_HOENN(ELECTABUZZ),
    SPECIES_TO_HOENN(MAGMAR),
    SPECIES_TO_HOENN(PINSIR),
    SPECIES_TO_HOENN(TAUROS),
    SPECIES_TO_HOENN(MAGIKARP),
    SPECIES_TO_HOENN(GYARADOS),
    SPECIES_TO_HOENN(LAPRAS),
    SPECIES_TO_HOENN(DITTO),
    SPECIES_TO_HOENN(EEVEE),
    SPECIES_TO_HOENN(VAPOREON),
    SPECIES_TO_HOENN(JOLTEON),
    SPECIES_TO_HOENN(FLAREON),
    SPECIES_TO_HOENN(PORYGON),
    SPECIES_TO_HOENN(OMANYTE),
    SPECIES_TO_HOENN(OMASTAR),
    SPECIES_TO_HOENN(KABUTO),
    SPECIES_TO_HOENN(KABUTOPS),
    SPECIES_TO_HOENN(AERODACTYL),
    SPECIES_TO_HOENN(SNORLAX),
    SPECIES_TO_HOENN(ARTICUNO),
    SPECIES_TO_HOENN(ZAPDOS),
    SPECIES_TO_HOENN(MOLTRES),
    SPECIES_TO_HOENN(DRATINI),
    SPECIES_TO_HOENN(DRAGONAIR),
    SPECIES_TO_HOENN(DRAGONITE),
    SPECIES_TO_HOENN(MEWTWO),
    SPECIES_TO_HOENN(MEW),
    SPECIES_TO_HOENN(CHIKORITA),
    SPECIES_TO_HOENN(BAYLEEF),
    SPECIES_TO_HOENN(MEGANIUM),
    SPECIES_TO_HOENN(CYNDAQUIL),
    SPECIES_TO_HOENN(QUILAVA),
    SPECIES_TO_HOENN(TYPHLOSION),
    SPECIES_TO_HOENN(TOTODILE),
    SPECIES_TO_HOENN(CROCONAW),
    SPECIES_TO_HOENN(FERALIGATR),
    SPECIES_TO_HOENN(SENTRET),
    SPECIES_TO_HOENN(FURRET),
    SPECIES_TO_HOENN(HOOTHOOT),
    SPECIES_TO_HOENN(NOCTOWL),
    SPECIES_TO_HOENN(LEDYBA),
    SPECIES_TO_HOENN(LEDIAN),
    SPECIES_TO_HOENN(SPINARAK),
    SPECIES_TO_HOENN(ARIADOS),
    SPECIES_TO_HOENN(CROBAT),
    SPECIES_TO_HOENN(CHINCHOU),
    SPECIES_TO_HOENN(LANTURN),
    SPECIES_TO_HOENN(PICHU),
    SPECIES_TO_HOENN(CLEFFA),
    SPECIES_TO_HOENN(IGGLYBUFF),
    SPECIES_TO_HOENN(TOGEPI),
    SPECIES_TO_HOENN(TOGETIC),
    SPECIES_TO_HOENN(NATU),
    SPECIES_TO_HOENN(XATU),
    SPECIES_TO_HOENN(MAREEP),
    SPECIES_TO_HOENN(FLAAFFY),
    SPECIES_TO_HOENN(AMPHAROS),
    SPECIES_TO_HOENN(BELLOSSOM),
    SPECIES_TO_HOENN(MARILL),
    SPECIES_TO_HOENN(AZUMARILL),
    SPECIES_TO_HOENN(SUDOWOODO),
    SPECIES_TO_HOENN(POLITOED),
    SPECIES_TO_HOENN(HOPPIP),
    SPECIES_TO_HOENN(SKIPLOOM),
    SPECIES_TO_HOENN(JUMPLUFF),
    SPECIES_TO_HOENN(AIPOM),
    SPECIES_TO_HOENN(SUNKERN),
    SPECIES_TO_HOENN(SUNFLORA),
    SPECIES_TO_HOENN(YANMA),
    SPECIES_TO_HOENN(WOOPER),
    SPECIES_TO_HOENN(QUAGSIRE),
    SPECIES_TO_HOENN(ESPEON),
    SPECIES_TO_HOENN(UMBREON),
    SPECIES_TO_HOENN(MURKROW),
    SPECIES_TO_HOENN(SLOWKING),
    SPECIES_TO_HOENN(MISDREAVUS),
    SPECIES_TO_HOENN(UNOWN),
    SPECIES_TO_HOENN(WOBBUFFET),
    SPECIES_TO_HOENN(GIRAFARIG),
    SPECIES_TO_HOENN(PINECO),
    SPECIES_TO_HOENN(FORRETRESS),
    SPECIES_TO_HOENN(DUNSPARCE),
    SPECIES_TO_HOENN(GLIGAR),
    SPECIES_TO_HOENN(STEELIX),
    SPECIES_TO_HOENN(SNUBBULL),
    SPECIES_TO_HOENN(GRANBULL),
    SPECIES_TO_HOENN(QWILFISH),
    SPECIES_TO_HOENN(SCIZOR),
    SPECIES_TO_HOENN(SHUCKLE),
    SPECIES_TO_HOENN(HERACROSS),
    SPECIES_TO_HOENN(SNEASEL),
    SPECIES_TO_HOENN(TEDDIURSA),
    SPECIES_TO_HOENN(URSARING),
    SPECIES_TO_HOENN(SLUGMA),
    SPECIES_TO_HOENN(MAGCARGO),
    SPECIES_TO_HOENN(SWINUB),
    SPECIES_TO_HOENN(PILOSWINE),
    SPECIES_TO_HOENN(CORSOLA),
    SPECIES_TO_HOENN(REMORAID),
    SPECIES_TO_HOENN(OCTILLERY),
    SPECIES_TO_HOENN(DELIBIRD),
    SPECIES_TO_HOENN(MANTINE),
    SPECIES_TO_HOENN(SKARMORY),
    SPECIES_TO_HOENN(HOUNDOUR),
    SPECIES_TO_HOENN(HOUNDOOM),
    SPECIES_TO_HOENN(KINGDRA),
    SPECIES_TO_HOENN(PHANPY),
    SPECIES_TO_HOENN(DONPHAN),
    SPECIES_TO_HOENN(PORYGON2),
    SPECIES_TO_HOENN(STANTLER),
    SPECIES_TO_HOENN(SMEARGLE),
    SPECIES_TO_HOENN(TYROGUE),
    SPECIES_TO_HOENN(HITMONTOP),
    SPECIES_TO_HOENN(SMOOCHUM),
    SPECIES_TO_HOENN(ELEKID),
    SPECIES_TO_HOENN(MAGBY),
    SPECIES_TO_HOENN(MILTANK),
    SPECIES_TO_HOENN(BLISSEY),
    SPECIES_TO_HOENN(RAIKOU),
    SPECIES_TO_HOENN(ENTEI),
    SPECIES_TO_HOENN(SUICUNE),
    SPECIES_TO_HOENN(LARVITAR),
    SPECIES_TO_HOENN(PUPITAR),
    SPECIES_TO_HOENN(TYRANITAR),
    SPECIES_TO_HOENN(LUGIA),
    SPECIES_TO_HOENN(HO_OH),
    SPECIES_TO_HOENN(CELEBI),
    SPECIES_TO_HOENN(OLD_UNOWN_B),
    SPECIES_TO_HOENN(OLD_UNOWN_C),
    SPECIES_TO_HOENN(OLD_UNOWN_D),
    SPECIES_TO_HOENN(OLD_UNOWN_E),
    SPECIES_TO_HOENN(OLD_UNOWN_F),
    SPECIES_TO_HOENN(OLD_UNOWN_G),
    SPECIES_TO_HOENN(OLD_UNOWN_H),
    SPECIES_TO_HOENN(OLD_UNOWN_I),
    SPECIES_TO_HOENN(OLD_UNOWN_J),
    SPECIES_TO_HOENN(OLD_UNOWN_K),
    SPECIES_TO_HOENN(OLD_UNOWN_L),
    SPECIES_TO_HOENN(OLD_UNOWN_M),
    SPECIES_TO_HOENN(OLD_UNOWN_N),
    SPECIES_TO_HOENN(OLD_UNOWN_O),
    SPECIES_TO_HOENN(OLD_UNOWN_P),
    SPECIES_TO_HOENN(OLD_UNOWN_Q),
    SPECIES_TO_HOENN(OLD_UNOWN_R),
    SPECIES_TO_HOENN(OLD_UNOWN_S),
    SPECIES_TO_HOENN(OLD_UNOWN_T),
    SPECIES_TO_HOENN(OLD_UNOWN_U),
    SPECIES_TO_HOENN(OLD_UNOWN_V),
    SPECIES_TO_HOENN(OLD_UNOWN_W),
    SPECIES_TO_HOENN(OLD_UNOWN_X),
    SPECIES_TO_HOENN(OLD_UNOWN_Y),
    SPECIES_TO_HOENN(OLD_UNOWN_Z),
    SPECIES_TO_HOENN(TREECKO),
    SPECIES_TO_HOENN(GROVYLE),
    SPECIES_TO_HOENN(SCEPTILE),
    SPECIES_TO_HOENN(TORCHIC),
    SPECIES_TO_HOENN(COMBUSKEN),
    SPECIES_TO_HOENN(BLAZIKEN),
    SPECIES_TO_HOENN(MUDKIP),
    SPECIES_TO_HOENN(MARSHTOMP),
    SPECIES_TO_HOENN(SWAMPERT),
    SPECIES_TO_HOENN(POOCHYENA),
    SPECIES_TO_HOENN(MIGHTYENA),
    SPECIES_TO_HOENN(ZIGZAGOON),
    SPECIES_TO_HOENN(LINOONE),
    SPECIES_TO_HOENN(WURMPLE),
    SPECIES_TO_HOENN(SILCOON),
    SPECIES_TO_HOENN(BEAUTIFLY),
    SPECIES_TO_HOENN(CASCOON),
    SPECIES_TO_HOENN(DUSTOX),
    SPECIES_TO_HOENN(LOTAD),
    SPECIES_TO_HOENN(LOMBRE),
    SPECIES_TO_HOENN(LUDICOLO),
    SPECIES_TO_HOENN(SEEDOT),
    SPECIES_TO_HOENN(NUZLEAF),
    SPECIES_TO_HOENN(SHIFTRY),
    SPECIES_TO_HOENN(NINCADA),
    SPECIES_TO_HOENN(NINJASK),
    SPECIES_TO_HOENN(SHEDINJA),
    SPECIES_TO_HOENN(TAILLOW),
    SPECIES_TO_HOENN(SWELLOW),
    SPECIES_TO_HOENN(SHROOMISH),
    SPECIES_TO_HOENN(BRELOOM),
    SPECIES_TO_HOENN(SPINDA),
    SPECIES_TO_HOENN(WINGULL),
    SPECIES_TO_HOENN(PELIPPER),
    SPECIES_TO_HOENN(SURSKIT),
    SPECIES_TO_HOENN(MASQUERAIN),
    SPECIES_TO_HOENN(WAILMER),
    SPECIES_TO_HOENN(WAILORD),
    SPECIES_TO_HOENN(SKITTY),
    SPECIES_TO_HOENN(DELCATTY),
    SPECIES_TO_HOENN(KECLEON),
    SPECIES_TO_HOENN(BALTOY),
    SPECIES_TO_HOENN(CLAYDOL),
    SPECIES_TO_HOENN(NOSEPASS),
    SPECIES_TO_HOENN(TORKOAL),
    SPECIES_TO_HOENN(SABLEYE),
    SPECIES_TO_HOENN(BARBOACH),
    SPECIES_TO_HOENN(WHISCASH),
    SPECIES_TO_HOENN(LUVDISC),
    SPECIES_TO_HOENN(CORPHISH),
    SPECIES_TO_HOENN(CRAWDAUNT),
    SPECIES_TO_HOENN(FEEBAS),
    SPECIES_TO_HOENN(MILOTIC),
    SPECIES_TO_HOENN(CARVANHA),
    SPECIES_TO_HOENN(SHARPEDO),
    SPECIES_TO_HOENN(TRAPINCH),
    SPECIES_TO_HOENN(VIBRAVA),
    SPECIES_TO_HOENN(FLYGON),
    SPECIES_TO_HOENN(MAKUHITA),
    SPECIES_TO_HOENN(HARIYAMA),
    SPECIES_TO_HOENN(ELECTRIKE),
    SPECIES_TO_HOENN(MANECTRIC),
    SPECIES_TO_HOENN(NUMEL),
    SPECIES_TO_HOENN(CAMERUPT),
    SPECIES_TO_HOENN(SPHEAL),
    SPECIES_TO_HOENN(SEALEO),
    SPECIES_TO_HOENN(WALREIN),
    SPECIES_TO_HOENN(CACNEA),
    SPECIES_TO_HOENN(CACTURNE),
    SPECIES_TO_HOENN(SNORUNT),
    SPECIES_TO_HOENN(GLALIE),
    SPECIES_TO_HOENN(LUNATONE),
    SPECIES_TO_HOENN(SOLROCK),
    SPECIES_TO_HOENN(AZURILL),
    SPECIES_TO_HOENN(SPOINK),
    SPECIES_TO_HOENN(GRUMPIG),
    SPECIES_TO_HOENN(PLUSLE),
    SPECIES_TO_HOENN(MINUN),
    SPECIES_TO_HOENN(MAWILE),
    SPECIES_TO_HOENN(MEDITITE),
    SPECIES_TO_HOENN(MEDICHAM),
    SPECIES_TO_HOENN(SWABLU),
    SPECIES_TO_HOENN(ALTARIA),
    SPECIES_TO_HOENN(WYNAUT),
    SPECIES_TO_HOENN(DUSKULL),
    SPECIES_TO_HOENN(DUSCLOPS),
    SPECIES_TO_HOENN(ROSELIA),
    SPECIES_TO_HOENN(SLAKOTH),
    SPECIES_TO_HOENN(VIGOROTH),
    SPECIES_TO_HOENN(SLAKING),
    SPECIES_TO_HOENN(GULPIN),
    SPECIES_TO_HOENN(SWALOT),
    SPECIES_TO_HOENN(TROPIUS),
    SPECIES_TO_HOENN(WHISMUR),
    SPECIES_TO_HOENN(LOUDRED),
    SPECIES_TO_HOENN(EXPLOUD),
    SPECIES_TO_HOENN(CLAMPERL),
    SPECIES_TO_HOENN(HUNTAIL),
    SPECIES_TO_HOENN(GOREBYSS),
    SPECIES_TO_HOENN(ABSOL),
    SPECIES_TO_HOENN(SHUPPET),
    SPECIES_TO_HOENN(BANETTE),
    SPECIES_TO_HOENN(SEVIPER),
    SPECIES_TO_HOENN(ZANGOOSE),
    SPECIES_TO_HOENN(RELICANTH),
    SPECIES_TO_HOENN(ARON),
    SPECIES_TO_HOENN(LAIRON),
    SPECIES_TO_HOENN(AGGRON),
    SPECIES_TO_HOENN(CASTFORM),
    SPECIES_TO_HOENN(VOLBEAT),
    SPECIES_TO_HOENN(ILLUMISE),
    SPECIES_TO_HOENN(LILEEP),
    SPECIES_TO_HOENN(CRADILY),
    SPECIES_TO_HOENN(ANORITH),
    SPECIES_TO_HOENN(ARMALDO),
    SPECIES_TO_HOENN(RALTS),
    SPECIES_TO_HOENN(KIRLIA),
    SPECIES_TO_HOENN(GARDEVOIR),
    SPECIES_TO_HOENN(BAGON),
    SPECIES_TO_HOENN(SHELGON),
    SPECIES_TO_HOENN(SALAMENCE),
    SPECIES_TO_HOENN(BELDUM),
    SPECIES_TO_HOENN(METANG),
    SPECIES_TO_HOENN(METAGROSS),
    SPECIES_TO_HOENN(REGIROCK),
    SPECIES_TO_HOENN(REGICE),
    SPECIES_TO_HOENN(REGISTEEL),
    SPECIES_TO_HOENN(KYOGRE),
    SPECIES_TO_HOENN(GROUDON),
    SPECIES_TO_HOENN(RAYQUAZA),
    SPECIES_TO_HOENN(LATIAS),
    SPECIES_TO_HOENN(LATIOS),
    SPECIES_TO_HOENN(JIRACHI),
    SPECIES_TO_HOENN(DEOXYS),
    SPECIES_TO_HOENN(CHIMECHO),
    SPECIES_TO_HOENN(MIME_JR),
    SPECIES_TO_HOENN(MUNCHLAX),
    SPECIES_TO_HOENN(BONSLY),
    SPECIES_TO_HOENN(MANTYKE),
    SPECIES_TO_HOENN(HAPPINY),
    SPECIES_TO_HOENN(CHINGLING),
    SPECIES_TO_HOENN(BUDEW),
    SPECIES_TO_HOENN(ROSERADE),
    SPECIES_TO_HOENN(DUSKNOIR),
    SPECIES_TO_HOENN(AMBIPOM),
    SPECIES_TO_HOENN(ELECTIVIRE),
    SPECIES_TO_HOENN(FROSLASS),
    SPECIES_TO_HOENN(GALLADE),
    SPECIES_TO_HOENN(GLISCOR),
    SPECIES_TO_HOENN(HONCHKROW),
    SPECIES_TO_HOENN(LICKILICKY),
    SPECIES_TO_HOENN(MAGMORTAR),
    SPECIES_TO_HOENN(MAGNEZONE),
    SPECIES_TO_HOENN(MAMOSWINE),
    SPECIES_TO_HOENN(MISMAGIUS),
    SPECIES_TO_HOENN(PORYGON_Z),
    SPECIES_TO_HOENN(PROBOPASS),
    SPECIES_TO_HOENN(RHYPERIOR),
    SPECIES_TO_HOENN(TANGROWTH),
    SPECIES_TO_HOENN(TOGEKISS),
    SPECIES_TO_HOENN(WEAVILE),
    SPECIES_TO_HOENN(YANMEGA),
    SPECIES_TO_HOENN(LEAFEON),
    SPECIES_TO_HOENN(GLACEON),
    SPECIES_TO_HOENN(SYLVEON),
    SPECIES_TO_HOENN(REGIDRAGO),
    SPECIES_TO_HOENN(REGIELEKI),
    SPECIES_TO_HOENN(REGIGIGAS),
    SPECIES_TO_HOENN(ARCEUS),
    SPECIES_TO_HOENN(ANNIHILAPE),
    SPECIES_TO_HOENN(FARIGIRAF),
    SPECIES_TO_HOENN(DUDUNSPARCE),
    SPECIES_TO_HOENN(WYRDEER),
    SPECIES_TO_HOENN(URSALUNA),
    SPECIES_TO_HOENN(URSALUNA_BLOODMOON),
    SPECIES_TO_HOENN(KLEAVOR),
    //SPECIES_TO_HOENN(URSALUNA_BLOODMOON),
    //SPECIES_TO_HOENN(KLEAVOR),
    //SPECIES_TO_HOENN(UNUSED_SPACE5),
    //SPECIES_TO_HOENN(UNUSED_SPACE6),
    //SPECIES_TO_HOENN(UNUSED_SPACE7),
    //SPECIES_TO_HOENN(UNUSED_SPACE8),
    //SPECIES_TO_HOENN(UNUSED_SPACE9),
    //SPECIES_TO_HOENN(UNUSED_SPACE10),
    //SPECIES_TO_HOENN(DEOXYS_ATTACK),
    //SPECIES_TO_HOENN(DEOXYS_DEFENSE),
    //SPECIES_TO_HOENN(DEOXYS_SPEED),
};

// Assigns all species to the National Dex Index (Summary No. for National Dex)
static const u16 sSpeciesToNationalPokedexNum[NUM_SPECIES - 1] =
{
    SPECIES_TO_NATIONAL(BULBASAUR),
    SPECIES_TO_NATIONAL(IVYSAUR),
    SPECIES_TO_NATIONAL(VENUSAUR),
    SPECIES_TO_NATIONAL(CHARMANDER),
    SPECIES_TO_NATIONAL(CHARMELEON),
    SPECIES_TO_NATIONAL(CHARIZARD),
    SPECIES_TO_NATIONAL(SQUIRTLE),
    SPECIES_TO_NATIONAL(WARTORTLE),
    SPECIES_TO_NATIONAL(BLASTOISE),
    SPECIES_TO_NATIONAL(CATERPIE),
    SPECIES_TO_NATIONAL(METAPOD),
    SPECIES_TO_NATIONAL(BUTTERFREE),
    SPECIES_TO_NATIONAL(WEEDLE),
    SPECIES_TO_NATIONAL(KAKUNA),
    SPECIES_TO_NATIONAL(BEEDRILL),
    SPECIES_TO_NATIONAL(PIDGEY),
    SPECIES_TO_NATIONAL(PIDGEOTTO),
    SPECIES_TO_NATIONAL(PIDGEOT),
    SPECIES_TO_NATIONAL(RATTATA),
    SPECIES_TO_NATIONAL(RATICATE),
    SPECIES_TO_NATIONAL(SPEAROW),
    SPECIES_TO_NATIONAL(FEAROW),
    SPECIES_TO_NATIONAL(EKANS),
    SPECIES_TO_NATIONAL(ARBOK),
    SPECIES_TO_NATIONAL(PIKACHU),
    SPECIES_TO_NATIONAL(RAICHU),
    SPECIES_TO_NATIONAL(SANDSHREW),
    SPECIES_TO_NATIONAL(SANDSLASH),
    SPECIES_TO_NATIONAL(NIDORAN_F),
    SPECIES_TO_NATIONAL(NIDORINA),
    SPECIES_TO_NATIONAL(NIDOQUEEN),
    SPECIES_TO_NATIONAL(NIDORAN_M),
    SPECIES_TO_NATIONAL(NIDORINO),
    SPECIES_TO_NATIONAL(NIDOKING),
    SPECIES_TO_NATIONAL(CLEFAIRY),
    SPECIES_TO_NATIONAL(CLEFABLE),
    SPECIES_TO_NATIONAL(VULPIX),
    SPECIES_TO_NATIONAL(NINETALES),
    SPECIES_TO_NATIONAL(JIGGLYPUFF),
    SPECIES_TO_NATIONAL(WIGGLYTUFF),
    SPECIES_TO_NATIONAL(ZUBAT),
    SPECIES_TO_NATIONAL(GOLBAT),
    SPECIES_TO_NATIONAL(ODDISH),
    SPECIES_TO_NATIONAL(GLOOM),
    SPECIES_TO_NATIONAL(VILEPLUME),
    SPECIES_TO_NATIONAL(PARAS),
    SPECIES_TO_NATIONAL(PARASECT),
    SPECIES_TO_NATIONAL(VENONAT),
    SPECIES_TO_NATIONAL(VENOMOTH),
    SPECIES_TO_NATIONAL(DIGLETT),
    SPECIES_TO_NATIONAL(DUGTRIO),
    SPECIES_TO_NATIONAL(MEOWTH),
    SPECIES_TO_NATIONAL(PERSIAN),
    SPECIES_TO_NATIONAL(PSYDUCK),
    SPECIES_TO_NATIONAL(GOLDUCK),
    SPECIES_TO_NATIONAL(MANKEY),
    SPECIES_TO_NATIONAL(PRIMEAPE),
    SPECIES_TO_NATIONAL(GROWLITHE),
    SPECIES_TO_NATIONAL(ARCANINE),
    SPECIES_TO_NATIONAL(POLIWAG),
    SPECIES_TO_NATIONAL(POLIWHIRL),
    SPECIES_TO_NATIONAL(POLIWRATH),
    SPECIES_TO_NATIONAL(ABRA),
    SPECIES_TO_NATIONAL(KADABRA),
    SPECIES_TO_NATIONAL(ALAKAZAM),
    SPECIES_TO_NATIONAL(MACHOP),
    SPECIES_TO_NATIONAL(MACHOKE),
    SPECIES_TO_NATIONAL(MACHAMP),
    SPECIES_TO_NATIONAL(BELLSPROUT),
    SPECIES_TO_NATIONAL(WEEPINBELL),
    SPECIES_TO_NATIONAL(VICTREEBEL),
    SPECIES_TO_NATIONAL(TENTACOOL),
    SPECIES_TO_NATIONAL(TENTACRUEL),
    SPECIES_TO_NATIONAL(GEODUDE),
    SPECIES_TO_NATIONAL(GRAVELER),
    SPECIES_TO_NATIONAL(GOLEM),
    SPECIES_TO_NATIONAL(PONYTA),
    SPECIES_TO_NATIONAL(RAPIDASH),
    SPECIES_TO_NATIONAL(SLOWPOKE),
    SPECIES_TO_NATIONAL(SLOWBRO),
    SPECIES_TO_NATIONAL(MAGNEMITE),
    SPECIES_TO_NATIONAL(MAGNETON),
    SPECIES_TO_NATIONAL(FARFETCHD),
    SPECIES_TO_NATIONAL(DODUO),
    SPECIES_TO_NATIONAL(DODRIO),
    SPECIES_TO_NATIONAL(SEEL),
    SPECIES_TO_NATIONAL(DEWGONG),
    SPECIES_TO_NATIONAL(GRIMER),
    SPECIES_TO_NATIONAL(MUK),
    SPECIES_TO_NATIONAL(SHELLDER),
    SPECIES_TO_NATIONAL(CLOYSTER),
    SPECIES_TO_NATIONAL(GASTLY),
    SPECIES_TO_NATIONAL(HAUNTER),
    SPECIES_TO_NATIONAL(GENGAR),
    SPECIES_TO_NATIONAL(ONIX),
    SPECIES_TO_NATIONAL(DROWZEE),
    SPECIES_TO_NATIONAL(HYPNO),
    SPECIES_TO_NATIONAL(KRABBY),
    SPECIES_TO_NATIONAL(KINGLER),
    SPECIES_TO_NATIONAL(VOLTORB),
    SPECIES_TO_NATIONAL(ELECTRODE),
    SPECIES_TO_NATIONAL(EXEGGCUTE),
    SPECIES_TO_NATIONAL(EXEGGUTOR),
    SPECIES_TO_NATIONAL(CUBONE),
    SPECIES_TO_NATIONAL(MAROWAK),
    SPECIES_TO_NATIONAL(HITMONLEE),
    SPECIES_TO_NATIONAL(HITMONCHAN),
    SPECIES_TO_NATIONAL(LICKITUNG),
    SPECIES_TO_NATIONAL(KOFFING),
    SPECIES_TO_NATIONAL(WEEZING),
    SPECIES_TO_NATIONAL(RHYHORN),
    SPECIES_TO_NATIONAL(RHYDON),
    SPECIES_TO_NATIONAL(CHANSEY),
    SPECIES_TO_NATIONAL(TANGELA),
    SPECIES_TO_NATIONAL(KANGASKHAN),
    SPECIES_TO_NATIONAL(HORSEA),
    SPECIES_TO_NATIONAL(SEADRA),
    SPECIES_TO_NATIONAL(GOLDEEN),
    SPECIES_TO_NATIONAL(SEAKING),
    SPECIES_TO_NATIONAL(STARYU),
    SPECIES_TO_NATIONAL(STARMIE),
    SPECIES_TO_NATIONAL(MR_MIME),
    SPECIES_TO_NATIONAL(SCYTHER),
    SPECIES_TO_NATIONAL(JYNX),
    SPECIES_TO_NATIONAL(ELECTABUZZ),
    SPECIES_TO_NATIONAL(MAGMAR),
    SPECIES_TO_NATIONAL(PINSIR),
    SPECIES_TO_NATIONAL(TAUROS),
    SPECIES_TO_NATIONAL(MAGIKARP),
    SPECIES_TO_NATIONAL(GYARADOS),
    SPECIES_TO_NATIONAL(LAPRAS),
    SPECIES_TO_NATIONAL(DITTO),
    SPECIES_TO_NATIONAL(EEVEE),
    SPECIES_TO_NATIONAL(VAPOREON),
    SPECIES_TO_NATIONAL(JOLTEON),
    SPECIES_TO_NATIONAL(FLAREON),
    SPECIES_TO_NATIONAL(PORYGON),
    SPECIES_TO_NATIONAL(OMANYTE),
    SPECIES_TO_NATIONAL(OMASTAR),
    SPECIES_TO_NATIONAL(KABUTO),
    SPECIES_TO_NATIONAL(KABUTOPS),
    SPECIES_TO_NATIONAL(AERODACTYL),
    SPECIES_TO_NATIONAL(SNORLAX),
    SPECIES_TO_NATIONAL(ARTICUNO),
    SPECIES_TO_NATIONAL(ZAPDOS),
    SPECIES_TO_NATIONAL(MOLTRES),
    SPECIES_TO_NATIONAL(DRATINI),
    SPECIES_TO_NATIONAL(DRAGONAIR),
    SPECIES_TO_NATIONAL(DRAGONITE),
    SPECIES_TO_NATIONAL(MEWTWO),
    SPECIES_TO_NATIONAL(MEW),
    SPECIES_TO_NATIONAL(CHIKORITA),
    SPECIES_TO_NATIONAL(BAYLEEF),
    SPECIES_TO_NATIONAL(MEGANIUM),
    SPECIES_TO_NATIONAL(CYNDAQUIL),
    SPECIES_TO_NATIONAL(QUILAVA),
    SPECIES_TO_NATIONAL(TYPHLOSION),
    SPECIES_TO_NATIONAL(TOTODILE),
    SPECIES_TO_NATIONAL(CROCONAW),
    SPECIES_TO_NATIONAL(FERALIGATR),
    SPECIES_TO_NATIONAL(SENTRET),
    SPECIES_TO_NATIONAL(FURRET),
    SPECIES_TO_NATIONAL(HOOTHOOT),
    SPECIES_TO_NATIONAL(NOCTOWL),
    SPECIES_TO_NATIONAL(LEDYBA),
    SPECIES_TO_NATIONAL(LEDIAN),
    SPECIES_TO_NATIONAL(SPINARAK),
    SPECIES_TO_NATIONAL(ARIADOS),
    SPECIES_TO_NATIONAL(CROBAT),
    SPECIES_TO_NATIONAL(CHINCHOU),
    SPECIES_TO_NATIONAL(LANTURN),
    SPECIES_TO_NATIONAL(PICHU),
    SPECIES_TO_NATIONAL(CLEFFA),
    SPECIES_TO_NATIONAL(IGGLYBUFF),
    SPECIES_TO_NATIONAL(TOGEPI),
    SPECIES_TO_NATIONAL(TOGETIC),
    SPECIES_TO_NATIONAL(NATU),
    SPECIES_TO_NATIONAL(XATU),
    SPECIES_TO_NATIONAL(MAREEP),
    SPECIES_TO_NATIONAL(FLAAFFY),
    SPECIES_TO_NATIONAL(AMPHAROS),
    SPECIES_TO_NATIONAL(BELLOSSOM),
    SPECIES_TO_NATIONAL(MARILL),
    SPECIES_TO_NATIONAL(AZUMARILL),
    SPECIES_TO_NATIONAL(SUDOWOODO),
    SPECIES_TO_NATIONAL(POLITOED),
    SPECIES_TO_NATIONAL(HOPPIP),
    SPECIES_TO_NATIONAL(SKIPLOOM),
    SPECIES_TO_NATIONAL(JUMPLUFF),
    SPECIES_TO_NATIONAL(AIPOM),
    SPECIES_TO_NATIONAL(SUNKERN),
    SPECIES_TO_NATIONAL(SUNFLORA),
    SPECIES_TO_NATIONAL(YANMA),
    SPECIES_TO_NATIONAL(WOOPER),
    SPECIES_TO_NATIONAL(QUAGSIRE),
    SPECIES_TO_NATIONAL(ESPEON),
    SPECIES_TO_NATIONAL(UMBREON),
    SPECIES_TO_NATIONAL(MURKROW),
    SPECIES_TO_NATIONAL(SLOWKING),
    SPECIES_TO_NATIONAL(MISDREAVUS),
    SPECIES_TO_NATIONAL(UNOWN),
    SPECIES_TO_NATIONAL(WOBBUFFET),
    SPECIES_TO_NATIONAL(GIRAFARIG),
    SPECIES_TO_NATIONAL(PINECO),
    SPECIES_TO_NATIONAL(FORRETRESS),
    SPECIES_TO_NATIONAL(DUNSPARCE),
    SPECIES_TO_NATIONAL(GLIGAR),
    SPECIES_TO_NATIONAL(STEELIX),
    SPECIES_TO_NATIONAL(SNUBBULL),
    SPECIES_TO_NATIONAL(GRANBULL),
    SPECIES_TO_NATIONAL(QWILFISH),
    SPECIES_TO_NATIONAL(SCIZOR),
    SPECIES_TO_NATIONAL(SHUCKLE),
    SPECIES_TO_NATIONAL(HERACROSS),
    SPECIES_TO_NATIONAL(SNEASEL),
    SPECIES_TO_NATIONAL(TEDDIURSA),
    SPECIES_TO_NATIONAL(URSARING),
    SPECIES_TO_NATIONAL(SLUGMA),
    SPECIES_TO_NATIONAL(MAGCARGO),
    SPECIES_TO_NATIONAL(SWINUB),
    SPECIES_TO_NATIONAL(PILOSWINE),
    SPECIES_TO_NATIONAL(CORSOLA),
    SPECIES_TO_NATIONAL(REMORAID),
    SPECIES_TO_NATIONAL(OCTILLERY),
    SPECIES_TO_NATIONAL(DELIBIRD),
    SPECIES_TO_NATIONAL(MANTINE),
    SPECIES_TO_NATIONAL(SKARMORY),
    SPECIES_TO_NATIONAL(HOUNDOUR),
    SPECIES_TO_NATIONAL(HOUNDOOM),
    SPECIES_TO_NATIONAL(KINGDRA),
    SPECIES_TO_NATIONAL(PHANPY),
    SPECIES_TO_NATIONAL(DONPHAN),
    SPECIES_TO_NATIONAL(PORYGON2),
    SPECIES_TO_NATIONAL(STANTLER),
    SPECIES_TO_NATIONAL(SMEARGLE),
    SPECIES_TO_NATIONAL(TYROGUE),
    SPECIES_TO_NATIONAL(HITMONTOP),
    SPECIES_TO_NATIONAL(SMOOCHUM),
    SPECIES_TO_NATIONAL(ELEKID),
    SPECIES_TO_NATIONAL(MAGBY),
    SPECIES_TO_NATIONAL(MILTANK),
    SPECIES_TO_NATIONAL(BLISSEY),
    SPECIES_TO_NATIONAL(RAIKOU),
    SPECIES_TO_NATIONAL(ENTEI),
    SPECIES_TO_NATIONAL(SUICUNE),
    SPECIES_TO_NATIONAL(LARVITAR),
    SPECIES_TO_NATIONAL(PUPITAR),
    SPECIES_TO_NATIONAL(TYRANITAR),
    SPECIES_TO_NATIONAL(LUGIA),
    SPECIES_TO_NATIONAL(HO_OH),
    SPECIES_TO_NATIONAL(CELEBI),
    SPECIES_TO_NATIONAL(OLD_UNOWN_B),
    SPECIES_TO_NATIONAL(OLD_UNOWN_C),
    SPECIES_TO_NATIONAL(OLD_UNOWN_D),
    SPECIES_TO_NATIONAL(OLD_UNOWN_E),
    SPECIES_TO_NATIONAL(OLD_UNOWN_F),
    SPECIES_TO_NATIONAL(OLD_UNOWN_G),
    SPECIES_TO_NATIONAL(OLD_UNOWN_H),
    SPECIES_TO_NATIONAL(OLD_UNOWN_I),
    SPECIES_TO_NATIONAL(OLD_UNOWN_J),
    SPECIES_TO_NATIONAL(OLD_UNOWN_K),
    SPECIES_TO_NATIONAL(OLD_UNOWN_L),
    SPECIES_TO_NATIONAL(OLD_UNOWN_M),
    SPECIES_TO_NATIONAL(OLD_UNOWN_N),
    SPECIES_TO_NATIONAL(OLD_UNOWN_O),
    SPECIES_TO_NATIONAL(OLD_UNOWN_P),
    SPECIES_TO_NATIONAL(OLD_UNOWN_Q),
    SPECIES_TO_NATIONAL(OLD_UNOWN_R),
    SPECIES_TO_NATIONAL(OLD_UNOWN_S),
    SPECIES_TO_NATIONAL(OLD_UNOWN_T),
    SPECIES_TO_NATIONAL(OLD_UNOWN_U),
    SPECIES_TO_NATIONAL(OLD_UNOWN_V),
    SPECIES_TO_NATIONAL(OLD_UNOWN_W),
    SPECIES_TO_NATIONAL(OLD_UNOWN_X),
    SPECIES_TO_NATIONAL(OLD_UNOWN_Y),
    SPECIES_TO_NATIONAL(OLD_UNOWN_Z),
    SPECIES_TO_NATIONAL(TREECKO),
    SPECIES_TO_NATIONAL(GROVYLE),
    SPECIES_TO_NATIONAL(SCEPTILE),
    SPECIES_TO_NATIONAL(TORCHIC),
    SPECIES_TO_NATIONAL(COMBUSKEN),
    SPECIES_TO_NATIONAL(BLAZIKEN),
    SPECIES_TO_NATIONAL(MUDKIP),
    SPECIES_TO_NATIONAL(MARSHTOMP),
    SPECIES_TO_NATIONAL(SWAMPERT),
    SPECIES_TO_NATIONAL(POOCHYENA),
    SPECIES_TO_NATIONAL(MIGHTYENA),
    SPECIES_TO_NATIONAL(ZIGZAGOON),
    SPECIES_TO_NATIONAL(LINOONE),
    SPECIES_TO_NATIONAL(WURMPLE),
    SPECIES_TO_NATIONAL(SILCOON),
    SPECIES_TO_NATIONAL(BEAUTIFLY),
    SPECIES_TO_NATIONAL(CASCOON),
    SPECIES_TO_NATIONAL(DUSTOX),
    SPECIES_TO_NATIONAL(LOTAD),
    SPECIES_TO_NATIONAL(LOMBRE),
    SPECIES_TO_NATIONAL(LUDICOLO),
    SPECIES_TO_NATIONAL(SEEDOT),
    SPECIES_TO_NATIONAL(NUZLEAF),
    SPECIES_TO_NATIONAL(SHIFTRY),
    SPECIES_TO_NATIONAL(NINCADA),
    SPECIES_TO_NATIONAL(NINJASK),
    SPECIES_TO_NATIONAL(SHEDINJA),
    SPECIES_TO_NATIONAL(TAILLOW),
    SPECIES_TO_NATIONAL(SWELLOW),
    SPECIES_TO_NATIONAL(SHROOMISH),
    SPECIES_TO_NATIONAL(BRELOOM),
    SPECIES_TO_NATIONAL(SPINDA),
    SPECIES_TO_NATIONAL(WINGULL),
    SPECIES_TO_NATIONAL(PELIPPER),
    SPECIES_TO_NATIONAL(SURSKIT),
    SPECIES_TO_NATIONAL(MASQUERAIN),
    SPECIES_TO_NATIONAL(WAILMER),
    SPECIES_TO_NATIONAL(WAILORD),
    SPECIES_TO_NATIONAL(SKITTY),
    SPECIES_TO_NATIONAL(DELCATTY),
    SPECIES_TO_NATIONAL(KECLEON),
    SPECIES_TO_NATIONAL(BALTOY),
    SPECIES_TO_NATIONAL(CLAYDOL),
    SPECIES_TO_NATIONAL(NOSEPASS),
    SPECIES_TO_NATIONAL(TORKOAL),
    SPECIES_TO_NATIONAL(SABLEYE),
    SPECIES_TO_NATIONAL(BARBOACH),
    SPECIES_TO_NATIONAL(WHISCASH),
    SPECIES_TO_NATIONAL(LUVDISC),
    SPECIES_TO_NATIONAL(CORPHISH),
    SPECIES_TO_NATIONAL(CRAWDAUNT),
    SPECIES_TO_NATIONAL(FEEBAS),
    SPECIES_TO_NATIONAL(MILOTIC),
    SPECIES_TO_NATIONAL(CARVANHA),
    SPECIES_TO_NATIONAL(SHARPEDO),
    SPECIES_TO_NATIONAL(TRAPINCH),
    SPECIES_TO_NATIONAL(VIBRAVA),
    SPECIES_TO_NATIONAL(FLYGON),
    SPECIES_TO_NATIONAL(MAKUHITA),
    SPECIES_TO_NATIONAL(HARIYAMA),
    SPECIES_TO_NATIONAL(ELECTRIKE),
    SPECIES_TO_NATIONAL(MANECTRIC),
    SPECIES_TO_NATIONAL(NUMEL),
    SPECIES_TO_NATIONAL(CAMERUPT),
    SPECIES_TO_NATIONAL(SPHEAL),
    SPECIES_TO_NATIONAL(SEALEO),
    SPECIES_TO_NATIONAL(WALREIN),
    SPECIES_TO_NATIONAL(CACNEA),
    SPECIES_TO_NATIONAL(CACTURNE),
    SPECIES_TO_NATIONAL(SNORUNT),
    SPECIES_TO_NATIONAL(GLALIE),
    SPECIES_TO_NATIONAL(LUNATONE),
    SPECIES_TO_NATIONAL(SOLROCK),
    SPECIES_TO_NATIONAL(AZURILL),
    SPECIES_TO_NATIONAL(SPOINK),
    SPECIES_TO_NATIONAL(GRUMPIG),
    SPECIES_TO_NATIONAL(PLUSLE),
    SPECIES_TO_NATIONAL(MINUN),
    SPECIES_TO_NATIONAL(MAWILE),
    SPECIES_TO_NATIONAL(MEDITITE),
    SPECIES_TO_NATIONAL(MEDICHAM),
    SPECIES_TO_NATIONAL(SWABLU),
    SPECIES_TO_NATIONAL(ALTARIA),
    SPECIES_TO_NATIONAL(WYNAUT),
    SPECIES_TO_NATIONAL(DUSKULL),
    SPECIES_TO_NATIONAL(DUSCLOPS),
    SPECIES_TO_NATIONAL(ROSELIA),
    SPECIES_TO_NATIONAL(SLAKOTH),
    SPECIES_TO_NATIONAL(VIGOROTH),
    SPECIES_TO_NATIONAL(SLAKING),
    SPECIES_TO_NATIONAL(GULPIN),
    SPECIES_TO_NATIONAL(SWALOT),
    SPECIES_TO_NATIONAL(TROPIUS),
    SPECIES_TO_NATIONAL(WHISMUR),
    SPECIES_TO_NATIONAL(LOUDRED),
    SPECIES_TO_NATIONAL(EXPLOUD),
    SPECIES_TO_NATIONAL(CLAMPERL),
    SPECIES_TO_NATIONAL(HUNTAIL),
    SPECIES_TO_NATIONAL(GOREBYSS),
    SPECIES_TO_NATIONAL(ABSOL),
    SPECIES_TO_NATIONAL(SHUPPET),
    SPECIES_TO_NATIONAL(BANETTE),
    SPECIES_TO_NATIONAL(SEVIPER),
    SPECIES_TO_NATIONAL(ZANGOOSE),
    SPECIES_TO_NATIONAL(RELICANTH),
    SPECIES_TO_NATIONAL(ARON),
    SPECIES_TO_NATIONAL(LAIRON),
    SPECIES_TO_NATIONAL(AGGRON),
    SPECIES_TO_NATIONAL(CASTFORM),
    SPECIES_TO_NATIONAL(VOLBEAT),
    SPECIES_TO_NATIONAL(ILLUMISE),
    SPECIES_TO_NATIONAL(LILEEP),
    SPECIES_TO_NATIONAL(CRADILY),
    SPECIES_TO_NATIONAL(ANORITH),
    SPECIES_TO_NATIONAL(ARMALDO),
    SPECIES_TO_NATIONAL(RALTS),
    SPECIES_TO_NATIONAL(KIRLIA),
    SPECIES_TO_NATIONAL(GARDEVOIR),
    SPECIES_TO_NATIONAL(BAGON),
    SPECIES_TO_NATIONAL(SHELGON),
    SPECIES_TO_NATIONAL(SALAMENCE),
    SPECIES_TO_NATIONAL(BELDUM),
    SPECIES_TO_NATIONAL(METANG),
    SPECIES_TO_NATIONAL(METAGROSS),
    SPECIES_TO_NATIONAL(REGIROCK),
    SPECIES_TO_NATIONAL(REGICE),
    SPECIES_TO_NATIONAL(REGISTEEL),
    SPECIES_TO_NATIONAL(KYOGRE),
    SPECIES_TO_NATIONAL(GROUDON),
    SPECIES_TO_NATIONAL(RAYQUAZA),
    SPECIES_TO_NATIONAL(LATIAS),
    SPECIES_TO_NATIONAL(LATIOS),
    SPECIES_TO_NATIONAL(JIRACHI),
    SPECIES_TO_NATIONAL(DEOXYS),
    SPECIES_TO_NATIONAL(CHIMECHO),
    SPECIES_TO_NATIONAL(MIME_JR),
    SPECIES_TO_NATIONAL(MUNCHLAX),
    SPECIES_TO_NATIONAL(BONSLY),
    SPECIES_TO_NATIONAL(MANTYKE),
    SPECIES_TO_NATIONAL(HAPPINY),
    SPECIES_TO_NATIONAL(CHINGLING),
    SPECIES_TO_NATIONAL(BUDEW),
    SPECIES_TO_NATIONAL(ROSERADE),
    SPECIES_TO_NATIONAL(DUSKNOIR),
    SPECIES_TO_NATIONAL(AMBIPOM),
    SPECIES_TO_NATIONAL(ELECTIVIRE),
    SPECIES_TO_NATIONAL(FROSLASS),
    SPECIES_TO_NATIONAL(GALLADE),
    SPECIES_TO_NATIONAL(GLISCOR),
    SPECIES_TO_NATIONAL(HONCHKROW),
    SPECIES_TO_NATIONAL(LICKILICKY),
    SPECIES_TO_NATIONAL(MAGMORTAR),
    SPECIES_TO_NATIONAL(MAGNEZONE),
    SPECIES_TO_NATIONAL(MAMOSWINE),
    SPECIES_TO_NATIONAL(MISMAGIUS),
    SPECIES_TO_NATIONAL(PORYGON_Z),
    SPECIES_TO_NATIONAL(PROBOPASS),
    SPECIES_TO_NATIONAL(RHYPERIOR),
    SPECIES_TO_NATIONAL(TANGROWTH),
    SPECIES_TO_NATIONAL(TOGEKISS),
    SPECIES_TO_NATIONAL(WEAVILE),
    SPECIES_TO_NATIONAL(YANMEGA),
    SPECIES_TO_NATIONAL(LEAFEON),
    SPECIES_TO_NATIONAL(GLACEON),
    SPECIES_TO_NATIONAL(SYLVEON),
    SPECIES_TO_NATIONAL(REGIDRAGO),
    SPECIES_TO_NATIONAL(REGIELEKI),
    SPECIES_TO_NATIONAL(REGIGIGAS),
    SPECIES_TO_NATIONAL(ARCEUS),
    SPECIES_TO_NATIONAL(ANNIHILAPE),
    SPECIES_TO_NATIONAL(FARIGIRAF),
    SPECIES_TO_NATIONAL(DUDUNSPARCE),
    SPECIES_TO_NATIONAL(WYRDEER),
    SPECIES_TO_NATIONAL(URSALUNA),
    SPECIES_TO_NATIONAL(URSALUNA_BLOODMOON),
    SPECIES_TO_NATIONAL(KLEAVOR),
    //SPECIES_TO_NATIONAL(URSALUNA_BLOODMOON),
    //SPECIES_TO_NATIONAL(KLEAVOR),
    //SPECIES_TO_NATIONAL(UNUSED_SPACE5),
    //SPECIES_TO_NATIONAL(UNUSED_SPACE6),
    //SPECIES_TO_NATIONAL(UNUSED_SPACE7),
    //SPECIES_TO_NATIONAL(UNUSED_SPACE8),
    //SPECIES_TO_NATIONAL(UNUSED_SPACE9),
    //SPECIES_TO_NATIONAL(UNUSED_SPACE10),
    //SPECIES_TO_NATIONAL(DEOXYS_ATTACK),
    //SPECIES_TO_NATIONAL(DEOXYS_DEFENSE),
    //SPECIES_TO_NATIONAL(DEOXYS_SPEED),
};

// Assigns all Hoenn Dex Indexes to a National Dex Index
static const u16 sHoennToNationalOrder[NUM_SPECIES - 1] =
=======
// NOTE: The order of the elements in the array below is irrelevant.
// To reorder the pokedex, see the values in include/constants/pokedex.h.

#define HOENN_TO_NATIONAL(name)     [HOENN_DEX_##name - 1] = NATIONAL_DEX_##name

// Assigns all Hoenn Dex Indexes to a National Dex Index
static const enum NationalDexOrder sHoennToNationalOrder[HOENN_DEX_COUNT - 1] =
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    HOENN_TO_NATIONAL(TREECKO),
    HOENN_TO_NATIONAL(GROVYLE),
    HOENN_TO_NATIONAL(SCEPTILE),
    HOENN_TO_NATIONAL(TORCHIC),
    HOENN_TO_NATIONAL(COMBUSKEN),
    HOENN_TO_NATIONAL(BLAZIKEN),
    HOENN_TO_NATIONAL(MUDKIP),
    HOENN_TO_NATIONAL(MARSHTOMP),
    HOENN_TO_NATIONAL(SWAMPERT),
    HOENN_TO_NATIONAL(POOCHYENA),
    HOENN_TO_NATIONAL(MIGHTYENA),
    HOENN_TO_NATIONAL(ZIGZAGOON),
    HOENN_TO_NATIONAL(LINOONE),
<<<<<<< HEAD
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GALARIAN_FORMS
    HOENN_TO_NATIONAL(OBSTAGOON),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(WURMPLE),
    HOENN_TO_NATIONAL(SILCOON),
    HOENN_TO_NATIONAL(BEAUTIFLY),
    HOENN_TO_NATIONAL(CASCOON),
    HOENN_TO_NATIONAL(DUSTOX),
    HOENN_TO_NATIONAL(LOTAD),
    HOENN_TO_NATIONAL(LOMBRE),
    HOENN_TO_NATIONAL(LUDICOLO),
    HOENN_TO_NATIONAL(SEEDOT),
    HOENN_TO_NATIONAL(NUZLEAF),
    HOENN_TO_NATIONAL(SHIFTRY),
    HOENN_TO_NATIONAL(TAILLOW),
    HOENN_TO_NATIONAL(SWELLOW),
    HOENN_TO_NATIONAL(WINGULL),
    HOENN_TO_NATIONAL(PELIPPER),
    HOENN_TO_NATIONAL(RALTS),
    HOENN_TO_NATIONAL(KIRLIA),
    HOENN_TO_NATIONAL(GARDEVOIR),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(GALLADE),
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_4_CROSS_EVOS
    HOENN_TO_NATIONAL(GALLADE),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(SURSKIT),
    HOENN_TO_NATIONAL(MASQUERAIN),
    HOENN_TO_NATIONAL(SHROOMISH),
    HOENN_TO_NATIONAL(BRELOOM),
    HOENN_TO_NATIONAL(SLAKOTH),
    HOENN_TO_NATIONAL(VIGOROTH),
    HOENN_TO_NATIONAL(SLAKING),
    HOENN_TO_NATIONAL(ABRA),
    HOENN_TO_NATIONAL(KADABRA),
    HOENN_TO_NATIONAL(ALAKAZAM),
    HOENN_TO_NATIONAL(NINCADA),
    HOENN_TO_NATIONAL(NINJASK),
    HOENN_TO_NATIONAL(SHEDINJA),
    HOENN_TO_NATIONAL(WHISMUR),
    HOENN_TO_NATIONAL(LOUDRED),
    HOENN_TO_NATIONAL(EXPLOUD),
    HOENN_TO_NATIONAL(MAKUHITA),
    HOENN_TO_NATIONAL(HARIYAMA),
    HOENN_TO_NATIONAL(GOLDEEN),
    HOENN_TO_NATIONAL(SEAKING),
    HOENN_TO_NATIONAL(MAGIKARP),
    HOENN_TO_NATIONAL(GYARADOS),
    HOENN_TO_NATIONAL(AZURILL),
    HOENN_TO_NATIONAL(MARILL),
    HOENN_TO_NATIONAL(AZUMARILL),
    HOENN_TO_NATIONAL(GEODUDE),
    HOENN_TO_NATIONAL(GRAVELER),
    HOENN_TO_NATIONAL(GOLEM),
    HOENN_TO_NATIONAL(NOSEPASS),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(PROBOPASS),
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_4_CROSS_EVOS
    HOENN_TO_NATIONAL(PROBOPASS),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(SKITTY),
    HOENN_TO_NATIONAL(DELCATTY),
    HOENN_TO_NATIONAL(ZUBAT),
    HOENN_TO_NATIONAL(GOLBAT),
    HOENN_TO_NATIONAL(CROBAT),
    HOENN_TO_NATIONAL(TENTACOOL),
    HOENN_TO_NATIONAL(TENTACRUEL),
    HOENN_TO_NATIONAL(SABLEYE),
    HOENN_TO_NATIONAL(MAWILE),
    HOENN_TO_NATIONAL(ARON),
    HOENN_TO_NATIONAL(LAIRON),
    HOENN_TO_NATIONAL(AGGRON),
    HOENN_TO_NATIONAL(MACHOP),
    HOENN_TO_NATIONAL(MACHOKE),
    HOENN_TO_NATIONAL(MACHAMP),
    HOENN_TO_NATIONAL(MEDITITE),
    HOENN_TO_NATIONAL(MEDICHAM),
    HOENN_TO_NATIONAL(ELECTRIKE),
    HOENN_TO_NATIONAL(MANECTRIC),
    HOENN_TO_NATIONAL(PLUSLE),
    HOENN_TO_NATIONAL(MINUN),
    HOENN_TO_NATIONAL(MAGNEMITE),
    HOENN_TO_NATIONAL(MAGNETON),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(MAGNEZONE),
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_4_CROSS_EVOS
    HOENN_TO_NATIONAL(MAGNEZONE),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(VOLTORB),
    HOENN_TO_NATIONAL(ELECTRODE),
    HOENN_TO_NATIONAL(VOLBEAT),
    HOENN_TO_NATIONAL(ILLUMISE),
    HOENN_TO_NATIONAL(ODDISH),
    HOENN_TO_NATIONAL(GLOOM),
    HOENN_TO_NATIONAL(VILEPLUME),
    HOENN_TO_NATIONAL(BELLOSSOM),
    HOENN_TO_NATIONAL(DODUO),
    HOENN_TO_NATIONAL(DODRIO),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(BUDEW),
    HOENN_TO_NATIONAL(ROSELIA),
    HOENN_TO_NATIONAL(ROSERADE),

=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_4_CROSS_EVOS
    HOENN_TO_NATIONAL(BUDEW),
    HOENN_TO_NATIONAL(ROSELIA),
    HOENN_TO_NATIONAL(ROSERADE),
#else
    HOENN_TO_NATIONAL(ROSELIA),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(GULPIN),
    HOENN_TO_NATIONAL(SWALOT),
    HOENN_TO_NATIONAL(CARVANHA),
    HOENN_TO_NATIONAL(SHARPEDO),
    HOENN_TO_NATIONAL(WAILMER),
    HOENN_TO_NATIONAL(WAILORD),
    HOENN_TO_NATIONAL(NUMEL),
    HOENN_TO_NATIONAL(CAMERUPT),
    HOENN_TO_NATIONAL(SLUGMA),
    HOENN_TO_NATIONAL(MAGCARGO),
    HOENN_TO_NATIONAL(TORKOAL),
    HOENN_TO_NATIONAL(GRIMER),
    HOENN_TO_NATIONAL(MUK),
    HOENN_TO_NATIONAL(KOFFING),
    HOENN_TO_NATIONAL(WEEZING),
    HOENN_TO_NATIONAL(SPOINK),
    HOENN_TO_NATIONAL(GRUMPIG),
    HOENN_TO_NATIONAL(SANDSHREW),
    HOENN_TO_NATIONAL(SANDSLASH),
    HOENN_TO_NATIONAL(SPINDA),
    HOENN_TO_NATIONAL(SKARMORY),
    HOENN_TO_NATIONAL(TRAPINCH),
    HOENN_TO_NATIONAL(VIBRAVA),
    HOENN_TO_NATIONAL(FLYGON),
    HOENN_TO_NATIONAL(CACNEA),
    HOENN_TO_NATIONAL(CACTURNE),
    HOENN_TO_NATIONAL(SWABLU),
    HOENN_TO_NATIONAL(ALTARIA),
    HOENN_TO_NATIONAL(ZANGOOSE),
    HOENN_TO_NATIONAL(SEVIPER),
    HOENN_TO_NATIONAL(LUNATONE),
    HOENN_TO_NATIONAL(SOLROCK),
    HOENN_TO_NATIONAL(BARBOACH),
    HOENN_TO_NATIONAL(WHISCASH),
    HOENN_TO_NATIONAL(CORPHISH),
    HOENN_TO_NATIONAL(CRAWDAUNT),
    HOENN_TO_NATIONAL(BALTOY),
    HOENN_TO_NATIONAL(CLAYDOL),
    HOENN_TO_NATIONAL(LILEEP),
    HOENN_TO_NATIONAL(CRADILY),
    HOENN_TO_NATIONAL(ANORITH),
    HOENN_TO_NATIONAL(ARMALDO),
    HOENN_TO_NATIONAL(IGGLYBUFF),
    HOENN_TO_NATIONAL(JIGGLYPUFF),
    HOENN_TO_NATIONAL(WIGGLYTUFF),
    HOENN_TO_NATIONAL(FEEBAS),
    HOENN_TO_NATIONAL(MILOTIC),
    HOENN_TO_NATIONAL(CASTFORM),
    HOENN_TO_NATIONAL(STARYU),
    HOENN_TO_NATIONAL(STARMIE),
    HOENN_TO_NATIONAL(KECLEON),
    HOENN_TO_NATIONAL(SHUPPET),
    HOENN_TO_NATIONAL(BANETTE),
    HOENN_TO_NATIONAL(DUSKULL),
    HOENN_TO_NATIONAL(DUSCLOPS),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(DUSKNOIR),
    HOENN_TO_NATIONAL(TROPIUS),
    HOENN_TO_NATIONAL(CHINGLING),
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_4_CROSS_EVOS
    HOENN_TO_NATIONAL(DUSKNOIR),
    HOENN_TO_NATIONAL(TROPIUS),
    HOENN_TO_NATIONAL(CHINGLING),
#else
    HOENN_TO_NATIONAL(TROPIUS),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(CHIMECHO),
    HOENN_TO_NATIONAL(ABSOL),
    HOENN_TO_NATIONAL(VULPIX),
    HOENN_TO_NATIONAL(NINETALES),
    HOENN_TO_NATIONAL(PICHU),
    HOENN_TO_NATIONAL(PIKACHU),
    HOENN_TO_NATIONAL(RAICHU),
    HOENN_TO_NATIONAL(PSYDUCK),
    HOENN_TO_NATIONAL(GOLDUCK),
    HOENN_TO_NATIONAL(WYNAUT),
    HOENN_TO_NATIONAL(WOBBUFFET),
    HOENN_TO_NATIONAL(NATU),
    HOENN_TO_NATIONAL(XATU),
    HOENN_TO_NATIONAL(GIRAFARIG),
<<<<<<< HEAD
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_9_CROSS_EVOS
    HOENN_TO_NATIONAL(FARIGIRAF),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(PHANPY),
    HOENN_TO_NATIONAL(DONPHAN),
    HOENN_TO_NATIONAL(PINSIR),
    HOENN_TO_NATIONAL(HERACROSS),
    HOENN_TO_NATIONAL(RHYHORN),
    HOENN_TO_NATIONAL(RHYDON),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(RHYPERIOR),
    HOENN_TO_NATIONAL(SNORUNT),
    HOENN_TO_NATIONAL(GLALIE),
    HOENN_TO_NATIONAL(FROSLASS),
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_4_CROSS_EVOS
    HOENN_TO_NATIONAL(RHYPERIOR),
#endif
    HOENN_TO_NATIONAL(SNORUNT),
    HOENN_TO_NATIONAL(GLALIE),
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GEN_4_CROSS_EVOS
    HOENN_TO_NATIONAL(FROSLASS),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(SPHEAL),
    HOENN_TO_NATIONAL(SEALEO),
    HOENN_TO_NATIONAL(WALREIN),
    HOENN_TO_NATIONAL(CLAMPERL),
    HOENN_TO_NATIONAL(HUNTAIL),
    HOENN_TO_NATIONAL(GOREBYSS),
    HOENN_TO_NATIONAL(RELICANTH),
    HOENN_TO_NATIONAL(CORSOLA),
<<<<<<< HEAD
=======
#if P_NEW_EVOS_IN_REGIONAL_DEX && P_GALARIAN_FORMS
    HOENN_TO_NATIONAL(CURSOLA),
#endif
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(CHINCHOU),
    HOENN_TO_NATIONAL(LANTURN),
    HOENN_TO_NATIONAL(LUVDISC),
    HOENN_TO_NATIONAL(HORSEA),
    HOENN_TO_NATIONAL(SEADRA),
    HOENN_TO_NATIONAL(KINGDRA),
    HOENN_TO_NATIONAL(BAGON),
    HOENN_TO_NATIONAL(SHELGON),
    HOENN_TO_NATIONAL(SALAMENCE),
    HOENN_TO_NATIONAL(BELDUM),
    HOENN_TO_NATIONAL(METANG),
    HOENN_TO_NATIONAL(METAGROSS),
    HOENN_TO_NATIONAL(REGIROCK),
    HOENN_TO_NATIONAL(REGICE),
    HOENN_TO_NATIONAL(REGISTEEL),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(REGIDRAGO),
    HOENN_TO_NATIONAL(REGIELEKI),
    HOENN_TO_NATIONAL(REGIGIGAS),
=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    HOENN_TO_NATIONAL(LATIAS),
    HOENN_TO_NATIONAL(LATIOS),
    HOENN_TO_NATIONAL(KYOGRE),
    HOENN_TO_NATIONAL(GROUDON),
    HOENN_TO_NATIONAL(RAYQUAZA),
    HOENN_TO_NATIONAL(JIRACHI),
    HOENN_TO_NATIONAL(DEOXYS),
<<<<<<< HEAD
    HOENN_TO_NATIONAL(BULBASAUR), // PokÃ©mon from here onwards are UNSEEN in the HoennDex.
    HOENN_TO_NATIONAL(IVYSAUR),
    HOENN_TO_NATIONAL(VENUSAUR),
    HOENN_TO_NATIONAL(CHARMANDER),
    HOENN_TO_NATIONAL(CHARMELEON),
    HOENN_TO_NATIONAL(CHARIZARD),
    HOENN_TO_NATIONAL(SQUIRTLE),
    HOENN_TO_NATIONAL(WARTORTLE),
    HOENN_TO_NATIONAL(BLASTOISE),
    HOENN_TO_NATIONAL(CATERPIE),
    HOENN_TO_NATIONAL(METAPOD),
    HOENN_TO_NATIONAL(BUTTERFREE),
    HOENN_TO_NATIONAL(WEEDLE),
    HOENN_TO_NATIONAL(KAKUNA),
    HOENN_TO_NATIONAL(BEEDRILL),
    HOENN_TO_NATIONAL(PIDGEY),
    HOENN_TO_NATIONAL(PIDGEOTTO),
    HOENN_TO_NATIONAL(PIDGEOT),
    HOENN_TO_NATIONAL(RATTATA),
    HOENN_TO_NATIONAL(RATICATE),
    HOENN_TO_NATIONAL(SPEAROW),
    HOENN_TO_NATIONAL(FEAROW),
    HOENN_TO_NATIONAL(EKANS),
    HOENN_TO_NATIONAL(ARBOK),
    HOENN_TO_NATIONAL(NIDORAN_F),
    HOENN_TO_NATIONAL(NIDORINA),
    HOENN_TO_NATIONAL(NIDOQUEEN),
    HOENN_TO_NATIONAL(NIDORAN_M),
    HOENN_TO_NATIONAL(NIDORINO),
    HOENN_TO_NATIONAL(NIDOKING),
    HOENN_TO_NATIONAL(CLEFAIRY),
    HOENN_TO_NATIONAL(CLEFABLE),
    HOENN_TO_NATIONAL(PARAS),
    HOENN_TO_NATIONAL(PARASECT),
    HOENN_TO_NATIONAL(VENONAT),
    HOENN_TO_NATIONAL(VENOMOTH),
    HOENN_TO_NATIONAL(DIGLETT),
    HOENN_TO_NATIONAL(DUGTRIO),
    HOENN_TO_NATIONAL(MEOWTH),
    HOENN_TO_NATIONAL(PERSIAN),
    HOENN_TO_NATIONAL(MANKEY),
    HOENN_TO_NATIONAL(PRIMEAPE),
    HOENN_TO_NATIONAL(GROWLITHE),
    HOENN_TO_NATIONAL(ARCANINE),
    HOENN_TO_NATIONAL(POLIWAG),
    HOENN_TO_NATIONAL(POLIWHIRL),
    HOENN_TO_NATIONAL(POLIWRATH),
    HOENN_TO_NATIONAL(BELLSPROUT),
    HOENN_TO_NATIONAL(WEEPINBELL),
    HOENN_TO_NATIONAL(VICTREEBEL),
    HOENN_TO_NATIONAL(PONYTA),
    HOENN_TO_NATIONAL(RAPIDASH),
    HOENN_TO_NATIONAL(SLOWPOKE),
    HOENN_TO_NATIONAL(SLOWBRO),
    HOENN_TO_NATIONAL(FARFETCHD),
    HOENN_TO_NATIONAL(SEEL),
    HOENN_TO_NATIONAL(DEWGONG),
    HOENN_TO_NATIONAL(SHELLDER),
    HOENN_TO_NATIONAL(CLOYSTER),
    HOENN_TO_NATIONAL(GASTLY),
    HOENN_TO_NATIONAL(HAUNTER),
    HOENN_TO_NATIONAL(GENGAR),
    HOENN_TO_NATIONAL(ONIX),
    HOENN_TO_NATIONAL(DROWZEE),
    HOENN_TO_NATIONAL(HYPNO),
    HOENN_TO_NATIONAL(KRABBY),
    HOENN_TO_NATIONAL(KINGLER),
    HOENN_TO_NATIONAL(EXEGGCUTE),
    HOENN_TO_NATIONAL(EXEGGUTOR),
    HOENN_TO_NATIONAL(CUBONE),
    HOENN_TO_NATIONAL(MAROWAK),
    HOENN_TO_NATIONAL(HITMONLEE),
    HOENN_TO_NATIONAL(HITMONCHAN),
    HOENN_TO_NATIONAL(LICKITUNG), 
    HOENN_TO_NATIONAL(CHANSEY),
    HOENN_TO_NATIONAL(TANGELA),
    HOENN_TO_NATIONAL(KANGASKHAN),
    HOENN_TO_NATIONAL(MR_MIME),
    HOENN_TO_NATIONAL(SCYTHER),
    HOENN_TO_NATIONAL(JYNX),
    HOENN_TO_NATIONAL(ELECTABUZZ),
    HOENN_TO_NATIONAL(MAGMAR),
    HOENN_TO_NATIONAL(TAUROS),
    HOENN_TO_NATIONAL(LAPRAS),
    HOENN_TO_NATIONAL(DITTO),
    HOENN_TO_NATIONAL(EEVEE),
    HOENN_TO_NATIONAL(VAPOREON),
    HOENN_TO_NATIONAL(JOLTEON),
    HOENN_TO_NATIONAL(FLAREON),
    HOENN_TO_NATIONAL(PORYGON),
    HOENN_TO_NATIONAL(OMANYTE),
    HOENN_TO_NATIONAL(OMASTAR),
    HOENN_TO_NATIONAL(KABUTO),
    HOENN_TO_NATIONAL(KABUTOPS),
    HOENN_TO_NATIONAL(AERODACTYL),
    HOENN_TO_NATIONAL(SNORLAX),
    HOENN_TO_NATIONAL(ARTICUNO),
    HOENN_TO_NATIONAL(ZAPDOS),
    HOENN_TO_NATIONAL(MOLTRES),
    HOENN_TO_NATIONAL(DRATINI),
    HOENN_TO_NATIONAL(DRAGONAIR),
    HOENN_TO_NATIONAL(DRAGONITE),
    HOENN_TO_NATIONAL(MEWTWO),
    HOENN_TO_NATIONAL(MEW),
    HOENN_TO_NATIONAL(CHIKORITA),
    HOENN_TO_NATIONAL(BAYLEEF),
    HOENN_TO_NATIONAL(MEGANIUM),
    HOENN_TO_NATIONAL(CYNDAQUIL),
    HOENN_TO_NATIONAL(QUILAVA),
    HOENN_TO_NATIONAL(TYPHLOSION),
    HOENN_TO_NATIONAL(TOTODILE),
    HOENN_TO_NATIONAL(CROCONAW),
    HOENN_TO_NATIONAL(FERALIGATR),
    HOENN_TO_NATIONAL(SENTRET),
    HOENN_TO_NATIONAL(FURRET),
    HOENN_TO_NATIONAL(HOOTHOOT),
    HOENN_TO_NATIONAL(NOCTOWL),
    HOENN_TO_NATIONAL(LEDYBA),
    HOENN_TO_NATIONAL(LEDIAN),
    HOENN_TO_NATIONAL(SPINARAK),
    HOENN_TO_NATIONAL(ARIADOS),
    HOENN_TO_NATIONAL(CLEFFA),
    HOENN_TO_NATIONAL(TOGEPI),
    HOENN_TO_NATIONAL(TOGETIC),
    HOENN_TO_NATIONAL(MAREEP),
    HOENN_TO_NATIONAL(FLAAFFY),
    HOENN_TO_NATIONAL(AMPHAROS),
    HOENN_TO_NATIONAL(SUDOWOODO),
    HOENN_TO_NATIONAL(POLITOED),
    HOENN_TO_NATIONAL(HOPPIP),
    HOENN_TO_NATIONAL(SKIPLOOM),
    HOENN_TO_NATIONAL(JUMPLUFF),
    HOENN_TO_NATIONAL(AIPOM),
    HOENN_TO_NATIONAL(SUNKERN),
    HOENN_TO_NATIONAL(SUNFLORA),
    HOENN_TO_NATIONAL(YANMA),
    HOENN_TO_NATIONAL(WOOPER),
    HOENN_TO_NATIONAL(QUAGSIRE),
    HOENN_TO_NATIONAL(ESPEON),
    HOENN_TO_NATIONAL(UMBREON),
    HOENN_TO_NATIONAL(MURKROW),
    HOENN_TO_NATIONAL(SLOWKING),
    HOENN_TO_NATIONAL(MISDREAVUS),
    HOENN_TO_NATIONAL(UNOWN),
    HOENN_TO_NATIONAL(PINECO),
    HOENN_TO_NATIONAL(FORRETRESS),
    HOENN_TO_NATIONAL(DUNSPARCE),
    HOENN_TO_NATIONAL(GLIGAR),
    HOENN_TO_NATIONAL(STEELIX),
    HOENN_TO_NATIONAL(SNUBBULL),
    HOENN_TO_NATIONAL(GRANBULL),
    HOENN_TO_NATIONAL(QWILFISH),
    HOENN_TO_NATIONAL(SCIZOR),
    HOENN_TO_NATIONAL(SHUCKLE),
    HOENN_TO_NATIONAL(SNEASEL),
    HOENN_TO_NATIONAL(TEDDIURSA),
    HOENN_TO_NATIONAL(URSARING),
    HOENN_TO_NATIONAL(SWINUB),
    HOENN_TO_NATIONAL(PILOSWINE),
    HOENN_TO_NATIONAL(REMORAID),
    HOENN_TO_NATIONAL(OCTILLERY),
    HOENN_TO_NATIONAL(DELIBIRD),
    HOENN_TO_NATIONAL(MANTINE),
    HOENN_TO_NATIONAL(HOUNDOUR),
    HOENN_TO_NATIONAL(HOUNDOOM),
    HOENN_TO_NATIONAL(PORYGON2),
    HOENN_TO_NATIONAL(STANTLER),
    HOENN_TO_NATIONAL(SMEARGLE),
    HOENN_TO_NATIONAL(TYROGUE),
    HOENN_TO_NATIONAL(HITMONTOP),
    HOENN_TO_NATIONAL(SMOOCHUM),
    HOENN_TO_NATIONAL(ELEKID),
    HOENN_TO_NATIONAL(MAGBY),
    HOENN_TO_NATIONAL(MILTANK),
    HOENN_TO_NATIONAL(BLISSEY),
    HOENN_TO_NATIONAL(RAIKOU),
    HOENN_TO_NATIONAL(ENTEI),
    HOENN_TO_NATIONAL(SUICUNE),
    HOENN_TO_NATIONAL(LARVITAR),
    HOENN_TO_NATIONAL(PUPITAR),
    HOENN_TO_NATIONAL(TYRANITAR),
    HOENN_TO_NATIONAL(LUGIA),
    HOENN_TO_NATIONAL(HO_OH),
    HOENN_TO_NATIONAL(CELEBI),
    HOENN_TO_NATIONAL(OLD_UNOWN_B),
    HOENN_TO_NATIONAL(OLD_UNOWN_C),
    HOENN_TO_NATIONAL(OLD_UNOWN_D),
    HOENN_TO_NATIONAL(OLD_UNOWN_E),
    HOENN_TO_NATIONAL(OLD_UNOWN_F),
    HOENN_TO_NATIONAL(OLD_UNOWN_G),
    HOENN_TO_NATIONAL(OLD_UNOWN_H),
    HOENN_TO_NATIONAL(OLD_UNOWN_I),
    HOENN_TO_NATIONAL(OLD_UNOWN_J),
    HOENN_TO_NATIONAL(OLD_UNOWN_K),
    HOENN_TO_NATIONAL(OLD_UNOWN_L),
    HOENN_TO_NATIONAL(OLD_UNOWN_M),
    HOENN_TO_NATIONAL(OLD_UNOWN_N),
    HOENN_TO_NATIONAL(OLD_UNOWN_O),
    HOENN_TO_NATIONAL(OLD_UNOWN_P),
    HOENN_TO_NATIONAL(OLD_UNOWN_Q),
    HOENN_TO_NATIONAL(OLD_UNOWN_R),
    HOENN_TO_NATIONAL(OLD_UNOWN_S),
    HOENN_TO_NATIONAL(OLD_UNOWN_T),
    HOENN_TO_NATIONAL(OLD_UNOWN_U),
    HOENN_TO_NATIONAL(OLD_UNOWN_V),
    HOENN_TO_NATIONAL(OLD_UNOWN_W),
    HOENN_TO_NATIONAL(OLD_UNOWN_X),
    HOENN_TO_NATIONAL(OLD_UNOWN_Y),
    HOENN_TO_NATIONAL(OLD_UNOWN_Z),
    HOENN_TO_NATIONAL(MIME_JR),
    HOENN_TO_NATIONAL(MUNCHLAX),
    HOENN_TO_NATIONAL(BONSLY),
    HOENN_TO_NATIONAL(MANTYKE),   
    HOENN_TO_NATIONAL(AMBIPOM),
    HOENN_TO_NATIONAL(ELECTIVIRE),
    HOENN_TO_NATIONAL(GLISCOR),
    HOENN_TO_NATIONAL(HAPPINY),
    HOENN_TO_NATIONAL(HONCHKROW),
    HOENN_TO_NATIONAL(LICKILICKY),
    HOENN_TO_NATIONAL(MAGMORTAR),
    HOENN_TO_NATIONAL(MAMOSWINE),
    HOENN_TO_NATIONAL(MISMAGIUS),
    HOENN_TO_NATIONAL(PORYGON_Z),
    HOENN_TO_NATIONAL(TANGROWTH),
    HOENN_TO_NATIONAL(TOGEKISS),
    HOENN_TO_NATIONAL(WEAVILE),
    HOENN_TO_NATIONAL(YANMEGA),
    HOENN_TO_NATIONAL(LEAFEON),
    HOENN_TO_NATIONAL(GLACEON),
    HOENN_TO_NATIONAL(SYLVEON),
    HOENN_TO_NATIONAL(ARCEUS),
    HOENN_TO_NATIONAL(ANNIHILAPE),
    HOENN_TO_NATIONAL(FARIGIRAF),
    HOENN_TO_NATIONAL(DUDUNSPARCE),
    HOENN_TO_NATIONAL(WYRDEER),
    HOENN_TO_NATIONAL(URSALUNA),
    HOENN_TO_NATIONAL(URSALUNA_BLOODMOON),
    HOENN_TO_NATIONAL(KLEAVOR),
    //HOENN_TO_NATIONAL(URSALUNA_BLOODMOON),
    //HOENN_TO_NATIONAL(KLEAVOR),
    //HOENN_TO_NATIONAL(UNUSED_SPACE5),
    //HOENN_TO_NATIONAL(UNUSED_SPACE6),
    //HOENN_TO_NATIONAL(UNUSED_SPACE7),
    //HOENN_TO_NATIONAL(UNUSED_SPACE8),
    //HOENN_TO_NATIONAL(UNUSED_SPACE9),
    //HOENN_TO_NATIONAL(UNUSED_SPACE10),
    //HOENN_TO_NATIONAL(DEOXYS_ATTACK),
    //HOENN_TO_NATIONAL(DEOXYS_DEFENSE),
    //HOENN_TO_NATIONAL(DEOXYS_SPEED),
=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
};

const struct SpindaSpot gSpindaSpotGraphics[] =
{
    {.x = 16, .y =  7, .image = INCBIN_U16("graphics/pokemon/spinda/spots/spot_0.1bpp")},
    {.x = 40, .y =  8, .image = INCBIN_U16("graphics/pokemon/spinda/spots/spot_1.1bpp")},
    {.x = 22, .y = 25, .image = INCBIN_U16("graphics/pokemon/spinda/spots/spot_2.1bpp")},
    {.x = 34, .y = 26, .image = INCBIN_U16("graphics/pokemon/spinda/spots/spot_3.1bpp")}
};

<<<<<<< HEAD
#include "data/pokemon/item_effects.h"

const s8 gNatureStatTable[NUM_NATURES][NUM_NATURE_STATS] =
{                      // Attack  Defense  Speed  Sp.Atk  Sp.Def
    [NATURE_HARDY]   = {    0,      0,      0,      0,      0   },
    [NATURE_LONELY]  = {   +1,     -1,      0,      0,      0   },
    [NATURE_BRAVE]   = {   +1,      0,     -1,      0,      0   },
    [NATURE_ADAMANT] = {   +1,      0,      0,     -1,      0   },
    [NATURE_NAUGHTY] = {   +1,      0,      0,      0,     -1   },
    [NATURE_BOLD]    = {   -1,     +1,      0,      0,      0   },
    [NATURE_DOCILE]  = {    0,      0,      0,      0,      0   },
    [NATURE_RELAXED] = {    0,     +1,     -1,      0,      0   },
    [NATURE_IMPISH]  = {    0,     +1,      0,     -1,      0   },
    [NATURE_LAX]     = {    0,     +1,      0,      0,     -1   },
    [NATURE_TIMID]   = {   -1,      0,     +1,      0,      0   },
    [NATURE_HASTY]   = {    0,     -1,     +1,      0,      0   },
    [NATURE_SERIOUS] = {    0,      0,      0,      0,      0   },
    [NATURE_JOLLY]   = {    0,      0,     +1,     -1,      0   },
    [NATURE_NAIVE]   = {    0,      0,     +1,      0,     -1   },
    [NATURE_MODEST]  = {   -1,      0,      0,     +1,      0   },
    [NATURE_MILD]    = {    0,     -1,      0,     +1,      0   },
    [NATURE_QUIET]   = {    0,      0,     -1,     +1,      0   },
    [NATURE_BASHFUL] = {    0,      0,      0,      0,      0   },
    [NATURE_RASH]    = {    0,      0,      0,     +1,     -1   },
    [NATURE_CALM]    = {   -1,      0,      0,      0,     +1   },
    [NATURE_GENTLE]  = {    0,     -1,      0,      0,     +1   },
    [NATURE_SASSY]   = {    0,      0,     -1,      0,     +1   },
    [NATURE_CAREFUL] = {    0,      0,      0,     -1,     +1   },
    [NATURE_QUIRKY]  = {    0,      0,      0,      0,      0   },
};

#include "data/pokemon/tmhm_learnsets.h"
#include "data/pokemon/trainer_class_lookups.h"
#include "data/pokemon/cry_ids.h"
#include "data/pokemon/experience_tables.h"
#include "data/pokemon/species_info.h"
#include "data/pokemon/level_up_learnsets.h"
#include "data/pokemon/level_up_learnsets_original.h"
#include "data/pokemon/evolution.h"
#include "data/pokemon/level_up_learnset_pointers.h"

// SPECIES_NONE are ignored in the following two tables, so decrement before accessing these arrays to get the right result

static const u8 sMonFrontAnimIdsTable[NUM_SPECIES - 1] =
{
    [SPECIES_BULBASAUR - 1]   = ANIM_V_JUMPS_H_JUMPS,
    [SPECIES_IVYSAUR - 1]     = ANIM_V_STRETCH,
    [SPECIES_VENUSAUR - 1]    = ANIM_ROTATE_UP_SLAM_DOWN,
    [SPECIES_CHARMANDER - 1]  = ANIM_V_JUMPS_SMALL,
    [SPECIES_CHARMELEON - 1]  = ANIM_BACK_AND_LUNGE,
    [SPECIES_CHARIZARD - 1]   = ANIM_V_SHAKE,
    [SPECIES_SQUIRTLE - 1]    = ANIM_SWING_CONCAVE,
    [SPECIES_WARTORTLE - 1]   = ANIM_SHRINK_GROW,
    [SPECIES_BLASTOISE - 1]   = ANIM_V_SHAKE_TWICE,
    [SPECIES_CATERPIE - 1]    = ANIM_SWING_CONCAVE,
    [SPECIES_METAPOD - 1]     = ANIM_SWING_CONCAVE,
    [SPECIES_BUTTERFREE - 1]  = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_WEEDLE - 1]      = ANIM_H_SLIDE_SLOW,
    [SPECIES_KAKUNA - 1]      = ANIM_GLOW_ORANGE,
    [SPECIES_BEEDRILL - 1]    = ANIM_H_VIBRATE,
    [SPECIES_PIDGEY - 1]      = ANIM_V_SLIDE_SLOW,
    [SPECIES_PIDGEOTTO - 1]   = ANIM_V_STRETCH,
    [SPECIES_PIDGEOT - 1]     = ANIM_FRONT_FLIP,
    [SPECIES_RATTATA - 1]     = ANIM_RAPID_H_HOPS,
    [SPECIES_RATICATE - 1]    = ANIM_FIGURE_8,
    [SPECIES_SPEAROW - 1]     = ANIM_RISING_WOBBLE,
    [SPECIES_FEAROW - 1]      = ANIM_FIGURE_8,
    [SPECIES_EKANS - 1]       = ANIM_H_STRETCH,
    [SPECIES_ARBOK - 1]       = ANIM_V_STRETCH,
    [SPECIES_PIKACHU - 1]     = ANIM_FLASH_YELLOW,
    [SPECIES_RAICHU - 1]      = ANIM_V_STRETCH,
    [SPECIES_SANDSHREW - 1]   = ANIM_SWING_CONCAVE_FAST_SHORT,
    [SPECIES_SANDSLASH - 1]   = ANIM_V_STRETCH,
    [SPECIES_NIDORAN_F - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_NIDORINA - 1]    = ANIM_V_STRETCH,
    [SPECIES_NIDOQUEEN - 1]   = ANIM_H_SHAKE,
    [SPECIES_NIDORAN_M - 1]   = ANIM_GROW_VIBRATE,
    [SPECIES_NIDORINO - 1]    = ANIM_SHRINK_GROW,
    [SPECIES_NIDOKING - 1]    = ANIM_H_SHAKE,
    [SPECIES_CLEFAIRY - 1]    = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_CLEFABLE - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL_SLOW,
    [SPECIES_VULPIX - 1]      = ANIM_V_STRETCH,
    [SPECIES_NINETALES - 1]   = ANIM_V_SHAKE,
    [SPECIES_JIGGLYPUFF - 1]  = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_WIGGLYTUFF - 1]  = ANIM_H_JUMPS,
    [SPECIES_ZUBAT - 1]       = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_GOLBAT - 1]      = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_ODDISH - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_GLOOM - 1]       = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_VILEPLUME - 1]   = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_PARAS - 1]       = ANIM_H_SLIDE_SLOW,
    [SPECIES_PARASECT - 1]    = ANIM_H_SHAKE,
    [SPECIES_VENONAT - 1]     = ANIM_V_JUMPS_H_JUMPS,
    [SPECIES_VENOMOTH - 1]    = ANIM_ZIGZAG_SLOW,
    [SPECIES_DIGLETT - 1]     = ANIM_V_SHAKE,
    [SPECIES_DUGTRIO - 1]     = ANIM_H_SHAKE_SLOW,
    [SPECIES_MEOWTH - 1]      = ANIM_V_JUMPS_SMALL,
    [SPECIES_PERSIAN - 1]     = ANIM_V_STRETCH,
    [SPECIES_PSYDUCK - 1]     = ANIM_V_JUMPS_H_JUMPS,
    [SPECIES_GOLDUCK - 1]     = ANIM_H_SHAKE_SLOW,
    [SPECIES_MANKEY - 1]      = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_PRIMEAPE - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_GROWLITHE - 1]   = ANIM_BACK_AND_LUNGE,
    [SPECIES_ARCANINE - 1]    = ANIM_H_VIBRATE,
    [SPECIES_POLIWAG - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_POLIWHIRL - 1]   = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_POLIWRATH - 1]   = ANIM_V_SHAKE_TWICE,
    [SPECIES_ABRA - 1]        = ANIM_H_JUMPS,
    [SPECIES_KADABRA - 1]     = ANIM_GROW_VIBRATE,
    [SPECIES_ALAKAZAM - 1]    = ANIM_V_STRETCH,
    [SPECIES_MACHOP - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MACHOKE - 1]     = ANIM_V_SHAKE,
    [SPECIES_MACHAMP - 1]     = ANIM_H_JUMPS,
    [SPECIES_BELLSPROUT - 1]  = ANIM_V_STRETCH,
    [SPECIES_WEEPINBELL - 1]  = ANIM_SWING_CONVEX,
    [SPECIES_VICTREEBEL - 1]  = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_TENTACOOL - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_TENTACRUEL - 1]  = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_GEODUDE - 1]     = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_GRAVELER - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_GOLEM - 1]       = ANIM_ROTATE_UP_SLAM_DOWN,
    [SPECIES_PONYTA - 1]      = ANIM_GLOW_ORANGE,
    [SPECIES_RAPIDASH - 1]    = ANIM_CIRCULAR_VIBRATE,
    [SPECIES_SLOWPOKE - 1]    = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_SLOWBRO - 1]     = ANIM_SWING_CONCAVE,
    [SPECIES_MAGNEMITE - 1]   = ANIM_TUMBLING_FRONT_FLIP_TWICE,
    [SPECIES_MAGNETON - 1]    = ANIM_FLASH_YELLOW,
    [SPECIES_FARFETCHD - 1]   = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_DODUO - 1]       = ANIM_H_SHAKE_SLOW,
    [SPECIES_DODRIO - 1]      = ANIM_LUNGE_GROW,
    [SPECIES_SEEL - 1]        = ANIM_SWING_CONCAVE,
    [SPECIES_DEWGONG - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_GRIMER - 1]      = ANIM_H_SLIDE_SLOW,
    [SPECIES_MUK - 1]         = ANIM_DEEP_V_SQUISH_AND_BOUNCE,
    [SPECIES_SHELLDER - 1]    = ANIM_TWIST,
    [SPECIES_CLOYSTER - 1]    = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_GASTLY - 1]      = ANIM_GLOW_BLACK,
    [SPECIES_HAUNTER - 1]     = ANIM_FLICKER_INCREASING,
    [SPECIES_GENGAR - 1]      = ANIM_GROW_IN_STAGES,
    [SPECIES_ONIX - 1]        = ANIM_RAPID_H_HOPS,
    [SPECIES_DROWZEE - 1]     = ANIM_CIRCLE_C_CLOCKWISE_SLOW,
    [SPECIES_HYPNO - 1]       = ANIM_GROW_VIBRATE,
    [SPECIES_KRABBY - 1]      = ANIM_H_SLIDE,
    [SPECIES_KINGLER - 1]     = ANIM_ZIGZAG_SLOW,
    [SPECIES_VOLTORB - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_ELECTRODE - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_EXEGGCUTE - 1]   = ANIM_H_SLIDE_SLOW,
    [SPECIES_EXEGGUTOR - 1]   = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_CUBONE - 1]      = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_MAROWAK - 1]     = ANIM_BOUNCE_ROTATE_TO_SIDES,
    [SPECIES_HITMONLEE - 1]   = ANIM_H_STRETCH,
    [SPECIES_HITMONCHAN - 1]  = ANIM_GROW_VIBRATE,
    [SPECIES_LICKITUNG - 1]   = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_KOFFING - 1]     = ANIM_SHRINK_GROW,
    [SPECIES_WEEZING - 1]     = ANIM_V_SLIDE,
    [SPECIES_RHYHORN - 1]     = ANIM_V_SHAKE,
    [SPECIES_RHYDON - 1]      = ANIM_SHRINK_GROW,
    [SPECIES_CHANSEY - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_TANGELA - 1]     = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_KANGASKHAN - 1]  = ANIM_V_STRETCH,
    [SPECIES_HORSEA - 1]      = ANIM_TWIST,
    [SPECIES_SEADRA - 1]      = ANIM_V_SLIDE,
    [SPECIES_GOLDEEN - 1]     = ANIM_SWING_CONVEX,
    [SPECIES_SEAKING - 1]     = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_STARYU - 1]      = ANIM_TWIST_TWICE,
    [SPECIES_STARMIE - 1]     = ANIM_TWIST,
    [SPECIES_MR_MIME - 1]     = ANIM_H_SLIDE_SLOW,
    [SPECIES_SCYTHER - 1]     = ANIM_H_VIBRATE,
    [SPECIES_JYNX - 1]        = ANIM_V_STRETCH,
    [SPECIES_ELECTABUZZ - 1]  = ANIM_FLASH_YELLOW,
    [SPECIES_MAGMAR - 1]      = ANIM_H_SHAKE,
    [SPECIES_PINSIR - 1]      = ANIM_GROW_VIBRATE,
    [SPECIES_TAUROS - 1]      = ANIM_V_SHAKE_TWICE,
    [SPECIES_MAGIKARP - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES,
    [SPECIES_GYARADOS - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_LAPRAS - 1]      = ANIM_V_STRETCH,
    [SPECIES_DITTO - 1]       = ANIM_CIRCULAR_STRETCH_TWICE,
    [SPECIES_EEVEE - 1]       = ANIM_V_STRETCH,
    [SPECIES_VAPOREON - 1]    = ANIM_V_STRETCH,
    [SPECIES_JOLTEON - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_FLAREON - 1]     = ANIM_V_STRETCH,
    [SPECIES_PORYGON - 1]     = ANIM_V_JUMPS_SMALL,
    [SPECIES_OMANYTE - 1]     = ANIM_V_SLIDE_WOBBLE_SMALL,
    [SPECIES_OMASTAR - 1]     = ANIM_GROW_VIBRATE,
    [SPECIES_KABUTO - 1]      = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_KABUTOPS - 1]    = ANIM_H_SHAKE,
    [SPECIES_AERODACTYL - 1]  = ANIM_V_SLIDE_SLOW,
    [SPECIES_SNORLAX - 1]     = ANIM_SWING_CONCAVE,
    [SPECIES_ARTICUNO - 1]    = ANIM_GROW_VIBRATE,
    [SPECIES_ZAPDOS - 1]      = ANIM_FLASH_YELLOW,
    [SPECIES_MOLTRES - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_DRATINI - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_DRAGONAIR - 1]   = ANIM_V_SHAKE,
    [SPECIES_DRAGONITE - 1]   = ANIM_V_SLIDE_SLOW,
    [SPECIES_MEWTWO - 1]      = ANIM_GROW_VIBRATE,
    [SPECIES_MEW - 1]         = ANIM_SWING_CONVEX,
    [SPECIES_CHIKORITA - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_BAYLEEF - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MEGANIUM - 1]    = ANIM_V_STRETCH,
    [SPECIES_CYNDAQUIL - 1]   = ANIM_V_JUMPS_SMALL,
    [SPECIES_QUILAVA - 1]     = ANIM_V_STRETCH,
    [SPECIES_TYPHLOSION - 1]  = ANIM_V_SHAKE,
    [SPECIES_TOTODILE - 1]    = ANIM_H_JUMPS,
    [SPECIES_CROCONAW - 1]    = ANIM_H_SHAKE,
    [SPECIES_FERALIGATR - 1]  = ANIM_H_SHAKE,
    [SPECIES_SENTRET - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_FURRET - 1]      = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_HOOTHOOT - 1]    = ANIM_V_SLIDE_SLOW,
    [SPECIES_NOCTOWL - 1]     = ANIM_V_STRETCH,
    [SPECIES_LEDYBA - 1]      = ANIM_V_JUMPS_SMALL,
    [SPECIES_LEDIAN - 1]      = ANIM_V_SLIDE_SLOW,
    [SPECIES_SPINARAK - 1]    = ANIM_CIRCLE_C_CLOCKWISE_SLOW,
    [SPECIES_ARIADOS - 1]     = ANIM_H_SHAKE,
    [SPECIES_CROBAT - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_CHINCHOU - 1]    = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_LANTURN - 1]     = ANIM_V_SLIDE_WOBBLE_SMALL,
    [SPECIES_PICHU - 1]       = ANIM_V_JUMPS_BIG,
    [SPECIES_CLEFFA - 1]      = ANIM_V_JUMPS_SMALL,
    [SPECIES_IGGLYBUFF - 1]   = ANIM_SWING_CONCAVE_FAST,
    [SPECIES_TOGEPI - 1]      = ANIM_SWING_CONCAVE,
    [SPECIES_TOGETIC - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_NATU - 1]        = ANIM_H_JUMPS,
    [SPECIES_XATU - 1]        = ANIM_GROW_VIBRATE,
    [SPECIES_MAREEP - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_FLAAFFY - 1]     = ANIM_V_JUMPS_BIG,
    [SPECIES_AMPHAROS - 1]    = ANIM_FLASH_YELLOW,
    [SPECIES_BELLOSSOM - 1]   = ANIM_SWING_CONCAVE,
    [SPECIES_MARILL - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_AZUMARILL - 1]   = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL_SLOW,
    [SPECIES_SUDOWOODO - 1]   = ANIM_H_SLIDE_SLOW,
    [SPECIES_POLITOED - 1]    = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_HOPPIP - 1]      = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_SKIPLOOM - 1]    = ANIM_RISING_WOBBLE,
    [SPECIES_JUMPLUFF - 1]    = ANIM_V_SLIDE_WOBBLE_SMALL,
    [SPECIES_AIPOM - 1]       = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_SUNKERN - 1]     = ANIM_V_JUMPS_SMALL,
    [SPECIES_SUNFLORA - 1]    = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_YANMA - 1]       = ANIM_FIGURE_8,
    [SPECIES_WOOPER - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_QUAGSIRE - 1]    = ANIM_H_STRETCH,
    [SPECIES_ESPEON - 1]      = ANIM_GROW_VIBRATE,
    [SPECIES_UMBREON - 1]     = ANIM_V_SHAKE,
    [SPECIES_MURKROW - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_SLOWKING - 1]    = ANIM_SHRINK_GROW,
    [SPECIES_MISDREAVUS - 1]  = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_UNOWN - 1]       = ANIM_ZIGZAG_FAST,
    [SPECIES_WOBBUFFET - 1]   = ANIM_DEEP_V_SQUISH_AND_BOUNCE,
    [SPECIES_GIRAFARIG - 1]   = ANIM_V_JUMPS_BIG,
    [SPECIES_PINECO - 1]      = ANIM_SWING_CONCAVE,
    [SPECIES_FORRETRESS - 1]  = ANIM_V_SHAKE,
    [SPECIES_DUNSPARCE - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_GLIGAR - 1]      = ANIM_SHRINK_GROW,
    [SPECIES_STEELIX - 1]     = ANIM_H_SHAKE,
    [SPECIES_SNUBBULL - 1]    = ANIM_V_STRETCH,
    [SPECIES_GRANBULL - 1]    = ANIM_V_SHAKE,
    [SPECIES_QWILFISH - 1]    = ANIM_GROW_IN_STAGES,
    [SPECIES_SCIZOR - 1]      = ANIM_H_VIBRATE,
    [SPECIES_SHUCKLE - 1]     = ANIM_SWING_CONCAVE,
    [SPECIES_HERACROSS - 1]   = ANIM_LUNGE_GROW,
    [SPECIES_SNEASEL - 1]     = ANIM_H_STRETCH,
    [SPECIES_TEDDIURSA - 1]   = ANIM_V_STRETCH,
    [SPECIES_URSARING - 1]    = ANIM_V_SHAKE,
    [SPECIES_SLUGMA - 1]      = ANIM_V_STRETCH,
    [SPECIES_MAGCARGO - 1]    = ANIM_V_STRETCH,
    [SPECIES_SWINUB - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_PILOSWINE - 1]   = ANIM_H_SHAKE,
    [SPECIES_CORSOLA - 1]     = ANIM_H_SLIDE,
    [SPECIES_REMORAID - 1]    = ANIM_V_JUMPS_SMALL,
    [SPECIES_OCTILLERY - 1]   = ANIM_V_STRETCH,
    [SPECIES_DELIBIRD - 1]    = ANIM_V_JUMPS_SMALL,
    [SPECIES_MANTINE - 1]     = ANIM_SWING_CONVEX,
    [SPECIES_SKARMORY - 1]    = ANIM_V_STRETCH,
    [SPECIES_HOUNDOUR - 1]    = ANIM_V_STRETCH,
    [SPECIES_HOUNDOOM - 1]    = ANIM_V_SHAKE,
    [SPECIES_KINGDRA - 1]     = ANIM_CIRCLE_INTO_BG,
    [SPECIES_PHANPY - 1]      = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_DONPHAN - 1]     = ANIM_V_SHAKE_TWICE,
    [SPECIES_PORYGON2 - 1]    = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_STANTLER - 1]    = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_SMEARGLE - 1]    = ANIM_H_JUMPS,
    [SPECIES_TYROGUE - 1]     = ANIM_H_STRETCH,
    [SPECIES_HITMONTOP - 1]   = ANIM_H_VIBRATE,
    [SPECIES_SMOOCHUM - 1]    = ANIM_GROW_VIBRATE,
    [SPECIES_ELEKID - 1]      = ANIM_FLASH_YELLOW,
    [SPECIES_MAGBY - 1]       = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MILTANK - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_BLISSEY - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_RAIKOU - 1]      = ANIM_FLASH_YELLOW,
    [SPECIES_ENTEI - 1]       = ANIM_GROW_VIBRATE,
    [SPECIES_SUICUNE - 1]     = ANIM_V_SHAKE,
    [SPECIES_LARVITAR - 1]    = ANIM_V_JUMPS_SMALL,
    [SPECIES_PUPITAR - 1]     = ANIM_V_SHAKE,
    [SPECIES_TYRANITAR - 1]   = ANIM_H_SHAKE,
    [SPECIES_LUGIA - 1]       = ANIM_GROW_IN_STAGES,
    [SPECIES_HO_OH - 1]       = ANIM_GROW_VIBRATE,
    [SPECIES_CELEBI - 1]      = ANIM_RISING_WOBBLE,
    [SPECIES_TREECKO - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_GROVYLE - 1]     = ANIM_V_STRETCH,
    [SPECIES_SCEPTILE - 1]    = ANIM_V_SHAKE,
    [SPECIES_TORCHIC - 1]     = ANIM_H_STRETCH,
    [SPECIES_COMBUSKEN - 1]   = ANIM_V_JUMPS_H_JUMPS,
    [SPECIES_BLAZIKEN - 1]    = ANIM_H_SHAKE,
    [SPECIES_MUDKIP - 1]      = ANIM_CIRCULAR_STRETCH_TWICE,
    [SPECIES_MARSHTOMP - 1]   = ANIM_V_SLIDE,
    [SPECIES_SWAMPERT - 1]    = ANIM_V_JUMPS_BIG,
    [SPECIES_POOCHYENA - 1]   = ANIM_V_SHAKE,
    [SPECIES_MIGHTYENA - 1]   = ANIM_V_SHAKE,
    [SPECIES_ZIGZAGOON - 1]   = ANIM_H_SLIDE,
    [SPECIES_LINOONE - 1]     = ANIM_GROW_VIBRATE,
    [SPECIES_WURMPLE - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_SILCOON - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_BEAUTIFLY - 1]   = ANIM_V_SLIDE,
    [SPECIES_CASCOON - 1]     = ANIM_V_SLIDE,
    [SPECIES_DUSTOX - 1]      = ANIM_V_JUMPS_H_JUMPS,
    [SPECIES_LOTAD - 1]       = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_LOMBRE - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_LUDICOLO - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_SEEDOT - 1]      = ANIM_BOUNCE_ROTATE_TO_SIDES,
    [SPECIES_NUZLEAF - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_SHIFTRY - 1]     = ANIM_H_VIBRATE,
    [SPECIES_NINCADA - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_NINJASK - 1]     = ANIM_H_SLIDE_SLOW,
    [SPECIES_SHEDINJA - 1]    = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_TAILLOW - 1]     = ANIM_V_JUMPS_BIG,
    [SPECIES_SWELLOW - 1]     = ANIM_CIRCULAR_STRETCH_TWICE,
    [SPECIES_SHROOMISH - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_BRELOOM - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_SPINDA - 1]      = ANIM_H_JUMPS,
    [SPECIES_WINGULL - 1]     = ANIM_H_PIVOT,
    [SPECIES_PELIPPER - 1]    = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_SURSKIT - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MASQUERAIN - 1]  = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_WAILMER - 1]     = ANIM_CIRCULAR_STRETCH_TWICE,
    [SPECIES_WAILORD - 1]     = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_SKITTY - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_DELCATTY - 1]    = ANIM_V_STRETCH,
    [SPECIES_KECLEON - 1]     = ANIM_FLICKER_INCREASING,
    [SPECIES_BALTOY - 1]      = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_CLAYDOL - 1]     = ANIM_V_SLIDE_WOBBLE_SMALL,
    [SPECIES_NOSEPASS - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_TORKOAL - 1]     = ANIM_V_STRETCH,
    [SPECIES_SABLEYE - 1]     = ANIM_GLOW_BLACK,
    [SPECIES_BARBOACH - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_WHISCASH - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_LUVDISC - 1]     = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_CORPHISH - 1]    = ANIM_V_SHAKE,
    [SPECIES_CRAWDAUNT - 1]   = ANIM_GROW_VIBRATE,
    [SPECIES_FEEBAS - 1]      = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_MILOTIC - 1]     = ANIM_GLOW_BLUE,
    [SPECIES_CARVANHA - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_SHARPEDO - 1]    = ANIM_H_JUMPS_V_STRETCH_TWICE,
    [SPECIES_TRAPINCH - 1]    = ANIM_V_SHAKE,
    [SPECIES_VIBRAVA - 1]     = ANIM_H_SHAKE,
    [SPECIES_FLYGON - 1]      = ANIM_ZIGZAG_SLOW,
    [SPECIES_MAKUHITA - 1]    = ANIM_SWING_CONCAVE,
    [SPECIES_HARIYAMA - 1]    = ANIM_ROTATE_UP_TO_SIDES,
    [SPECIES_ELECTRIKE - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MANECTRIC - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_NUMEL - 1]       = ANIM_V_SLIDE,
    [SPECIES_CAMERUPT - 1]    = ANIM_V_SHAKE,
    [SPECIES_SPHEAL - 1]      = ANIM_SPIN,
    [SPECIES_SEALEO - 1]      = ANIM_V_STRETCH,
    [SPECIES_WALREIN - 1]     = ANIM_H_SHAKE,
    [SPECIES_CACNEA - 1]      = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_CACTURNE - 1]    = ANIM_V_SLIDE,
    [SPECIES_SNORUNT - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_GLALIE - 1]      = ANIM_ZIGZAG_FAST,
    [SPECIES_LUNATONE - 1]    = ANIM_SWING_CONVEX_FAST,
    [SPECIES_SOLROCK - 1]     = ANIM_ROTATE_TO_SIDES_TWICE,
    [SPECIES_AZURILL - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_SPOINK - 1]      = ANIM_H_JUMPS_V_STRETCH_TWICE,
    [SPECIES_GRUMPIG - 1]     = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_PLUSLE - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MINUN - 1]       = ANIM_CIRCULAR_STRETCH_TWICE,
    [SPECIES_MAWILE - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MEDITITE - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES,
    [SPECIES_MEDICHAM - 1]    = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_SWABLU - 1]      = ANIM_V_SLIDE,
    [SPECIES_ALTARIA - 1]     = ANIM_H_STRETCH,
    [SPECIES_WYNAUT - 1]      = ANIM_H_JUMPS_V_STRETCH,
    [SPECIES_DUSKULL - 1]     = ANIM_ZIGZAG_FAST,
    [SPECIES_DUSCLOPS - 1]    = ANIM_H_VIBRATE,
    [SPECIES_ROSELIA - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_SLAKOTH - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_VIGOROTH - 1]    = ANIM_H_JUMPS,
    [SPECIES_SLAKING - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_GULPIN - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_SWALOT - 1]      = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_TROPIUS - 1]     = ANIM_V_SHAKE,
    [SPECIES_WHISMUR - 1]     = ANIM_H_SLIDE,
    [SPECIES_LOUDRED - 1]     = ANIM_BOUNCE_ROTATE_TO_SIDES_SLOW,
    [SPECIES_EXPLOUD - 1]     = ANIM_V_SHAKE_TWICE,
    [SPECIES_CLAMPERL - 1]    = ANIM_TWIST,
    [SPECIES_HUNTAIL - 1]     = ANIM_GROW_VIBRATE,
    [SPECIES_GOREBYSS - 1]    = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_ABSOL - 1]       = ANIM_CIRCULAR_VIBRATE,
    [SPECIES_SHUPPET - 1]     = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_BANETTE - 1]     = ANIM_SWING_CONVEX,
    [SPECIES_SEVIPER - 1]     = ANIM_V_STRETCH,
    [SPECIES_ZANGOOSE - 1]    = ANIM_GROW_VIBRATE,
    [SPECIES_RELICANTH - 1]   = ANIM_TIP_MOVE_FORWARD,
    [SPECIES_ARON - 1]        = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_LAIRON - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_AGGRON - 1]      = ANIM_V_SHAKE_TWICE,
    [SPECIES_CASTFORM - 1]    = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_VOLBEAT - 1]     = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_ILLUMISE - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES,
    [SPECIES_LILEEP - 1]      = ANIM_V_STRETCH,
    [SPECIES_CRADILY - 1]     = ANIM_V_SHAKE_TWICE,
    [SPECIES_ANORITH - 1]     = ANIM_TWIST,
    [SPECIES_ARMALDO - 1]     = ANIM_V_SHAKE,
    [SPECIES_RALTS - 1]       = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_KIRLIA - 1]      = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_GARDEVOIR - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_BAGON - 1]       = ANIM_V_SHAKE_TWICE,
    [SPECIES_SHELGON - 1]     = ANIM_V_SLIDE,
    [SPECIES_SALAMENCE - 1]   = ANIM_H_SHAKE,
    [SPECIES_BELDUM - 1]      = ANIM_H_SHAKE,
    [SPECIES_METANG - 1]      = ANIM_V_SLIDE,
    [SPECIES_METAGROSS - 1]   = ANIM_V_SHAKE,
    [SPECIES_REGIROCK - 1]    = ANIM_CIRCULAR_STRETCH_TWICE,
    [SPECIES_REGICE - 1]      = ANIM_FOUR_PETAL,
    [SPECIES_REGISTEEL - 1]   = ANIM_GROW_VIBRATE,
    [SPECIES_KYOGRE - 1]      = ANIM_SWING_CONCAVE_FAST_SHORT,
    [SPECIES_GROUDON - 1]     = ANIM_V_SHAKE,
    [SPECIES_RAYQUAZA - 1]    = ANIM_H_SHAKE,
    [SPECIES_LATIAS - 1]      = ANIM_SWING_CONCAVE_FAST_SHORT,
    [SPECIES_LATIOS - 1]      = ANIM_V_SHAKE,
    [SPECIES_JIRACHI - 1]     = ANIM_SWING_CONVEX,
    [SPECIES_DEOXYS - 1]      = ANIM_H_PIVOT,
    [SPECIES_CHIMECHO - 1]    = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_ARCEUS - 1]      = ANIM_GROW_VIBRATE,
    [SPECIES_AMBIPOM - 1]     = ANIM_BACK_AND_LUNGE,
    [SPECIES_BONSLY - 1]        = ANIM_BOUNCE_ROTATE_TO_SIDES,
    [SPECIES_BUDEW - 1]         = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_CHINGLING - 1]     = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_DEOXYS_ATTACK - 1]          = ANIM_GROW_VIBRATE,
    [SPECIES_DEOXYS_DEFENSE - 1]         = ANIM_GROW_VIBRATE,
    [SPECIES_DEOXYS_SPEED - 1]           = ANIM_GROW_VIBRATE,
    [SPECIES_DUSKNOIR - 1]      = ANIM_H_SLIDE,
    [SPECIES_ELECTIVIRE - 1]    = ANIM_GLOW_YELLOW,
    [SPECIES_FROSLASS - 1]      = ANIM_V_SLIDE_WOBBLE,
    [SPECIES_GALLADE - 1]       = ANIM_H_VIBRATE,
    [SPECIES_GLACEON - 1]       = ANIM_V_STRETCH,
    [SPECIES_GLISCOR - 1]       = ANIM_SWING_CONVEX,
    [SPECIES_HAPPINY - 1]       = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_HONCHKROW - 1]     = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_LEAFEON - 1]       = ANIM_SHRINK_GROW,
    [SPECIES_LICKILICKY - 1]    = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_MAGMORTAR - 1]     = ANIM_V_STRETCH,
    [SPECIES_MAGNEZONE - 1]     = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_MAMOSWINE - 1]     = ANIM_BACK_AND_LUNGE,
    [SPECIES_MANTYKE - 1]       = ANIM_TWIST_TWICE,
    [SPECIES_MISMAGIUS - 1]     = ANIM_H_SLIDE_WOBBLE,
    [SPECIES_MIME_JR - 1]       = ANIM_H_SLIDE_SLOW,
    [SPECIES_MUNCHLAX - 1]      = ANIM_V_SQUISH_AND_BOUNCE_SLOW,
    [SPECIES_PORYGON_Z - 1]     = ANIM_CIRCLE_C_CLOCKWISE_SLOW,
    [SPECIES_PROBOPASS - 1]     = ANIM_V_SLIDE,
    [SPECIES_REGIDRAGO - 1]     = ANIM_GLOW_RED,
    [SPECIES_REGIELEKI - 1]   = ANIM_SHAKE_FLASH_YELLOW_SLOW,
    [SPECIES_REGIGIGAS - 1]     = ANIM_V_SHAKE,
    [SPECIES_RHYPERIOR - 1]     = ANIM_V_SHAKE_TWICE,
    [SPECIES_ROSERADE - 1]      = ANIM_H_VIBRATE,
    [SPECIES_SYLVEON - 1]       = ANIM_SHRINK_GROW,
    [SPECIES_TANGROWTH - 1]     = ANIM_H_STRETCH,
    [SPECIES_TOGEKISS - 1]      = ANIM_SWING_CONVEX,
    [SPECIES_WEAVILE - 1]       = ANIM_H_VIBRATE,
    [SPECIES_YANMEGA - 1]       = ANIM_H_VIBRATE,
    [SPECIES_ANNIHILAPE - 1]    = ANIM_BOUNCE_ROTATE_TO_SIDES_SMALL,
    [SPECIES_FARIGIRAF - 1]     = ANIM_V_JUMPS_BIG,
    [SPECIES_DUDUNSPARCE - 1]   = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_WYRDEER - 1] = ANIM_V_SQUISH_AND_BOUNCE,
    [SPECIES_URSALUNA - 1] = ANIM_V_SHAKE,
    [SPECIES_URSALUNA_BLOODMOON - 1] = ANIM_V_SHAKE,
    [SPECIES_KLEAVOR - 1] = ANIM_H_VIBRATE,
    [SPECIES_UNUSED_SPACE5 - 1] = ANIM_H_VIBRATE,
    [SPECIES_UNUSED_SPACE6 - 1] = ANIM_H_VIBRATE,
    [SPECIES_UNUSED_SPACE7 - 1] = ANIM_H_VIBRATE,
    [SPECIES_UNUSED_SPACE8 - 1] = ANIM_H_VIBRATE,
    [SPECIES_UNUSED_SPACE9 - 1] = ANIM_H_VIBRATE,
    [SPECIES_UNUSED_SPACE10 - 1] = ANIM_H_VIBRATE,
};

static const u8 sMonAnimationDelayTable[NUM_SPECIES - 1] =
{
    [SPECIES_BLASTOISE - 1]  = 50,
    [SPECIES_WEEDLE - 1]     = 10,
    [SPECIES_KAKUNA - 1]     = 20,
    [SPECIES_BEEDRILL - 1]   = 35,
    [SPECIES_PIDGEOTTO - 1]  = 25,
    [SPECIES_FEAROW - 1]     = 2,
    [SPECIES_EKANS - 1]      = 30,
    [SPECIES_NIDORAN_F - 1]  = 28,
    [SPECIES_NIDOKING - 1]   = 25,
    [SPECIES_PARAS - 1]      = 10,
    [SPECIES_PARASECT - 1]   = 45,
    [SPECIES_VENONAT - 1]    = 20,
    [SPECIES_DIGLETT - 1]    = 25,
    [SPECIES_DUGTRIO - 1]    = 35,
    [SPECIES_MEOWTH - 1]     = 40,
    [SPECIES_PERSIAN - 1]    = 20,
    [SPECIES_MANKEY - 1]     = 20,
    [SPECIES_GROWLITHE - 1]  = 30,
    [SPECIES_ARCANINE - 1]   = 40,
    [SPECIES_POLIWHIRL - 1]  = 5,
    [SPECIES_WEEPINBELL - 1] = 3,
    [SPECIES_MUK - 1]        = 45,
    [SPECIES_SHELLDER - 1]   = 20,
    [SPECIES_HAUNTER - 1]    = 23,
    [SPECIES_DROWZEE - 1]    = 48,
    [SPECIES_HYPNO - 1]      = 40,
    [SPECIES_HITMONCHAN - 1] = 25,
    [SPECIES_SCYTHER - 1]    = 10,
    [SPECIES_TAUROS - 1]     = 10,
    [SPECIES_TYPHLOSION - 1] = 20,
    [SPECIES_FERALIGATR - 1] = 5,
    [SPECIES_NATU - 1]       = 30,
    [SPECIES_MAREEP - 1]     = 50,
    [SPECIES_AMPHAROS - 1]   = 10,
    [SPECIES_POLITOED - 1]   = 40,
    [SPECIES_DUNSPARCE - 1]  = 10,
    [SPECIES_STEELIX - 1]    = 45,
    [SPECIES_QWILFISH - 1]   = 39,
    [SPECIES_SCIZOR - 1]     = 19,
    [SPECIES_OCTILLERY - 1]  = 20,
    [SPECIES_SMOOCHUM - 1]   = 40,
    [SPECIES_TYRANITAR - 1]  = 10,
    [SPECIES_LUGIA - 1]      = 20,
    [SPECIES_WAILORD - 1]    = 10,
    [SPECIES_KECLEON - 1]    = 30,
    [SPECIES_MILOTIC - 1]    = 45,
    [SPECIES_SPHEAL - 1]     = 15,
    [SPECIES_SNORUNT - 1]    = 20,
    [SPECIES_GRUMPIG - 1]    = 15,
    [SPECIES_WYNAUT - 1]     = 15,
    [SPECIES_DUSCLOPS - 1]   = 30,
    [SPECIES_ABSOL - 1]      = 45,
    [SPECIES_SALAMENCE - 1]  = 70,
    [SPECIES_KYOGRE - 1]     = 60,
    [SPECIES_RAYQUAZA - 1]   = 60,
    //[SPECIES_REGIELEKI - 1]  = 30,
};
=======
// In Battle Palace, moves are chosen based on the pokemons nature rather than by the player
// Moves are grouped into "Attack", "Defense", or "Support" (see PALACE_MOVE_GROUP_*)
// Each nature has a certain percent chance of selecting a move from a particular group
// and a separate percent chance for each group when at or below 50% HP
// The table below doesn't list percentages for Support because you can subtract the other two
// Support percentages are listed in comments off to the side instead
#define PALACE_STYLE(atk, def, atkLow, defLow) {atk, atk + def, atkLow, atkLow + defLow}

const struct NatureInfo gNaturesInfo[NUM_NATURES] =
{
    [NATURE_HARDY] =
    {
        .name = COMPOUND_STRING("Hardy"),
        .statUp = STAT_ATK,
        .statDown = STAT_ATK,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_HARDY, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(61, 7, 61, 7), //32% support >= 50% HP, 32% support < 50% HP
        .battlePalaceFlavorText = B_MSG_EAGER_FOR_MORE,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_LONELY] =
    {
        .name = COMPOUND_STRING("Lonely"),
        .statUp = STAT_ATK,
        .statDown = STAT_DEF,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_LONELY, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlSupportHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(20, 25, 84, 8), //55%,  8%
        .battlePalaceFlavorText = B_MSG_GLINT_IN_EYE,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_BRAVE] =
    {
        .name = COMPOUND_STRING("Brave"),
        .statUp = STAT_ATK,
        .statDown = STAT_SPEED,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_BRAVE, AFFINE_TURN_UP},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighDefenseLow,
        .battlePalacePercents = PALACE_STYLE(70, 15, 32, 60), //15%, 8%
        .battlePalaceFlavorText = B_MSG_GETTING_IN_POS,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_ADAMANT] =
    {
        .name = COMPOUND_STRING("Adamant"),
        .statUp = STAT_ATK,
        .statDown = STAT_SPATK,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_ADAMANT, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(38, 31, 70, 15), //31%, 15%
        .battlePalaceFlavorText = B_MSG_GLINT_IN_EYE,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_NAUGHTY] =
    {
        .name = COMPOUND_STRING("Naughty"),
        .statUp = STAT_ATK,
        .statDown = STAT_SPDEF,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_NAUGHTY, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlDefenseHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(20, 70, 70, 22), //10%, 8%
        .battlePalaceFlavorText = B_MSG_GLINT_IN_EYE,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_BOLD] =
    {
        .name = COMPOUND_STRING("Bold"),
        .statUp = STAT_DEF,
        .statDown = STAT_ATK,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_BOLD, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlSupportHighDefenseLow,
        .battlePalacePercents = PALACE_STYLE(30, 20, 32, 58), //50%, 10%
        .battlePalaceFlavorText = B_MSG_GETTING_IN_POS,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_DOCILE] =
    {
        .name = COMPOUND_STRING("Docile"),
        .statUp = STAT_DEF,
        .statDown = STAT_DEF,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_DOCILE, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(56, 22, 56, 22), //22%, 22%
        .battlePalaceFlavorText = B_MSG_EAGER_FOR_MORE,
        .battlePalaceSmokescreen = PALACE_TARGET_RANDOM,
    },
    [NATURE_RELAXED] =
    {
        .name = COMPOUND_STRING("Relaxed"),
        .statUp = STAT_DEF,
        .statDown = STAT_SPEED,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_RELAXED, AFFINE_TURN_UP_AND_DOWN},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlSupportHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(25, 15, 75, 15), //60%, 10%
        .battlePalaceFlavorText = B_MSG_GLINT_IN_EYE,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_IMPISH] =
    {
        .name = COMPOUND_STRING("Impish"),
        .statUp = STAT_DEF,
        .statDown = STAT_SPATK,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_IMPISH, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighDefenseLow,
        .battlePalacePercents = PALACE_STYLE(69, 6, 28, 55), //25%, 17%
        .battlePalaceFlavorText = B_MSG_GETTING_IN_POS,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_LAX] =
    {
        .name = COMPOUND_STRING("Lax"),
        .statUp = STAT_DEF,
        .statDown = STAT_SPDEF,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_LAX, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlSupportHighSupportLow,
        .battlePalacePercents = PALACE_STYLE(35, 10, 29, 6), //55%, 65%
        .battlePalaceFlavorText = B_MSG_GROWL_DEEPLY,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_TIMID] =
    {
        .name = COMPOUND_STRING("Timid"),
        .statUp = STAT_SPEED,
        .statDown = STAT_ATK,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_TIMID, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighSupportLow,
        .battlePalacePercents = PALACE_STYLE(62, 10, 30, 20), //28%, 50%
        .battlePalaceFlavorText = B_MSG_GROWL_DEEPLY,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_HASTY] =
    {
        .name = COMPOUND_STRING("Hasty"),
        .statUp = STAT_SPEED,
        .statDown = STAT_DEF,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_HASTY, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(58, 37, 88, 6), //5%, 6%
        .battlePalaceFlavorText = B_MSG_GLINT_IN_EYE,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_SERIOUS] =
    {
        .name = COMPOUND_STRING("Serious"),
        .statUp = STAT_SPEED,
        .statDown = STAT_SPEED,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_SERIOUS, AFFINE_TURN_DOWN},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlSupportHighSupportLow,
        .battlePalacePercents = PALACE_STYLE(34, 11, 29, 11), //55%, 60%
        .battlePalaceFlavorText = B_MSG_EAGER_FOR_MORE,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_JOLLY] =
    {
        .name = COMPOUND_STRING("Jolly"),
        .statUp = STAT_SPEED,
        .statDown = STAT_SPATK,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_JOLLY, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlSupportHighDefenseLow,
        .battlePalacePercents = PALACE_STYLE(35, 5, 35, 60), //60%, 5%
        .battlePalaceFlavorText = B_MSG_GETTING_IN_POS,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_NAIVE] =
    {
        .name = COMPOUND_STRING("Naive"),
        .statUp = STAT_SPEED,
        .statDown = STAT_SPDEF,
        .backAnim = 0,
        .pokeBlockAnim = {ANIM_NAIVE, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(56, 22, 56, 22), //22%, 22%
        .battlePalaceFlavorText = B_MSG_EAGER_FOR_MORE,
        .battlePalaceSmokescreen = PALACE_TARGET_RANDOM,
    },
    [NATURE_MODEST] =
    {
        .name = COMPOUND_STRING("Modest"),
        .statUp = STAT_SPATK,
        .statDown = STAT_ATK,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_MODEST, AFFINE_TURN_DOWN_SLOW},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlDefenseHighDefenseLow,
        .battlePalacePercents = PALACE_STYLE(35, 45, 34, 60), //20%, 6%
        .battlePalaceFlavorText = B_MSG_GETTING_IN_POS,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_MILD] =
    {
        .name = COMPOUND_STRING("Mild"),
        .statUp = STAT_SPATK,
        .statDown = STAT_DEF,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_MILD, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlDefenseHighSupportLow,
        .battlePalacePercents = PALACE_STYLE(44, 50, 34, 6), //6%, 60%
        .battlePalaceFlavorText = B_MSG_GROWL_DEEPLY,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_QUIET] =
    {
        .name = COMPOUND_STRING("Quiet"),
        .statUp = STAT_SPATK,
        .statDown = STAT_SPEED,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_QUIET, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(56, 22, 56, 22), //22%, 22%
        .battlePalaceFlavorText = B_MSG_EAGER_FOR_MORE,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_BASHFUL] =
    {
        .name = COMPOUND_STRING("Bashful"),
        .statUp = STAT_SPATK,
        .statDown = STAT_SPATK,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_BASHFUL, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlDefenseHighDefenseLow,
        .battlePalacePercents = PALACE_STYLE(30, 58, 30, 58), //12%, 12%
        .battlePalaceFlavorText = B_MSG_EAGER_FOR_MORE,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_RASH] =
    {
        .name = COMPOUND_STRING("Rash"),
        .statUp = STAT_SPATK,
        .statDown = STAT_SPDEF,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_RASH, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlSupportHighSupportLow,
        .battlePalacePercents = PALACE_STYLE(30, 13, 27, 6), //57%, 67%
        .battlePalaceFlavorText = B_MSG_GROWL_DEEPLY,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_CALM] =
    {
        .name = COMPOUND_STRING("Calm"),
        .statUp = STAT_SPDEF,
        .statDown = STAT_ATK,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_CALM, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlDefenseHighDefenseLow,
        .battlePalacePercents = PALACE_STYLE(40, 50, 25, 62), //10%, 13%
        .battlePalaceFlavorText = B_MSG_GETTING_IN_POS,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_GENTLE] =
    {
        .name = COMPOUND_STRING("Gentle"),
        .statUp = STAT_SPDEF,
        .statDown = STAT_DEF,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_GENTLE, AFFINE_TURN_DOWN_SLIGHT},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlDefenseHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(18, 70, 90, 5), //12%, 5%
        .battlePalaceFlavorText = B_MSG_GLINT_IN_EYE,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
    [NATURE_SASSY] =
    {
        .name = COMPOUND_STRING("Sassy"),
        .statUp = STAT_SPDEF,
        .statDown = STAT_SPEED,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_SASSY, AFFINE_TURN_UP_HIGH},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighSupportLow,
        .battlePalacePercents = PALACE_STYLE(88, 6, 22, 20), //6%, 58%
        .battlePalaceFlavorText = B_MSG_GROWL_DEEPLY,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_CAREFUL] =
    {
        .name = COMPOUND_STRING("Careful"),
        .statUp = STAT_SPDEF,
        .statDown = STAT_SPATK,
        .backAnim = 2,
        .pokeBlockAnim = {ANIM_CAREFUL, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlDefenseHighSupportLow,
        .battlePalacePercents = PALACE_STYLE(42, 50, 42, 5), //8%, 53%
        .battlePalaceFlavorText = B_MSG_GROWL_DEEPLY,
        .battlePalaceSmokescreen = PALACE_TARGET_WEAKER,
    },
    [NATURE_QUIRKY] =
    {
        .name = COMPOUND_STRING("Quirky"),
        .statUp = STAT_SPDEF,
        .statDown = STAT_SPDEF,
        .backAnim = 1,
        .pokeBlockAnim = {ANIM_QUIRKY, AFFINE_NONE},
        .natureGirlMessage = BattleFrontier_Lounge5_Text_NatureGirlAttackHighAttackLow,
        .battlePalacePercents = PALACE_STYLE(56, 22, 56, 22), //22%, 22%
        .battlePalaceFlavorText = B_MSG_EAGER_FOR_MORE,
        .battlePalaceSmokescreen = PALACE_TARGET_STRONGER,
    },
};

#include "data/graphics/pokemon.h"

#include "data/pokemon/trainer_class_lookups.h"
#include "data/pokemon/experience_tables.h"

#if P_LVL_UP_LEARNSETS >= GEN_9
#include "data/pokemon/level_up_learnsets/gen_9.h" // Scarlet/Violet
#elif P_LVL_UP_LEARNSETS >= GEN_8
#include "data/pokemon/level_up_learnsets/gen_8.h" // Sword/Shield
#elif P_LVL_UP_LEARNSETS >= GEN_7
#include "data/pokemon/level_up_learnsets/gen_7.h" // Ultra Sun/Ultra Moon
#elif P_LVL_UP_LEARNSETS >= GEN_6
#include "data/pokemon/level_up_learnsets/gen_6.h" // Omega Ruby/Alpha Sapphire
#elif P_LVL_UP_LEARNSETS >= GEN_5
#include "data/pokemon/level_up_learnsets/gen_5.h" // Black 2/White 2
#elif P_LVL_UP_LEARNSETS >= GEN_4
#include "data/pokemon/level_up_learnsets/gen_4.h" // HeartGold/SoulSilver
#elif P_LVL_UP_LEARNSETS >= GEN_3
#include "data/pokemon/level_up_learnsets/gen_3.h" // Ruby/Sapphire/Emerald
#elif P_LVL_UP_LEARNSETS >= GEN_2
#include "data/pokemon/level_up_learnsets/gen_2.h" // Crystal
#elif P_LVL_UP_LEARNSETS >= GEN_1
#include "data/pokemon/level_up_learnsets/gen_1.h" // Yellow
#endif

#include "data/pokemon/teachable_learnsets.h"
#include "data/pokemon/egg_moves.h"
#include "data/pokemon/form_species_tables.h"
#include "data/pokemon/form_change_tables.h"
#include "data/pokemon/form_change_table_pointers.h"
#include "data/object_events/object_event_pic_tables_followers.h"

#include "data/pokemon/species_info.h"
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

#define PP_UP_SHIFTS(val)           val,        (val) << 2,        (val) << 4,        (val) << 6
#define PP_UP_SHIFTS_INV(val) (u8)~(val), (u8)~((val) << 2), (u8)~((val) << 4), (u8)~((val) << 6)

// PP Up bonuses are stored for a PokÃ©mon as a single byte.
// There are 2 bits (a value 0-3) for each move slot that
// represent how many PP Ups have been applied.
// The following arrays take a move slot id and return:
// gPPUpGetMask - A mask to get the number of PP Ups applied to that move slot
// gPPUpClearMask - A mask to clear the number of PP Ups applied to that move slot
// gPPUpAddValues - A value to add to the PP Bonuses byte to apply 1 PP Up to that move slot
const u8 gPPUpGetMask[MAX_MON_MOVES]   = {PP_UP_SHIFTS(3)};
const u8 gPPUpClearMask[MAX_MON_MOVES] = {PP_UP_SHIFTS_INV(3)};
const u8 gPPUpAddValues[MAX_MON_MOVES] = {PP_UP_SHIFTS(1)};

const u8 gStatStageRatios[MAX_STAT_STAGE + 1][2] =
{
    {10, 40}, // -6, MIN_STAT_STAGE
    {10, 35}, // -5
    {10, 30}, // -4
    {10, 25}, // -3
    {10, 20}, // -2
    {10, 15}, // -1
    {10, 10}, //  0, DEFAULT_STAT_STAGE
    {15, 10}, // +1
    {20, 10}, // +2
    {25, 10}, // +3
    {30, 10}, // +4
    {35, 10}, // +5
    {40, 10}, // +6, MAX_STAT_STAGE
};

<<<<<<< HEAD
static const u16 sDeoxysBaseStats[] =
{
    [STAT_HP]    = 50,
    [STAT_ATK]   = 95,
    [STAT_DEF]   = 90,
    [STAT_SPEED] = 180,
    [STAT_SPATK] = 95,
    [STAT_SPDEF] = 90,
};

=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
// The classes used by other players in the Union Room.
// These should correspond with the overworld graphics in sUnionRoomObjGfxIds
const u16 gUnionRoomFacilityClasses[NUM_UNION_ROOM_CLASSES * GENDER_COUNT] =
{
    // Male classes
    FACILITY_CLASS_COOLTRAINER_M,
    FACILITY_CLASS_BLACK_BELT,
    FACILITY_CLASS_CAMPER,
    FACILITY_CLASS_YOUNGSTER,
    FACILITY_CLASS_PSYCHIC_M,
    FACILITY_CLASS_BUG_CATCHER,
    FACILITY_CLASS_PKMN_BREEDER_M,
    FACILITY_CLASS_GUITARIST,
    // Female classes
    FACILITY_CLASS_COOLTRAINER_F,
    FACILITY_CLASS_HEX_MANIAC,
    FACILITY_CLASS_PICNICKER,
    FACILITY_CLASS_LASS,
    FACILITY_CLASS_PSYCHIC_F,
    FACILITY_CLASS_BATTLE_GIRL,
    FACILITY_CLASS_PKMN_BREEDER_F,
    FACILITY_CLASS_BEAUTY
};

<<<<<<< HEAD
static const u8 sHoldEffectToType[][2] =
{
    {HOLD_EFFECT_BUG_POWER, TYPE_BUG},
    {HOLD_EFFECT_STEEL_POWER, TYPE_STEEL},
    {HOLD_EFFECT_GROUND_POWER, TYPE_GROUND},
    {HOLD_EFFECT_ROCK_POWER, TYPE_ROCK},
    {HOLD_EFFECT_GRASS_POWER, TYPE_GRASS},
    {HOLD_EFFECT_DARK_POWER, TYPE_DARK},
    {HOLD_EFFECT_FIGHTING_POWER, TYPE_FIGHTING},
    {HOLD_EFFECT_ELECTRIC_POWER, TYPE_ELECTRIC},
    {HOLD_EFFECT_WATER_POWER, TYPE_WATER},
    {HOLD_EFFECT_FLYING_POWER, TYPE_FLYING},
    {HOLD_EFFECT_POISON_POWER, TYPE_POISON},
    {HOLD_EFFECT_ICE_POWER, TYPE_ICE},
    {HOLD_EFFECT_GHOST_POWER, TYPE_GHOST},
    {HOLD_EFFECT_PSYCHIC_POWER, TYPE_PSYCHIC},
    {HOLD_EFFECT_FIRE_POWER, TYPE_FIRE},
    {HOLD_EFFECT_DRAGON_POWER, TYPE_DRAGON},
    {HOLD_EFFECT_NORMAL_POWER, TYPE_NORMAL},
    {HOLD_EFFECT_FAIRY_POWER, TYPE_FAIRY},
};

=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
const struct SpriteTemplate gBattlerSpriteTemplates[MAX_BATTLERS_COUNT] =
{
    [B_POSITION_PLAYER_LEFT] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gBattlerPicTable_PlayerLeft,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [B_POSITION_OPPONENT_LEFT] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpriteOpponentSide,
        .anims = NULL,
        .images = gBattlerPicTable_OpponentLeft,
        .affineAnims = gAffineAnims_BattleSpriteOpponentSide,
        .callback = SpriteCB_WildMon,
    },
    [B_POSITION_PLAYER_RIGHT] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gBattlerPicTable_PlayerRight,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [B_POSITION_OPPONENT_RIGHT] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpriteOpponentSide,
        .anims = NULL,
        .images = gBattlerPicTable_OpponentRight,
        .affineAnims = gAffineAnims_BattleSpriteOpponentSide,
        .callback = SpriteCB_WildMon
    },
};

<<<<<<< HEAD
static const struct SpriteTemplate sTrainerBackSpriteTemplates[] =
{
    [TRAINER_BACK_PIC_BRENDAN] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_Brendan,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [TRAINER_BACK_PIC_MAY] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_May,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [TRAINER_BACK_PIC_RED] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_Red,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [TRAINER_BACK_PIC_LEAF] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_Leaf,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [TRAINER_BACK_PIC_RUBY_SAPPHIRE_BRENDAN] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_RubySapphireBrendan,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [TRAINER_BACK_PIC_RUBY_SAPPHIRE_MAY] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_RubySapphireMay,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [TRAINER_BACK_PIC_WALLY] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_Wally,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
    [TRAINER_BACK_PIC_STEVEN] = {
        .tileTag = TAG_NONE,
        .paletteTag = 0,
        .oam = &gOamData_BattleSpritePlayerSide,
        .anims = NULL,
        .images = gTrainerBackPicTable_Steven,
        .affineAnims = gAffineAnims_BattleSpritePlayerSide,
        .callback = SpriteCB_BattleSpriteStartSlideLeft,
    },
=======
static const struct SpriteTemplate sTrainerBackSpriteTemplate =
{
    .tileTag = TAG_NONE,
    .paletteTag = 0,
    .oam = &gOamData_BattleSpritePlayerSide,
    .anims = NULL,
    .images = NULL,
    .affineAnims = gAffineAnims_BattleSpritePlayerSide,
    .callback = SpriteCB_BattleSpriteStartSlideLeft,
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
};

#define NUM_SECRET_BASE_CLASSES 5
static const u8 sSecretBaseFacilityClasses[GENDER_COUNT][NUM_SECRET_BASE_CLASSES] =
{
    [MALE] = {
        FACILITY_CLASS_YOUNGSTER,
        FACILITY_CLASS_BUG_CATCHER,
        FACILITY_CLASS_RICH_BOY,
        FACILITY_CLASS_CAMPER,
        FACILITY_CLASS_COOLTRAINER_M
    },
    [FEMALE] = {
        FACILITY_CLASS_LASS,
        FACILITY_CLASS_SCHOOL_KID_F,
        FACILITY_CLASS_LADY,
        FACILITY_CLASS_PICNICKER,
        FACILITY_CLASS_COOLTRAINER_F
    }
};

static const u8 sGetMonDataEVConstants[] =
{
    MON_DATA_HP_EV,
    MON_DATA_ATK_EV,
    MON_DATA_DEF_EV,
    MON_DATA_SPEED_EV,
    MON_DATA_SPDEF_EV,
    MON_DATA_SPATK_EV
};

// For stat-raising items
static const u8 sStatsToRaise[] =
{
<<<<<<< HEAD
    STAT_ATK, STAT_ATK, STAT_SPEED, STAT_DEF, STAT_SPATK, STAT_ACC
=======
    STAT_ATK, STAT_ATK, STAT_DEF, STAT_SPEED, STAT_SPATK, STAT_SPDEF, STAT_ACC
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
};

// 3 modifiers each for how much to change friendship for different ranges
// 0-99, 100-199, 200+
static const s8 sFriendshipEventModifiers[][3] =
{
    [FRIENDSHIP_EVENT_GROW_LEVEL]      = { 5,  3,  2},
    [FRIENDSHIP_EVENT_VITAMIN]         = { 5,  3,  2},
    [FRIENDSHIP_EVENT_BATTLE_ITEM]     = { 1,  1,  0},
    [FRIENDSHIP_EVENT_LEAGUE_BATTLE]   = { 3,  2,  1},
    [FRIENDSHIP_EVENT_LEARN_TMHM]      = { 1,  1,  0},
    [FRIENDSHIP_EVENT_WALKING]         = { 1,  1,  1},
    [FRIENDSHIP_EVENT_FAINT_SMALL]     = {-1, -1, -1},
    [FRIENDSHIP_EVENT_FAINT_FIELD_PSN] = {-5, -5, -10},
    [FRIENDSHIP_EVENT_FAINT_LARGE]     = {-5, -5, -10},
<<<<<<< HEAD
    [FRIENDSHIP_EVENT_HAIRCUT1]        = {99,  99,  99},
    [FRIENDSHIP_EVENT_HAIRCUT2]        = {66,  66,  66},

};

#define HM_MOVES_END 0xFFFF

static const u16 sHMMoves[] =
{
    MOVE_CUT, MOVE_FLY, MOVE_SURF, MOVE_STRENGTH, MOVE_FLASH,
    MOVE_ROCK_SMASH, MOVE_WATERFALL, MOVE_DIVE, HM_MOVES_END
=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
};

static const struct SpeciesItem sAlteringCaveWildMonHeldItems[] =
{
    {SPECIES_NONE,      ITEM_NONE},
    {SPECIES_MAREEP,    ITEM_GANLON_BERRY},
    {SPECIES_PINECO,    ITEM_APICOT_BERRY},
    {SPECIES_HOUNDOUR,  ITEM_BIG_MUSHROOM},
    {SPECIES_TEDDIURSA, ITEM_PETAYA_BERRY},
    {SPECIES_AIPOM,     ITEM_BERRY_JUICE},
    {SPECIES_SHUCKLE,   ITEM_BERRY_JUICE},
    {SPECIES_STANTLER,  ITEM_PETAYA_BERRY},
    {SPECIES_SMEARGLE,  ITEM_SALAC_BERRY},
};

static const struct OamData sOamData_64x64 =
{
    .y = 0,
    .affineMode = ST_OAM_AFFINE_OFF,
    .objMode = ST_OAM_OBJ_NORMAL,
    .mosaic = FALSE,
    .bpp = ST_OAM_4BPP,
    .shape = SPRITE_SHAPE(64x64),
    .x = 0,
    .matrixNum = 0,
    .size = SPRITE_SIZE(64x64),
    .tileNum = 0,
    .priority = 0,
    .paletteNum = 0,
    .affineParam = 0
};

static const struct SpriteTemplate sSpriteTemplate_64x64 =
{
    .tileTag = TAG_NONE,
    .paletteTag = TAG_NONE,
    .oam = &sOamData_64x64,
    .anims = gDummySpriteAnimTable,
    .images = NULL,
    .affineAnims = gDummySpriteAffineAnimTable,
    .callback = SpriteCallbackDummy,
};

<<<<<<< HEAD
//*********************** //tx_randomizer_and_challenges
#define EVO_TYPE_0 0
#define EVO_TYPE_1 1
#define EVO_TYPE_2 2
#define EVO_TYPE_SELF 3
#define EVO_TYPE_LEGENDARY 4

const u8 gRandomizationTypes[7][25] =
{
    [TX_RANDOM_T_WILD_POKEMON]    = _("TX RANDOM WILD PKMN"),
    [TX_RANDOM_T_TRAINER]         = _("TX RANDOM TRAINER  "),
    [TX_RANDOM_T_MOVES]           = _("TX RANDOM MOVES    "),
    [TX_RANDOM_T_ABILITY]         = _("TX RANDOM ABILITY  "),
    [TX_RANDOM_T_EVO]             = _("TX RANDOM EVO      "),
    [TX_RANDOM_T_EVO_METH]        = _("TX RANDOM EVO METH "),
    [TX_RANDOM_T_STATIC]          = _("TX RANDOM STATIC   "),
};
const u8 gEvoStages[5][20] = 
{
    [EVO_TYPE_0]            = _("EVO TYPE 0"),
    [EVO_TYPE_1]            = _("EVO TYPE 1"),
    [EVO_TYPE_2]            = _("EVO TYPE 2"),
    [EVO_TYPE_SELF]         = _("EVO TYPE SELF"),
    [EVO_TYPE_LEGENDARY]    = _("EVO TYPE LEGENDARY"),
};

static const u8 gSpeciesMapping[NUM_SPECIES+1] =
{
    [SPECIES_NONE]              = EVO_TYPE_SELF,
    [SPECIES_BULBASAUR]         = EVO_TYPE_0,
    [SPECIES_IVYSAUR]           = EVO_TYPE_1,
    [SPECIES_VENUSAUR]          = EVO_TYPE_2,
    [SPECIES_CHARMANDER]        = EVO_TYPE_0,
    [SPECIES_CHARMELEON]        = EVO_TYPE_1,
    [SPECIES_CHARIZARD]         = EVO_TYPE_2,
    [SPECIES_SQUIRTLE]          = EVO_TYPE_0,
    [SPECIES_WARTORTLE]         = EVO_TYPE_1,
    [SPECIES_BLASTOISE]         = EVO_TYPE_2,
    [SPECIES_CATERPIE]          = EVO_TYPE_0,
    [SPECIES_METAPOD]           = EVO_TYPE_1,
    [SPECIES_BUTTERFREE]        = EVO_TYPE_2,
    [SPECIES_WEEDLE]            = EVO_TYPE_0,
    [SPECIES_KAKUNA]            = EVO_TYPE_1,
    [SPECIES_BEEDRILL]          = EVO_TYPE_2,
    [SPECIES_PIDGEY]            = EVO_TYPE_0,
    [SPECIES_PIDGEOTTO]         = EVO_TYPE_1,
    [SPECIES_PIDGEOT]           = EVO_TYPE_2,
    [SPECIES_RATTATA]           = EVO_TYPE_0,
    [SPECIES_RATICATE]          = EVO_TYPE_1,
    [SPECIES_SPEAROW]           = EVO_TYPE_0,
    [SPECIES_FEAROW]            = EVO_TYPE_1,
    [SPECIES_EKANS]             = EVO_TYPE_0,
    [SPECIES_ARBOK]             = EVO_TYPE_1,
    [SPECIES_PIKACHU]           = EVO_TYPE_1,
    [SPECIES_RAICHU]            = EVO_TYPE_2,
    [SPECIES_SANDSHREW]         = EVO_TYPE_0,
    [SPECIES_SANDSLASH]         = EVO_TYPE_1,
    [SPECIES_NIDORAN_F]         = EVO_TYPE_0,
    [SPECIES_NIDORINA]          = EVO_TYPE_1,
    [SPECIES_NIDOQUEEN]         = EVO_TYPE_2,
    [SPECIES_NIDORAN_M]         = EVO_TYPE_0,
    [SPECIES_NIDORINO]          = EVO_TYPE_1,
    [SPECIES_NIDOKING]          = EVO_TYPE_2,
    [SPECIES_CLEFAIRY]          = EVO_TYPE_1,
    [SPECIES_CLEFABLE]          = EVO_TYPE_2,
    [SPECIES_VULPIX]            = EVO_TYPE_0,
    [SPECIES_NINETALES]         = EVO_TYPE_1,
    [SPECIES_JIGGLYPUFF]        = EVO_TYPE_1,
    [SPECIES_WIGGLYTUFF]        = EVO_TYPE_2,
    [SPECIES_ZUBAT]             = EVO_TYPE_0,
    [SPECIES_GOLBAT]            = EVO_TYPE_1,
    [SPECIES_ODDISH]            = EVO_TYPE_0,
    [SPECIES_GLOOM]             = EVO_TYPE_1,
    [SPECIES_VILEPLUME]         = EVO_TYPE_2,
    [SPECIES_PARAS]             = EVO_TYPE_0,
    [SPECIES_PARASECT]          = EVO_TYPE_1,
    [SPECIES_VENONAT]           = EVO_TYPE_0,
    [SPECIES_VENOMOTH]          = EVO_TYPE_1,
    [SPECIES_DIGLETT]           = EVO_TYPE_0,
    [SPECIES_DUGTRIO]           = EVO_TYPE_1,
    [SPECIES_MEOWTH]            = EVO_TYPE_0,
    [SPECIES_PERSIAN]           = EVO_TYPE_1,
    [SPECIES_PSYDUCK]           = EVO_TYPE_0,
    [SPECIES_GOLDUCK]           = EVO_TYPE_1,
    [SPECIES_MANKEY]            = EVO_TYPE_0,
    [SPECIES_PRIMEAPE]          = EVO_TYPE_1,
    [SPECIES_GROWLITHE]         = EVO_TYPE_0,
    [SPECIES_ARCANINE]          = EVO_TYPE_1,
    [SPECIES_POLIWAG]           = EVO_TYPE_0,
    [SPECIES_POLIWHIRL]         = EVO_TYPE_1,
    [SPECIES_POLIWRATH]         = EVO_TYPE_2,
    [SPECIES_ABRA]              = EVO_TYPE_0,
    [SPECIES_KADABRA]           = EVO_TYPE_1,
    [SPECIES_ALAKAZAM]          = EVO_TYPE_2,
    [SPECIES_MACHOP]            = EVO_TYPE_0,
    [SPECIES_MACHOKE]           = EVO_TYPE_1,
    [SPECIES_MACHAMP]           = EVO_TYPE_2,
    [SPECIES_BELLSPROUT]        = EVO_TYPE_0,
    [SPECIES_WEEPINBELL]        = EVO_TYPE_1,
    [SPECIES_VICTREEBEL]        = EVO_TYPE_2,
    [SPECIES_TENTACOOL]         = EVO_TYPE_0,
    [SPECIES_TENTACRUEL]        = EVO_TYPE_1,
    [SPECIES_GEODUDE]           = EVO_TYPE_0,
    [SPECIES_GRAVELER]          = EVO_TYPE_1,
    [SPECIES_GOLEM]             = EVO_TYPE_2,
    [SPECIES_PONYTA]            = EVO_TYPE_0,
    [SPECIES_RAPIDASH]          = EVO_TYPE_1,
    [SPECIES_SLOWPOKE]          = EVO_TYPE_0,
    [SPECIES_SLOWBRO]           = EVO_TYPE_2,
    [SPECIES_MAGNEMITE]         = EVO_TYPE_0,
    [SPECIES_MAGNETON]          = EVO_TYPE_1,
    [SPECIES_FARFETCHD]         = EVO_TYPE_0,
    [SPECIES_DODUO]             = EVO_TYPE_0,
    [SPECIES_DODRIO]            = EVO_TYPE_1,
    [SPECIES_SEEL]              = EVO_TYPE_0,
    [SPECIES_DEWGONG]           = EVO_TYPE_1,
    [SPECIES_GRIMER]            = EVO_TYPE_0,
    [SPECIES_MUK]               = EVO_TYPE_1,
    [SPECIES_SHELLDER]          = EVO_TYPE_0,
    [SPECIES_CLOYSTER]          = EVO_TYPE_1,
    [SPECIES_GASTLY]            = EVO_TYPE_0,
    [SPECIES_HAUNTER]           = EVO_TYPE_1,
    [SPECIES_GENGAR]            = EVO_TYPE_2,
    [SPECIES_ONIX]              = EVO_TYPE_0,
    [SPECIES_DROWZEE]           = EVO_TYPE_0,
    [SPECIES_HYPNO]             = EVO_TYPE_1,
    [SPECIES_KRABBY]            = EVO_TYPE_0,
    [SPECIES_KINGLER]           = EVO_TYPE_1,
    [SPECIES_VOLTORB]           = EVO_TYPE_0,
    [SPECIES_ELECTRODE]         = EVO_TYPE_1,
    [SPECIES_EXEGGCUTE]         = EVO_TYPE_0,
    [SPECIES_EXEGGUTOR]         = EVO_TYPE_1,
    [SPECIES_CUBONE]            = EVO_TYPE_0,
    [SPECIES_MAROWAK]           = EVO_TYPE_1,
    [SPECIES_HITMONLEE]         = EVO_TYPE_1,
    [SPECIES_HITMONCHAN]        = EVO_TYPE_1,
    [SPECIES_LICKITUNG]         = EVO_TYPE_0,
    [SPECIES_KOFFING]           = EVO_TYPE_0,
    [SPECIES_WEEZING]           = EVO_TYPE_1,
    [SPECIES_RHYHORN]           = EVO_TYPE_0,
    [SPECIES_RHYDON]            = EVO_TYPE_1,
    [SPECIES_CHANSEY]           = EVO_TYPE_1,
    [SPECIES_TANGELA]           = EVO_TYPE_0,
    [SPECIES_KANGASKHAN]        = EVO_TYPE_0,
    [SPECIES_HORSEA]            = EVO_TYPE_0,
    [SPECIES_SEADRA]            = EVO_TYPE_1,
    [SPECIES_GOLDEEN]           = EVO_TYPE_0,
    [SPECIES_SEAKING]           = EVO_TYPE_1,
    [SPECIES_STARYU]            = EVO_TYPE_0,
    [SPECIES_STARMIE]           = EVO_TYPE_1,
    [SPECIES_MR_MIME]           = EVO_TYPE_1,
    [SPECIES_SCYTHER]           = EVO_TYPE_0,
    [SPECIES_JYNX]              = EVO_TYPE_1,
    [SPECIES_ELECTABUZZ]        = EVO_TYPE_1,
    [SPECIES_MAGMAR]            = EVO_TYPE_1,
    [SPECIES_PINSIR]            = EVO_TYPE_0,
    [SPECIES_TAUROS]            = EVO_TYPE_0,
    [SPECIES_MAGIKARP]          = EVO_TYPE_0,
    [SPECIES_GYARADOS]          = EVO_TYPE_2,
    [SPECIES_LAPRAS]            = EVO_TYPE_0,
    [SPECIES_DITTO]             = EVO_TYPE_0,
    [SPECIES_EEVEE]             = EVO_TYPE_0,
    [SPECIES_VAPOREON]          = EVO_TYPE_1,
    [SPECIES_JOLTEON]           = EVO_TYPE_1,
    [SPECIES_FLAREON]           = EVO_TYPE_1,
    [SPECIES_PORYGON]           = EVO_TYPE_0,
    [SPECIES_OMANYTE]           = EVO_TYPE_0,
    [SPECIES_OMASTAR]           = EVO_TYPE_1,
    [SPECIES_KABUTO]            = EVO_TYPE_0,
    [SPECIES_KABUTOPS]          = EVO_TYPE_1,
    [SPECIES_AERODACTYL]        = EVO_TYPE_0,
    [SPECIES_SNORLAX]           = EVO_TYPE_1,
    [SPECIES_ARTICUNO]          = EVO_TYPE_LEGENDARY,
    [SPECIES_ZAPDOS]            = EVO_TYPE_LEGENDARY,
    [SPECIES_MOLTRES]           = EVO_TYPE_LEGENDARY,
    [SPECIES_DRATINI]           = EVO_TYPE_0,
    [SPECIES_DRAGONAIR]         = EVO_TYPE_1,
    [SPECIES_DRAGONITE]         = EVO_TYPE_2,
    [SPECIES_MEWTWO]            = EVO_TYPE_LEGENDARY,
    [SPECIES_MEW]               = EVO_TYPE_LEGENDARY,
    [SPECIES_CHIKORITA]         = EVO_TYPE_0,
    [SPECIES_BAYLEEF]           = EVO_TYPE_1,
    [SPECIES_MEGANIUM]          = EVO_TYPE_2,
    [SPECIES_CYNDAQUIL]         = EVO_TYPE_0,
    [SPECIES_QUILAVA]           = EVO_TYPE_1,
    [SPECIES_TYPHLOSION]        = EVO_TYPE_2,
    [SPECIES_TOTODILE]          = EVO_TYPE_0,
    [SPECIES_CROCONAW]          = EVO_TYPE_1,
    [SPECIES_FERALIGATR]        = EVO_TYPE_2,
    [SPECIES_SENTRET]           = EVO_TYPE_0,
    [SPECIES_FURRET]            = EVO_TYPE_1,
    [SPECIES_HOOTHOOT]          = EVO_TYPE_0,
    [SPECIES_NOCTOWL]           = EVO_TYPE_1,
    [SPECIES_LEDYBA]            = EVO_TYPE_0,
    [SPECIES_LEDIAN]            = EVO_TYPE_1,
    [SPECIES_SPINARAK]          = EVO_TYPE_0,
    [SPECIES_ARIADOS]           = EVO_TYPE_1,
    [SPECIES_CROBAT]            = EVO_TYPE_2,
    [SPECIES_CHINCHOU]          = EVO_TYPE_0,
    [SPECIES_LANTURN]           = EVO_TYPE_1,
    [SPECIES_PICHU]             = EVO_TYPE_0,
    [SPECIES_CLEFFA]            = EVO_TYPE_0,
    [SPECIES_IGGLYBUFF]         = EVO_TYPE_0,
    [SPECIES_TOGEPI]            = EVO_TYPE_0,
    [SPECIES_TOGETIC]           = EVO_TYPE_1,
    [SPECIES_NATU]              = EVO_TYPE_0,
    [SPECIES_XATU]              = EVO_TYPE_1,
    [SPECIES_MAREEP]            = EVO_TYPE_0,
    [SPECIES_FLAAFFY]           = EVO_TYPE_1,
    [SPECIES_AMPHAROS]          = EVO_TYPE_2,
    [SPECIES_BELLOSSOM]         = EVO_TYPE_2,
    [SPECIES_MARILL]            = EVO_TYPE_1,
    [SPECIES_AZUMARILL]         = EVO_TYPE_2,
    [SPECIES_SUDOWOODO]         = EVO_TYPE_1,
    [SPECIES_POLITOED]          = EVO_TYPE_2,
    [SPECIES_HOPPIP]            = EVO_TYPE_0,
    [SPECIES_SKIPLOOM]          = EVO_TYPE_1,
    [SPECIES_JUMPLUFF]          = EVO_TYPE_2,
    [SPECIES_AIPOM]             = EVO_TYPE_0,
    [SPECIES_SUNKERN]           = EVO_TYPE_0,
    [SPECIES_SUNFLORA]          = EVO_TYPE_1,
    [SPECIES_YANMA]             = EVO_TYPE_0,
    [SPECIES_WOOPER]            = EVO_TYPE_0,
    [SPECIES_QUAGSIRE]          = EVO_TYPE_1,
    [SPECIES_ESPEON]            = EVO_TYPE_1,
    [SPECIES_UMBREON]           = EVO_TYPE_1,
    [SPECIES_MURKROW]           = EVO_TYPE_0,
    [SPECIES_SLOWKING]          = EVO_TYPE_2,
    [SPECIES_MISDREAVUS]        = EVO_TYPE_0,
    [SPECIES_UNOWN]             = EVO_TYPE_0,
    [SPECIES_WOBBUFFET]         = EVO_TYPE_1,
    [SPECIES_GIRAFARIG]         = EVO_TYPE_0,
    [SPECIES_PINECO]            = EVO_TYPE_0,
    [SPECIES_FORRETRESS]        = EVO_TYPE_1,
    [SPECIES_DUNSPARCE]         = EVO_TYPE_0,
    [SPECIES_GLIGAR]            = EVO_TYPE_0,
    [SPECIES_STEELIX]           = EVO_TYPE_1,
    [SPECIES_SNUBBULL]          = EVO_TYPE_0,
    [SPECIES_GRANBULL]          = EVO_TYPE_1,
    [SPECIES_QWILFISH]          = EVO_TYPE_0,
    [SPECIES_SCIZOR]            = EVO_TYPE_1,
    [SPECIES_SHUCKLE]           = EVO_TYPE_0,
    [SPECIES_HERACROSS]         = EVO_TYPE_0,
    [SPECIES_SNEASEL]           = EVO_TYPE_0,
    [SPECIES_TEDDIURSA]         = EVO_TYPE_0,
    [SPECIES_URSARING]          = EVO_TYPE_1,
    [SPECIES_SLUGMA]            = EVO_TYPE_0,
    [SPECIES_MAGCARGO]          = EVO_TYPE_1,
    [SPECIES_SWINUB]            = EVO_TYPE_0,
    [SPECIES_PILOSWINE]         = EVO_TYPE_1,
    [SPECIES_CORSOLA]           = EVO_TYPE_0,
    [SPECIES_REMORAID]          = EVO_TYPE_0,
    [SPECIES_OCTILLERY]         = EVO_TYPE_1,
    [SPECIES_DELIBIRD]          = EVO_TYPE_0,
    [SPECIES_MANTINE]           = EVO_TYPE_1,
    [SPECIES_SKARMORY]          = EVO_TYPE_0,
    [SPECIES_HOUNDOUR]          = EVO_TYPE_0,
    [SPECIES_HOUNDOOM]          = EVO_TYPE_1,
    [SPECIES_KINGDRA]           = EVO_TYPE_2,
    [SPECIES_PHANPY]            = EVO_TYPE_0,
    [SPECIES_DONPHAN]           = EVO_TYPE_1,
    [SPECIES_PORYGON2]          = EVO_TYPE_1,
    [SPECIES_STANTLER]          = EVO_TYPE_0,
    [SPECIES_SMEARGLE]          = EVO_TYPE_0,
    [SPECIES_TYROGUE]           = EVO_TYPE_0,
    [SPECIES_HITMONTOP]         = EVO_TYPE_1,
    [SPECIES_SMOOCHUM]          = EVO_TYPE_0,
    [SPECIES_ELEKID]            = EVO_TYPE_0,
    [SPECIES_MAGBY]             = EVO_TYPE_0,
    [SPECIES_MILTANK]           = EVO_TYPE_0,
    [SPECIES_BLISSEY]           = EVO_TYPE_2,
    [SPECIES_RAIKOU]            = EVO_TYPE_LEGENDARY,
    [SPECIES_ENTEI]             = EVO_TYPE_LEGENDARY,
    [SPECIES_SUICUNE]           = EVO_TYPE_LEGENDARY,
    [SPECIES_LARVITAR]          = EVO_TYPE_0,
    [SPECIES_PUPITAR]           = EVO_TYPE_1,
    [SPECIES_TYRANITAR]         = EVO_TYPE_2,
    [SPECIES_LUGIA]             = EVO_TYPE_LEGENDARY,
    [SPECIES_HO_OH]             = EVO_TYPE_LEGENDARY,
    [SPECIES_CELEBI]            = EVO_TYPE_LEGENDARY,
    [SPECIES_OLD_UNOWN_B]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_C]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_D]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_E]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_F]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_G]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_H]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_I]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_J]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_K]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_L]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_M]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_N]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_O]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_P]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_Q]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_R]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_S]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_T]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_U]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_V]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_W]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_X]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_Y]       = EVO_TYPE_SELF,
    [SPECIES_OLD_UNOWN_Z]       = EVO_TYPE_SELF,
    [SPECIES_TREECKO]           = EVO_TYPE_0,
    [SPECIES_GROVYLE]           = EVO_TYPE_1,
    [SPECIES_SCEPTILE]          = EVO_TYPE_2,
    [SPECIES_TORCHIC]           = EVO_TYPE_0,
    [SPECIES_COMBUSKEN]         = EVO_TYPE_1,
    [SPECIES_BLAZIKEN]          = EVO_TYPE_2,
    [SPECIES_MUDKIP]            = EVO_TYPE_0,
    [SPECIES_MARSHTOMP]         = EVO_TYPE_1,
    [SPECIES_SWAMPERT]          = EVO_TYPE_2,
    [SPECIES_POOCHYENA]         = EVO_TYPE_0,
    [SPECIES_MIGHTYENA]         = EVO_TYPE_1,
    [SPECIES_ZIGZAGOON]         = EVO_TYPE_0,
    [SPECIES_LINOONE]           = EVO_TYPE_1,
    [SPECIES_WURMPLE]           = EVO_TYPE_0,
    [SPECIES_SILCOON]           = EVO_TYPE_1,
    [SPECIES_BEAUTIFLY]         = EVO_TYPE_2,
    [SPECIES_CASCOON]           = EVO_TYPE_1,
    [SPECIES_DUSTOX]            = EVO_TYPE_2,
    [SPECIES_LOTAD]             = EVO_TYPE_0,
    [SPECIES_LOMBRE]            = EVO_TYPE_1,
    [SPECIES_LUDICOLO]          = EVO_TYPE_2,
    [SPECIES_SEEDOT]            = EVO_TYPE_0,
    [SPECIES_NUZLEAF]           = EVO_TYPE_1,
    [SPECIES_SHIFTRY]           = EVO_TYPE_2,
    [SPECIES_NINCADA]           = EVO_TYPE_0,
    [SPECIES_NINJASK]           = EVO_TYPE_1,
    [SPECIES_SHEDINJA]          = EVO_TYPE_1,
    [SPECIES_TAILLOW]           = EVO_TYPE_0,
    [SPECIES_SWELLOW]           = EVO_TYPE_1,
    [SPECIES_SHROOMISH]         = EVO_TYPE_0,
    [SPECIES_BRELOOM]           = EVO_TYPE_1,
    [SPECIES_SPINDA]            = EVO_TYPE_0,
    [SPECIES_WINGULL]           = EVO_TYPE_0,
    [SPECIES_PELIPPER]          = EVO_TYPE_1,
    [SPECIES_SURSKIT]           = EVO_TYPE_0,
    [SPECIES_MASQUERAIN]        = EVO_TYPE_1,
    [SPECIES_WAILMER]           = EVO_TYPE_0,
    [SPECIES_WAILORD]           = EVO_TYPE_1,
    [SPECIES_SKITTY]            = EVO_TYPE_0,
    [SPECIES_DELCATTY]          = EVO_TYPE_1,
    [SPECIES_KECLEON]           = EVO_TYPE_0,
    [SPECIES_BALTOY]            = EVO_TYPE_0,
    [SPECIES_CLAYDOL]           = EVO_TYPE_1,
    [SPECIES_NOSEPASS]          = EVO_TYPE_0,
    [SPECIES_TORKOAL]           = EVO_TYPE_0,
    [SPECIES_SABLEYE]           = EVO_TYPE_0,
    [SPECIES_BARBOACH]          = EVO_TYPE_0,
    [SPECIES_WHISCASH]          = EVO_TYPE_0,
    [SPECIES_LUVDISC]           = EVO_TYPE_0,
    [SPECIES_CORPHISH]          = EVO_TYPE_0,
    [SPECIES_CRAWDAUNT]         = EVO_TYPE_1,
    [SPECIES_FEEBAS]            = EVO_TYPE_0,
    [SPECIES_MILOTIC]           = EVO_TYPE_1,
    [SPECIES_CARVANHA]          = EVO_TYPE_0,
    [SPECIES_SHARPEDO]          = EVO_TYPE_1,
    [SPECIES_TRAPINCH]          = EVO_TYPE_0,
    [SPECIES_VIBRAVA]           = EVO_TYPE_1,
    [SPECIES_FLYGON]            = EVO_TYPE_2,
    [SPECIES_MAKUHITA]          = EVO_TYPE_0,
    [SPECIES_HARIYAMA]          = EVO_TYPE_1,
    [SPECIES_ELECTRIKE]         = EVO_TYPE_0,
    [SPECIES_MANECTRIC]         = EVO_TYPE_1,
    [SPECIES_NUMEL]             = EVO_TYPE_0,
    [SPECIES_CAMERUPT]          = EVO_TYPE_1,
    [SPECIES_SPHEAL]            = EVO_TYPE_0,
    [SPECIES_SEALEO]            = EVO_TYPE_1,
    [SPECIES_WALREIN]           = EVO_TYPE_2,
    [SPECIES_CACNEA]            = EVO_TYPE_0,
    [SPECIES_CACTURNE]          = EVO_TYPE_1,
    [SPECIES_SNORUNT]           = EVO_TYPE_0,
    [SPECIES_GLALIE]            = EVO_TYPE_1,
    [SPECIES_LUNATONE]          = EVO_TYPE_0,
    [SPECIES_SOLROCK]           = EVO_TYPE_0,
    [SPECIES_AZURILL]           = EVO_TYPE_0,
    [SPECIES_SPOINK]            = EVO_TYPE_0,
    [SPECIES_GRUMPIG]           = EVO_TYPE_1,
    [SPECIES_PLUSLE]            = EVO_TYPE_0,
    [SPECIES_MINUN]             = EVO_TYPE_0,
    [SPECIES_MAWILE]            = EVO_TYPE_0,
    [SPECIES_MEDITITE]          = EVO_TYPE_0,
    [SPECIES_MEDICHAM]          = EVO_TYPE_1,
    [SPECIES_SWABLU]            = EVO_TYPE_0,
    [SPECIES_ALTARIA]           = EVO_TYPE_1,
    [SPECIES_WYNAUT]            = EVO_TYPE_0,
    [SPECIES_DUSKULL]           = EVO_TYPE_0,
    [SPECIES_DUSCLOPS]          = EVO_TYPE_1,
    [SPECIES_ROSELIA]           = EVO_TYPE_1,
    [SPECIES_SLAKOTH]           = EVO_TYPE_0,
    [SPECIES_VIGOROTH]          = EVO_TYPE_1,
    [SPECIES_SLAKING]           = EVO_TYPE_2,
    [SPECIES_GULPIN]            = EVO_TYPE_0,
    [SPECIES_SWALOT]            = EVO_TYPE_1,
    [SPECIES_TROPIUS]           = EVO_TYPE_0,
    [SPECIES_WHISMUR]           = EVO_TYPE_0,
    [SPECIES_LOUDRED]           = EVO_TYPE_1,
    [SPECIES_EXPLOUD]           = EVO_TYPE_2,
    [SPECIES_CLAMPERL]          = EVO_TYPE_0,
    [SPECIES_HUNTAIL]           = EVO_TYPE_1,
    [SPECIES_GOREBYSS]          = EVO_TYPE_1,
    [SPECIES_ABSOL]             = EVO_TYPE_0,
    [SPECIES_SHUPPET]           = EVO_TYPE_0,
    [SPECIES_BANETTE]           = EVO_TYPE_1,
    [SPECIES_SEVIPER]           = EVO_TYPE_0,
    [SPECIES_ZANGOOSE]          = EVO_TYPE_0,
    [SPECIES_RELICANTH]         = EVO_TYPE_0,
    [SPECIES_ARON]              = EVO_TYPE_0,
    [SPECIES_LAIRON]            = EVO_TYPE_1,
    [SPECIES_AGGRON]            = EVO_TYPE_2,
    [SPECIES_CASTFORM]          = EVO_TYPE_SELF,
    [SPECIES_VOLBEAT]           = EVO_TYPE_1,
    [SPECIES_ILLUMISE]          = EVO_TYPE_1,
    [SPECIES_LILEEP]            = EVO_TYPE_0,
    [SPECIES_CRADILY]           = EVO_TYPE_1,
    [SPECIES_ANORITH]           = EVO_TYPE_0,
    [SPECIES_ARMALDO]           = EVO_TYPE_1,
    [SPECIES_RALTS]             = EVO_TYPE_0,
    [SPECIES_KIRLIA]            = EVO_TYPE_1,
    [SPECIES_GARDEVOIR]         = EVO_TYPE_2,
    [SPECIES_BAGON]             = EVO_TYPE_0,
    [SPECIES_SHELGON]           = EVO_TYPE_1,
    [SPECIES_SALAMENCE]         = EVO_TYPE_2,
    [SPECIES_BELDUM]            = EVO_TYPE_0,
    [SPECIES_METANG]            = EVO_TYPE_1,
    [SPECIES_METAGROSS]         = EVO_TYPE_2,
    [SPECIES_REGIROCK]          = EVO_TYPE_LEGENDARY,
    [SPECIES_REGICE]            = EVO_TYPE_LEGENDARY,
    [SPECIES_REGISTEEL]         = EVO_TYPE_LEGENDARY,
    [SPECIES_KYOGRE]            = EVO_TYPE_LEGENDARY,
    [SPECIES_GROUDON]           = EVO_TYPE_LEGENDARY,
    [SPECIES_RAYQUAZA]          = EVO_TYPE_LEGENDARY,
    [SPECIES_LATIAS]            = EVO_TYPE_LEGENDARY,
    [SPECIES_LATIOS]            = EVO_TYPE_LEGENDARY,
    [SPECIES_JIRACHI]           = EVO_TYPE_LEGENDARY,
    [SPECIES_DEOXYS]            = EVO_TYPE_LEGENDARY,
    [SPECIES_CHIMECHO]          = EVO_TYPE_1,
    [SPECIES_AMBIPOM]           = EVO_TYPE_1,
    [SPECIES_ARCEUS]            = EVO_TYPE_LEGENDARY,
    [SPECIES_BONSLY]            = EVO_TYPE_0,
    [SPECIES_BUDEW]             = EVO_TYPE_0,
    [SPECIES_CHINGLING]         = EVO_TYPE_0,
    [SPECIES_DUSKNOIR]          = EVO_TYPE_2,
    [SPECIES_ELECTIVIRE]        = EVO_TYPE_2,
    [SPECIES_FROSLASS]          = EVO_TYPE_1,
    [SPECIES_GALLADE]           = EVO_TYPE_2,
    [SPECIES_GLACEON]           = EVO_TYPE_1,
    [SPECIES_GLISCOR]           = EVO_TYPE_1,
    [SPECIES_HAPPINY]           = EVO_TYPE_0,
    [SPECIES_HONCHKROW]         = EVO_TYPE_1,
    [SPECIES_LEAFEON]           = EVO_TYPE_1,
    [SPECIES_LICKILICKY]        = EVO_TYPE_1,
    [SPECIES_MAGMORTAR]         = EVO_TYPE_2,
    [SPECIES_MAGNEZONE]         = EVO_TYPE_2,
    [SPECIES_MAMOSWINE]         = EVO_TYPE_2,
    [SPECIES_MANTYKE]           = EVO_TYPE_0,
    [SPECIES_MISMAGIUS]         = EVO_TYPE_1,
    [SPECIES_MIME_JR]           = EVO_TYPE_0,
    [SPECIES_MUNCHLAX]          = EVO_TYPE_0,
    [SPECIES_PORYGON_Z]         = EVO_TYPE_2,
    [SPECIES_PROBOPASS]         = EVO_TYPE_1,
    [SPECIES_REGIDRAGO]         = EVO_TYPE_LEGENDARY,
    [SPECIES_REGIELEKI]         = EVO_TYPE_LEGENDARY,
    [SPECIES_REGIGIGAS]         = EVO_TYPE_LEGENDARY,
    [SPECIES_RHYPERIOR]         = EVO_TYPE_2,
    [SPECIES_ROSERADE]          = EVO_TYPE_2,
    [SPECIES_SYLVEON]           = EVO_TYPE_1,
    [SPECIES_TANGROWTH]         = EVO_TYPE_1,
    [SPECIES_TOGEKISS]          = EVO_TYPE_2,
    [SPECIES_WEAVILE]           = EVO_TYPE_1,
    [SPECIES_YANMEGA]           = EVO_TYPE_1,
    [SPECIES_ANNIHILAPE]        = EVO_TYPE_2,
    [SPECIES_FARIGIRAF - 1]     = EVO_TYPE_1,
    [SPECIES_DUDUNSPARCE - 1]   = EVO_TYPE_1,
    [SPECIES_WYRDEER - 1] = EVO_TYPE_1,
    [SPECIES_URSALUNA - 1] = EVO_TYPE_1,
    [SPECIES_URSALUNA_BLOODMOON - 1] = EVO_TYPE_1,
    [SPECIES_KLEAVOR - 1] = EVO_TYPE_1,
    //[SPECIES_UNUSED_SPACE5 - 1] = EVO_TYPE_LEGENDARY,
    //[SPECIES_UNUSED_SPACE6 - 1] = EVO_TYPE_LEGENDARY,
    //[SPECIES_UNUSED_SPACE7 - 1] = EVO_TYPE_LEGENDARY,
    //[SPECIES_UNUSED_SPACE8 - 1] = EVO_TYPE_LEGENDARY,
    //[SPECIES_UNUSED_SPACE9 - 1] = EVO_TYPE_LEGENDARY,
    //[SPECIES_UNUSED_SPACE10 - 1] = EVO_TYPE_LEGENDARY,
    [SPECIES_DEOXYS_ATTACK]     = EVO_TYPE_LEGENDARY,
    [SPECIES_DEOXYS_DEFENSE]    = EVO_TYPE_LEGENDARY,
    [SPECIES_DEOXYS_SPEED]      = EVO_TYPE_LEGENDARY,
};
#define RANDOM_SPECIES_COUNT ARRAY_COUNT(sRandomSpecies)
static const u16 sRandomSpecies[] =
{
    //SPECIES_NONE                    ,
    SPECIES_BULBASAUR               ,
    SPECIES_IVYSAUR                 ,
    SPECIES_VENUSAUR                ,
    SPECIES_CHARMANDER              ,
    SPECIES_CHARMELEON              ,
    SPECIES_CHARIZARD               ,
    SPECIES_SQUIRTLE                ,
    SPECIES_WARTORTLE               ,
    SPECIES_BLASTOISE               ,
    SPECIES_CATERPIE                ,
    SPECIES_METAPOD                 ,
    SPECIES_BUTTERFREE              ,
    SPECIES_WEEDLE                  ,
    SPECIES_KAKUNA                  ,
    SPECIES_BEEDRILL                ,
    SPECIES_PIDGEY                  ,
    SPECIES_PIDGEOTTO               ,
    SPECIES_PIDGEOT                 ,
    SPECIES_RATTATA                 ,
    SPECIES_RATICATE                ,
    SPECIES_SPEAROW                 ,
    SPECIES_FEAROW                  ,
    SPECIES_EKANS                   ,
    SPECIES_ARBOK                   ,
    SPECIES_PIKACHU                 ,
    SPECIES_RAICHU                  ,
    SPECIES_SANDSHREW               ,
    SPECIES_SANDSLASH               ,
    SPECIES_NIDORAN_F               ,
    SPECIES_NIDORINA                ,
    SPECIES_NIDOQUEEN               ,
    SPECIES_NIDORAN_M               ,
    SPECIES_NIDORINO                ,
    SPECIES_NIDOKING                ,
    SPECIES_CLEFAIRY                ,
    SPECIES_CLEFABLE                ,
    SPECIES_VULPIX                  ,
    SPECIES_NINETALES               ,
    SPECIES_JIGGLYPUFF              ,
    SPECIES_WIGGLYTUFF              ,
    SPECIES_ZUBAT                   ,
    SPECIES_GOLBAT                  ,
    SPECIES_ODDISH                  ,
    SPECIES_GLOOM                   ,
    SPECIES_VILEPLUME               ,
    SPECIES_PARAS                   ,
    SPECIES_PARASECT                ,
    SPECIES_VENONAT                 ,
    SPECIES_VENOMOTH                ,
    SPECIES_DIGLETT                 ,
    SPECIES_DUGTRIO                 ,
    SPECIES_MEOWTH                  ,
    SPECIES_PERSIAN                 ,
    SPECIES_PSYDUCK                 ,
    SPECIES_GOLDUCK                 ,
    SPECIES_MANKEY                  ,
    SPECIES_PRIMEAPE                ,
    SPECIES_GROWLITHE               ,
    SPECIES_ARCANINE                ,
    SPECIES_POLIWAG                 ,
    SPECIES_POLIWHIRL               ,
    SPECIES_POLIWRATH               ,
    SPECIES_ABRA                    ,
    SPECIES_KADABRA                 ,
    SPECIES_ALAKAZAM                ,
    SPECIES_MACHOP                  ,
    SPECIES_MACHOKE                 ,
    SPECIES_MACHAMP                 ,
    SPECIES_BELLSPROUT              ,
    SPECIES_WEEPINBELL              ,
    SPECIES_VICTREEBEL              ,
    SPECIES_TENTACOOL               ,
    SPECIES_TENTACRUEL              ,
    SPECIES_GEODUDE                 ,
    SPECIES_GRAVELER                ,
    SPECIES_GOLEM                   ,
    SPECIES_PONYTA                  ,
    SPECIES_RAPIDASH                ,
    SPECIES_SLOWPOKE                ,
    SPECIES_SLOWBRO                 ,
    SPECIES_MAGNEMITE               ,
    SPECIES_MAGNETON                ,
    SPECIES_FARFETCHD               ,
    SPECIES_DODUO                   ,
    SPECIES_DODRIO                  ,
    SPECIES_SEEL                    ,
    SPECIES_DEWGONG                 ,
    SPECIES_GRIMER                  ,
    SPECIES_MUK                     ,
    SPECIES_SHELLDER                ,
    SPECIES_CLOYSTER                ,
    SPECIES_GASTLY                  ,
    SPECIES_HAUNTER                 ,
    SPECIES_GENGAR                  ,
    SPECIES_ONIX                    ,
    SPECIES_DROWZEE                 ,
    SPECIES_HYPNO                   ,
    SPECIES_KRABBY                  ,
    SPECIES_KINGLER                 ,
    SPECIES_VOLTORB                 ,
    SPECIES_ELECTRODE               ,
    SPECIES_EXEGGCUTE               ,
    SPECIES_EXEGGUTOR               ,
    SPECIES_CUBONE                  ,
    SPECIES_MAROWAK                 ,
    SPECIES_HITMONLEE               ,
    SPECIES_HITMONCHAN              ,
    SPECIES_LICKITUNG               ,
    SPECIES_KOFFING                 ,
    SPECIES_WEEZING                 ,
    SPECIES_RHYHORN                 ,
    SPECIES_RHYDON                  ,
    SPECIES_CHANSEY                 ,
    SPECIES_TANGELA                 ,
    SPECIES_KANGASKHAN              ,
    SPECIES_HORSEA                  ,
    SPECIES_SEADRA                  ,
    SPECIES_GOLDEEN                 ,
    SPECIES_SEAKING                 ,
    SPECIES_STARYU                  ,
    SPECIES_STARMIE                 ,
    SPECIES_MR_MIME                 ,
    SPECIES_SCYTHER                 ,
    SPECIES_JYNX                    ,
    SPECIES_ELECTABUZZ              ,
    SPECIES_MAGMAR                  ,
    SPECIES_PINSIR                  ,
    SPECIES_TAUROS                  ,
    SPECIES_MAGIKARP                ,
    SPECIES_GYARADOS                ,
    SPECIES_LAPRAS                  ,
    SPECIES_DITTO                   ,
    SPECIES_EEVEE                   ,
    SPECIES_VAPOREON                ,
    SPECIES_JOLTEON                 ,
    SPECIES_FLAREON                 ,
    SPECIES_PORYGON                 ,
    SPECIES_OMANYTE                 ,
    SPECIES_OMASTAR                 ,
    SPECIES_KABUTO                  ,
    SPECIES_KABUTOPS                ,
    SPECIES_AERODACTYL              ,
    SPECIES_SNORLAX                 ,
    // SPECIES_ARTICUNO  ,
    // SPECIES_ZAPDOS    ,
    // SPECIES_MOLTRES   ,
    SPECIES_DRATINI                 ,
    SPECIES_DRAGONAIR               ,
    SPECIES_DRAGONITE               ,
    // SPECIES_MEWTWO    ,
    // SPECIES_MEW       ,
    SPECIES_CHIKORITA                  ,
    SPECIES_BAYLEEF                    ,
    SPECIES_MEGANIUM                   ,
    SPECIES_CYNDAQUIL                  ,
    SPECIES_QUILAVA                    ,
    SPECIES_TYPHLOSION                 ,
    SPECIES_TOTODILE                   ,
    SPECIES_CROCONAW                   ,
    SPECIES_FERALIGATR                 ,
    SPECIES_SENTRET                    ,
    SPECIES_FURRET                     ,
    SPECIES_HOOTHOOT                   ,
    SPECIES_NOCTOWL                    ,
    SPECIES_LEDYBA                     ,
    SPECIES_LEDIAN                     ,
    SPECIES_SPINARAK                   ,
    SPECIES_ARIADOS                    ,
    SPECIES_CROBAT                     ,
    SPECIES_CHINCHOU                   ,
    SPECIES_LANTURN                    ,
    SPECIES_PICHU                      ,
    SPECIES_CLEFFA                     ,
    SPECIES_IGGLYBUFF                  ,
    SPECIES_TOGEPI                     ,
    SPECIES_TOGETIC                    ,
    SPECIES_NATU                       ,
    SPECIES_XATU                       ,
    SPECIES_MAREEP                     ,
    SPECIES_FLAAFFY                    ,
    SPECIES_AMPHAROS                   ,
    SPECIES_BELLOSSOM                  ,
    SPECIES_MARILL                     ,
    SPECIES_AZUMARILL                  ,
    SPECIES_SUDOWOODO                  ,
    SPECIES_POLITOED                   ,
    SPECIES_HOPPIP                     ,
    SPECIES_SKIPLOOM                   ,
    SPECIES_JUMPLUFF                   ,
    SPECIES_AIPOM                      ,
    SPECIES_SUNKERN                    ,
    SPECIES_SUNFLORA                   ,
    SPECIES_YANMA                      ,
    SPECIES_WOOPER                     ,
    SPECIES_QUAGSIRE                   ,
    SPECIES_ESPEON                     ,
    SPECIES_UMBREON                    ,
    SPECIES_MURKROW                    ,
    SPECIES_SLOWKING                   ,
    SPECIES_MISDREAVUS                 ,
    SPECIES_UNOWN                      ,
    SPECIES_WOBBUFFET                  ,
    SPECIES_GIRAFARIG                  ,
    SPECIES_PINECO                     ,
    SPECIES_FORRETRESS                 ,
    SPECIES_DUNSPARCE                  ,
    SPECIES_GLIGAR                     ,
    SPECIES_STEELIX                    ,
    SPECIES_SNUBBULL                   ,
    SPECIES_GRANBULL                   ,
    SPECIES_QWILFISH                   ,
    SPECIES_SCIZOR                     ,
    SPECIES_SHUCKLE                    ,
    SPECIES_HERACROSS                  ,
    SPECIES_SNEASEL                    ,
    SPECIES_TEDDIURSA                  ,
    SPECIES_URSARING                   ,
    SPECIES_SLUGMA                     ,
    SPECIES_MAGCARGO                   ,
    SPECIES_SWINUB                     ,
    SPECIES_PILOSWINE                  ,
    SPECIES_CORSOLA                    ,
    SPECIES_REMORAID                   ,
    SPECIES_OCTILLERY                  ,
    SPECIES_DELIBIRD                   ,
    SPECIES_MANTINE                    ,
    SPECIES_SKARMORY                   ,
    SPECIES_HOUNDOUR                   ,
    SPECIES_HOUNDOOM                   ,
    SPECIES_KINGDRA                    ,
    SPECIES_PHANPY                     ,
    SPECIES_DONPHAN                    ,
    SPECIES_PORYGON2                   ,
    SPECIES_STANTLER                   ,
    SPECIES_SMEARGLE                   ,
    SPECIES_TYROGUE                    ,
    SPECIES_HITMONTOP                  ,
    SPECIES_SMOOCHUM                   ,
    SPECIES_ELEKID                     ,
    SPECIES_MAGBY                      ,
    SPECIES_MILTANK                    ,
    SPECIES_BLISSEY                    ,
    //SPECIES_RAIKOU                     ,
    //SPECIES_ENTEI                      ,
    //SPECIES_SUICUNE                    ,
    SPECIES_LARVITAR                   ,
    SPECIES_PUPITAR                    ,
    SPECIES_TYRANITAR                  ,
    // SPECIES_LUGIA     ,
    // SPECIES_HO_OH     ,
    // SPECIES_CELEBI    ,
    // SPECIES_OLD_UNOWN_B,
    // SPECIES_OLD_UNOWN_C,
    // SPECIES_OLD_UNOWN_D,
    // SPECIES_OLD_UNOWN_E,
    // SPECIES_OLD_UNOWN_F,
    // SPECIES_OLD_UNOWN_G,
    // SPECIES_OLD_UNOWN_H,
    // SPECIES_OLD_UNOWN_I,
    // SPECIES_OLD_UNOWN_J,
    // SPECIES_OLD_UNOWN_K,
    // SPECIES_OLD_UNOWN_L,
    // SPECIES_OLD_UNOWN_M,
    // SPECIES_OLD_UNOWN_N,
    // SPECIES_OLD_UNOWN_O,
    // SPECIES_OLD_UNOWN_P,
    // SPECIES_OLD_UNOWN_Q,
    // SPECIES_OLD_UNOWN_R,
    // SPECIES_OLD_UNOWN_S,
    // SPECIES_OLD_UNOWN_T,
    // SPECIES_OLD_UNOWN_U,
    // SPECIES_OLD_UNOWN_V,
    // SPECIES_OLD_UNOWN_W,
    // SPECIES_OLD_UNOWN_X,
    // SPECIES_OLD_UNOWN_Y,
    // SPECIES_OLD_UNOWN_Z,
    SPECIES_TREECKO           ,
    SPECIES_GROVYLE           ,
    SPECIES_SCEPTILE          ,
    SPECIES_TORCHIC           ,
    SPECIES_COMBUSKEN         ,
    SPECIES_BLAZIKEN          ,
    SPECIES_MUDKIP            ,
    SPECIES_MARSHTOMP         ,
    SPECIES_SWAMPERT          ,
    SPECIES_POOCHYENA         ,
    SPECIES_MIGHTYENA         ,
    SPECIES_ZIGZAGOON         ,
    SPECIES_LINOONE           ,
    SPECIES_WURMPLE           ,
    SPECIES_SILCOON           ,
    SPECIES_BEAUTIFLY         ,
    SPECIES_CASCOON           ,
    SPECIES_DUSTOX            ,
    SPECIES_LOTAD             ,
    SPECIES_LOMBRE            ,
    SPECIES_LUDICOLO          ,
    SPECIES_SEEDOT            ,
    SPECIES_NUZLEAF           ,
    SPECIES_SHIFTRY           ,
    SPECIES_NINCADA           ,
    SPECIES_NINJASK           ,
    // SPECIES_SHEDINJA          ,
    SPECIES_TAILLOW           ,
    SPECIES_SWELLOW           ,
    SPECIES_SHROOMISH         ,
    SPECIES_BRELOOM           ,
    SPECIES_SPINDA            ,
    SPECIES_WINGULL           ,
    SPECIES_PELIPPER          ,
    SPECIES_SURSKIT           ,
    SPECIES_MASQUERAIN        ,
    SPECIES_WAILMER           ,
    SPECIES_WAILORD           ,
    SPECIES_SKITTY            ,
    SPECIES_DELCATTY          ,
    SPECIES_KECLEON           ,
    SPECIES_BALTOY            ,
    SPECIES_CLAYDOL           ,
    SPECIES_NOSEPASS          ,
    SPECIES_TORKOAL           ,
    SPECIES_SABLEYE           ,
    SPECIES_BARBOACH          ,
    SPECIES_WHISCASH          ,
    SPECIES_LUVDISC           ,
    SPECIES_CORPHISH          ,
    SPECIES_CRAWDAUNT         ,
    SPECIES_FEEBAS            ,
    SPECIES_MILOTIC           ,
    SPECIES_CARVANHA          ,
    SPECIES_SHARPEDO          ,
    SPECIES_TRAPINCH          ,
    SPECIES_VIBRAVA           ,
    SPECIES_FLYGON            ,
    SPECIES_MAKUHITA          ,
    SPECIES_HARIYAMA          ,
    SPECIES_ELECTRIKE         ,
    SPECIES_MANECTRIC         ,
    SPECIES_NUMEL             ,
    SPECIES_CAMERUPT          ,
    SPECIES_SPHEAL            ,
    SPECIES_SEALEO            ,
    SPECIES_WALREIN           ,
    SPECIES_CACNEA            ,
    SPECIES_CACTURNE          ,
    SPECIES_SNORUNT           ,
    SPECIES_GLALIE            ,
    SPECIES_LUNATONE          ,
    SPECIES_SOLROCK           ,
    SPECIES_AZURILL           ,
    SPECIES_SPOINK            ,
    SPECIES_GRUMPIG           ,
    SPECIES_PLUSLE            ,
    SPECIES_MINUN             ,
    SPECIES_MAWILE            ,
    SPECIES_MEDITITE          ,
    SPECIES_MEDICHAM          ,
    SPECIES_SWABLU            ,
    SPECIES_ALTARIA           ,
    SPECIES_WYNAUT            ,
    SPECIES_DUSKULL           ,
    SPECIES_DUSCLOPS          ,
    SPECIES_ROSELIA           ,
    SPECIES_SLAKOTH           ,
    SPECIES_VIGOROTH          ,
    SPECIES_SLAKING           ,
    SPECIES_GULPIN            ,
    SPECIES_SWALOT            ,
    SPECIES_TROPIUS           ,
    SPECIES_WHISMUR           ,
    SPECIES_LOUDRED           ,
    SPECIES_EXPLOUD           ,
    SPECIES_CLAMPERL          ,
    SPECIES_HUNTAIL           ,
    SPECIES_GOREBYSS          ,
    SPECIES_ABSOL             ,
    SPECIES_SHUPPET           ,
    SPECIES_BANETTE           ,
    SPECIES_SEVIPER           ,
    SPECIES_ZANGOOSE          ,
    SPECIES_RELICANTH         ,
    SPECIES_ARON              ,
    SPECIES_LAIRON            ,
    SPECIES_AGGRON            ,
    // SPECIES_CASTFORM          ,
    SPECIES_VOLBEAT           ,
    SPECIES_ILLUMISE          ,
    SPECIES_LILEEP            ,
    SPECIES_CRADILY           ,
    SPECIES_ANORITH           ,
    SPECIES_ARMALDO           ,
    SPECIES_RALTS             ,
    SPECIES_KIRLIA            ,
    SPECIES_GARDEVOIR         ,
    SPECIES_BAGON             ,
    SPECIES_SHELGON           ,
    SPECIES_SALAMENCE         ,
    SPECIES_BELDUM            ,
    SPECIES_METANG            ,
    SPECIES_METAGROSS         ,
    // SPECIES_REGIROCK  ,
    // SPECIES_REGICE    ,
    // SPECIES_REGISTEEL ,
    // SPECIES_KYOGRE    ,
    // SPECIES_GROUDON   ,
    // SPECIES_RAYQUAZA  ,
    // SPECIES_LATIAS    ,
    // SPECIES_LATIOS    ,
    // SPECIES_JIRACHI   ,
    // SPECIES_DEOXYS    ,
    SPECIES_CHIMECHO          ,
    SPECIES_AMBIPOM           ,
    //SPECIES_ARCEUS            ,
    SPECIES_BONSLY            ,
    SPECIES_BUDEW             ,
    SPECIES_CHINGLING         ,
    SPECIES_DUSKNOIR          ,
    SPECIES_ELECTIVIRE        ,
    SPECIES_FROSLASS          ,
    SPECIES_GALLADE           ,
    SPECIES_GLACEON           ,
    SPECIES_GLISCOR           ,
    SPECIES_HAPPINY           ,
    SPECIES_HONCHKROW         ,
    SPECIES_LEAFEON           ,
    SPECIES_LICKILICKY        ,
    SPECIES_MAGMORTAR         ,
    SPECIES_MAGNEZONE         ,
    SPECIES_MAMOSWINE         ,
    SPECIES_MANTYKE           ,
    SPECIES_MISMAGIUS         ,
    SPECIES_MIME_JR           ,
    SPECIES_MUNCHLAX          ,
    SPECIES_PORYGON_Z         ,
    SPECIES_PROBOPASS         ,
    //SPECIES_REGIDRAGO         ,
    //SPECIES_REGIELEKI         ,
    //SPECIES_REGIGIGAS         ,
    SPECIES_RHYPERIOR         ,
    SPECIES_ROSERADE          ,
    SPECIES_SYLVEON           ,
    SPECIES_TANGROWTH         ,
    SPECIES_TOGEKISS          ,
    SPECIES_WEAVILE           ,
    SPECIES_YANMEGA           ,
    //SPECIES_DEOXYS_ATTACK     ,
    //SPECIES_DEOXYS_DEFENSE    ,
    //SPECIES_DEOXYS_SPEED      ,
    SPECIES_ANNIHILAPE           ,
    SPECIES_FARIGIRAF           ,
    SPECIES_DUDUNSPARCE           ,
    SPECIES_WYRDEER           ,
    SPECIES_URSALUNA           ,
    SPECIES_URSALUNA_BLOODMOON           ,
    SPECIES_KLEAVOR           ,
    //SPECIES_UNUSED_SPACE5           ,
    //SPECIES_UNUSED_SPACE6           ,
    //SPECIES_UNUSED_SPACE7           ,
    //SPECIES_UNUSED_SPACE8           ,
    //SPECIES_UNUSED_SPACE9           ,
    //SPECIES_UNUSED_SPACE10            ,
    // SPECIES_EGG       ,
};
#define RANDOM_SPECIES_COUNT_LEGENDARY ARRAY_COUNT(sRandomSpeciesLegendary)
static const u16 sRandomSpeciesLegendary[] =
{
    //SPECIES_NONE                    ,
    SPECIES_BULBASAUR               ,
    SPECIES_IVYSAUR                 ,
    SPECIES_VENUSAUR                ,
    SPECIES_CHARMANDER              ,
    SPECIES_CHARMELEON              ,
    SPECIES_CHARIZARD               ,
    SPECIES_SQUIRTLE                ,
    SPECIES_WARTORTLE               ,
    SPECIES_BLASTOISE               ,
    SPECIES_CATERPIE                ,
    SPECIES_METAPOD                 ,
    SPECIES_BUTTERFREE              ,
    SPECIES_WEEDLE                  ,
    SPECIES_KAKUNA                  ,
    SPECIES_BEEDRILL                ,
    SPECIES_PIDGEY                  ,
    SPECIES_PIDGEOTTO               ,
    SPECIES_PIDGEOT                 ,
    SPECIES_RATTATA                 ,
    SPECIES_RATICATE                ,
    SPECIES_SPEAROW                 ,
    SPECIES_FEAROW                  ,
    SPECIES_EKANS                   ,
    SPECIES_ARBOK                   ,
    SPECIES_PIKACHU                 ,
    SPECIES_RAICHU                  ,
    SPECIES_SANDSHREW               ,
    SPECIES_SANDSLASH               ,
    SPECIES_NIDORAN_F               ,
    SPECIES_NIDORINA                ,
    SPECIES_NIDOQUEEN               ,
    SPECIES_NIDORAN_M               ,
    SPECIES_NIDORINO                ,
    SPECIES_NIDOKING                ,
    SPECIES_CLEFAIRY                ,
    SPECIES_CLEFABLE                ,
    SPECIES_VULPIX                  ,
    SPECIES_NINETALES               ,
    SPECIES_JIGGLYPUFF              ,
    SPECIES_WIGGLYTUFF              ,
    SPECIES_ZUBAT                   ,
    SPECIES_GOLBAT                  ,
    SPECIES_ODDISH                  ,
    SPECIES_GLOOM                   ,
    SPECIES_VILEPLUME               ,
    SPECIES_PARAS                   ,
    SPECIES_PARASECT                ,
    SPECIES_VENONAT                 ,
    SPECIES_VENOMOTH                ,
    SPECIES_DIGLETT                 ,
    SPECIES_DUGTRIO                 ,
    SPECIES_MEOWTH                  ,
    SPECIES_PERSIAN                 ,
    SPECIES_PSYDUCK                 ,
    SPECIES_GOLDUCK                 ,
    SPECIES_MANKEY                  ,
    SPECIES_PRIMEAPE                ,
    SPECIES_GROWLITHE               ,
    SPECIES_ARCANINE                ,
    SPECIES_POLIWAG                 ,
    SPECIES_POLIWHIRL               ,
    SPECIES_POLIWRATH               ,
    SPECIES_ABRA                    ,
    SPECIES_KADABRA                 ,
    SPECIES_ALAKAZAM                ,
    SPECIES_MACHOP                  ,
    SPECIES_MACHOKE                 ,
    SPECIES_MACHAMP                 ,
    SPECIES_BELLSPROUT              ,
    SPECIES_WEEPINBELL              ,
    SPECIES_VICTREEBEL              ,
    SPECIES_TENTACOOL               ,
    SPECIES_TENTACRUEL              ,
    SPECIES_GEODUDE                 ,
    SPECIES_GRAVELER                ,
    SPECIES_GOLEM                   ,
    SPECIES_PONYTA                  ,
    SPECIES_RAPIDASH                ,
    SPECIES_SLOWPOKE                ,
    SPECIES_SLOWBRO                 ,
    SPECIES_MAGNEMITE               ,
    SPECIES_MAGNETON                ,
    SPECIES_FARFETCHD               ,
    SPECIES_DODUO                   ,
    SPECIES_DODRIO                  ,
    SPECIES_SEEL                    ,
    SPECIES_DEWGONG                 ,
    SPECIES_GRIMER                  ,
    SPECIES_MUK                     ,
    SPECIES_SHELLDER                ,
    SPECIES_CLOYSTER                ,
    SPECIES_GASTLY                  ,
    SPECIES_HAUNTER                 ,
    SPECIES_GENGAR                  ,
    SPECIES_ONIX                    ,
    SPECIES_DROWZEE                 ,
    SPECIES_HYPNO                   ,
    SPECIES_KRABBY                  ,
    SPECIES_KINGLER                 ,
    SPECIES_VOLTORB                 ,
    SPECIES_ELECTRODE               ,
    SPECIES_EXEGGCUTE               ,
    SPECIES_EXEGGUTOR               ,
    SPECIES_CUBONE                  ,
    SPECIES_MAROWAK                 ,
    SPECIES_HITMONLEE               ,
    SPECIES_HITMONCHAN              ,
    SPECIES_LICKITUNG               ,
    SPECIES_KOFFING                 ,
    SPECIES_WEEZING                 ,
    SPECIES_RHYHORN                 ,
    SPECIES_RHYDON                  ,
    SPECIES_CHANSEY                 ,
    SPECIES_TANGELA                 ,
    SPECIES_KANGASKHAN              ,
    SPECIES_HORSEA                  ,
    SPECIES_SEADRA                  ,
    SPECIES_GOLDEEN                 ,
    SPECIES_SEAKING                 ,
    SPECIES_STARYU                  ,
    SPECIES_STARMIE                 ,
    SPECIES_MR_MIME                 ,
    SPECIES_SCYTHER                 ,
    SPECIES_JYNX                    ,
    SPECIES_ELECTABUZZ              ,
    SPECIES_MAGMAR                  ,
    SPECIES_PINSIR                  ,
    SPECIES_TAUROS                  ,
    SPECIES_MAGIKARP                ,
    SPECIES_GYARADOS                ,
    SPECIES_LAPRAS                  ,
    SPECIES_DITTO                   ,
    SPECIES_EEVEE                   ,
    SPECIES_VAPOREON                ,
    SPECIES_JOLTEON                 ,
    SPECIES_FLAREON                 ,
    SPECIES_PORYGON                 ,
    SPECIES_OMANYTE                 ,
    SPECIES_OMASTAR                 ,
    SPECIES_KABUTO                  ,
    SPECIES_KABUTOPS                ,
    SPECIES_AERODACTYL              ,
    SPECIES_SNORLAX                 ,
    SPECIES_ARTICUNO                ,
    SPECIES_ZAPDOS                  ,
    SPECIES_MOLTRES                 ,
    SPECIES_DRATINI                 ,
    SPECIES_DRAGONAIR               ,
    SPECIES_DRAGONITE               ,
    SPECIES_MEWTWO                  ,
    SPECIES_MEW                     ,
    SPECIES_CHIKORITA                  ,
    SPECIES_BAYLEEF                    ,
    SPECIES_MEGANIUM                   ,
    SPECIES_CYNDAQUIL                  ,
    SPECIES_QUILAVA                    ,
    SPECIES_TYPHLOSION                 ,
    SPECIES_TOTODILE                   ,
    SPECIES_CROCONAW                   ,
    SPECIES_FERALIGATR                 ,
    SPECIES_SENTRET                    ,
    SPECIES_FURRET                     ,
    SPECIES_HOOTHOOT                   ,
    SPECIES_NOCTOWL                    ,
    SPECIES_LEDYBA                     ,
    SPECIES_LEDIAN                     ,
    SPECIES_SPINARAK                   ,
    SPECIES_ARIADOS                    ,
    SPECIES_CROBAT                     ,
    SPECIES_CHINCHOU                   ,
    SPECIES_LANTURN                    ,
    SPECIES_PICHU                      ,
    SPECIES_CLEFFA                     ,
    SPECIES_IGGLYBUFF                  ,
    SPECIES_TOGEPI                     ,
    SPECIES_TOGETIC                    ,
    SPECIES_NATU                       ,
    SPECIES_XATU                       ,
    SPECIES_MAREEP                     ,
    SPECIES_FLAAFFY                    ,
    SPECIES_AMPHAROS                   ,
    SPECIES_BELLOSSOM                  ,
    SPECIES_MARILL                     ,
    SPECIES_AZUMARILL                  ,
    SPECIES_SUDOWOODO                  ,
    SPECIES_POLITOED                   ,
    SPECIES_HOPPIP                     ,
    SPECIES_SKIPLOOM                   ,
    SPECIES_JUMPLUFF                   ,
    SPECIES_AIPOM                      ,
    SPECIES_SUNKERN                    ,
    SPECIES_SUNFLORA                   ,
    SPECIES_YANMA                      ,
    SPECIES_WOOPER                     ,
    SPECIES_QUAGSIRE                   ,
    SPECIES_ESPEON                     ,
    SPECIES_UMBREON                    ,
    SPECIES_MURKROW                    ,
    SPECIES_SLOWKING                   ,
    SPECIES_MISDREAVUS                 ,
    SPECIES_UNOWN                      ,
    SPECIES_WOBBUFFET                  ,
    SPECIES_GIRAFARIG                  ,
    SPECIES_PINECO                     ,
    SPECIES_FORRETRESS                 ,
    SPECIES_DUNSPARCE                  ,
    SPECIES_GLIGAR                     ,
    SPECIES_STEELIX                    ,
    SPECIES_SNUBBULL                   ,
    SPECIES_GRANBULL                   ,
    SPECIES_QWILFISH                   ,
    SPECIES_SCIZOR                     ,
    SPECIES_SHUCKLE                    ,
    SPECIES_HERACROSS                  ,
    SPECIES_SNEASEL                    ,
    SPECIES_TEDDIURSA                  ,
    SPECIES_URSARING                   ,
    SPECIES_SLUGMA                     ,
    SPECIES_MAGCARGO                   ,
    SPECIES_SWINUB                     ,
    SPECIES_PILOSWINE                  ,
    SPECIES_CORSOLA                    ,
    SPECIES_REMORAID                   ,
    SPECIES_OCTILLERY                  ,
    SPECIES_DELIBIRD                   ,
    SPECIES_MANTINE                    ,
    SPECIES_SKARMORY                   ,
    SPECIES_HOUNDOUR                   ,
    SPECIES_HOUNDOOM                   ,
    SPECIES_KINGDRA                    ,
    SPECIES_PHANPY                     ,
    SPECIES_DONPHAN                    ,
    SPECIES_PORYGON2                   ,
    SPECIES_STANTLER                   ,
    SPECIES_SMEARGLE                   ,
    SPECIES_TYROGUE                    ,
    SPECIES_HITMONTOP                  ,
    SPECIES_SMOOCHUM                   ,
    SPECIES_ELEKID                     ,
    SPECIES_MAGBY                      ,
    SPECIES_MILTANK                    ,
    SPECIES_BLISSEY                    ,
    SPECIES_RAIKOU                     ,
    SPECIES_ENTEI                      ,
    SPECIES_SUICUNE                    ,
    SPECIES_LARVITAR                   ,
    SPECIES_PUPITAR                    ,
    SPECIES_TYRANITAR                  ,
    SPECIES_LUGIA                      ,
    SPECIES_HO_OH                      ,
    SPECIES_CELEBI                     ,
    // SPECIES_OLD_UNOWN_B,
    // SPECIES_OLD_UNOWN_C,
    // SPECIES_OLD_UNOWN_D,
    // SPECIES_OLD_UNOWN_E,
    // SPECIES_OLD_UNOWN_F,
    // SPECIES_OLD_UNOWN_G,
    // SPECIES_OLD_UNOWN_H,
    // SPECIES_OLD_UNOWN_I,
    // SPECIES_OLD_UNOWN_J,
    // SPECIES_OLD_UNOWN_K,
    // SPECIES_OLD_UNOWN_L,
    // SPECIES_OLD_UNOWN_M,
    // SPECIES_OLD_UNOWN_N,
    // SPECIES_OLD_UNOWN_O,
    // SPECIES_OLD_UNOWN_P,
    // SPECIES_OLD_UNOWN_Q,
    // SPECIES_OLD_UNOWN_R,
    // SPECIES_OLD_UNOWN_S,
    // SPECIES_OLD_UNOWN_T,
    // SPECIES_OLD_UNOWN_U,
    // SPECIES_OLD_UNOWN_V,
    // SPECIES_OLD_UNOWN_W,
    // SPECIES_OLD_UNOWN_X,
    // SPECIES_OLD_UNOWN_Y,
    // SPECIES_OLD_UNOWN_Z,
    SPECIES_TREECKO           ,
    SPECIES_GROVYLE           ,
    SPECIES_SCEPTILE          ,
    SPECIES_TORCHIC           ,
    SPECIES_COMBUSKEN         ,
    SPECIES_BLAZIKEN          ,
    SPECIES_MUDKIP            ,
    SPECIES_MARSHTOMP         ,
    SPECIES_SWAMPERT          ,
    SPECIES_POOCHYENA         ,
    SPECIES_MIGHTYENA         ,
    SPECIES_ZIGZAGOON         ,
    SPECIES_LINOONE           ,
    SPECIES_WURMPLE           ,
    SPECIES_SILCOON           ,
    SPECIES_BEAUTIFLY         ,
    SPECIES_CASCOON           ,
    SPECIES_DUSTOX            ,
    SPECIES_LOTAD             ,
    SPECIES_LOMBRE            ,
    SPECIES_LUDICOLO          ,
    SPECIES_SEEDOT            ,
    SPECIES_NUZLEAF           ,
    SPECIES_SHIFTRY           ,
    SPECIES_NINCADA           ,
    SPECIES_NINJASK           ,
    // SPECIES_SHEDINJA          ,
    SPECIES_TAILLOW           ,
    SPECIES_SWELLOW           ,
    SPECIES_SHROOMISH         ,
    SPECIES_BRELOOM           ,
    SPECIES_SPINDA            ,
    SPECIES_WINGULL           ,
    SPECIES_PELIPPER          ,
    SPECIES_SURSKIT           ,
    SPECIES_MASQUERAIN        ,
    SPECIES_WAILMER           ,
    SPECIES_WAILORD           ,
    SPECIES_SKITTY            ,
    SPECIES_DELCATTY          ,
    SPECIES_KECLEON           ,
    SPECIES_BALTOY            ,
    SPECIES_CLAYDOL           ,
    SPECIES_NOSEPASS          ,
    SPECIES_TORKOAL           ,
    SPECIES_SABLEYE           ,
    SPECIES_BARBOACH          ,
    SPECIES_WHISCASH          ,
    SPECIES_LUVDISC           ,
    SPECIES_CORPHISH          ,
    SPECIES_CRAWDAUNT         ,
    SPECIES_FEEBAS            ,
    SPECIES_MILOTIC           ,
    SPECIES_CARVANHA          ,
    SPECIES_SHARPEDO          ,
    SPECIES_TRAPINCH          ,
    SPECIES_VIBRAVA           ,
    SPECIES_FLYGON            ,
    SPECIES_MAKUHITA          ,
    SPECIES_HARIYAMA          ,
    SPECIES_ELECTRIKE         ,
    SPECIES_MANECTRIC         ,
    SPECIES_NUMEL             ,
    SPECIES_CAMERUPT          ,
    SPECIES_SPHEAL            ,
    SPECIES_SEALEO            ,
    SPECIES_WALREIN           ,
    SPECIES_CACNEA            ,
    SPECIES_CACTURNE          ,
    SPECIES_SNORUNT           ,
    SPECIES_GLALIE            ,
    SPECIES_LUNATONE          ,
    SPECIES_SOLROCK           ,
    SPECIES_AZURILL           ,
    SPECIES_SPOINK            ,
    SPECIES_GRUMPIG           ,
    SPECIES_PLUSLE            ,
    SPECIES_MINUN             ,
    SPECIES_MAWILE            ,
    SPECIES_MEDITITE          ,
    SPECIES_MEDICHAM          ,
    SPECIES_SWABLU            ,
    SPECIES_ALTARIA           ,
    SPECIES_WYNAUT            ,
    SPECIES_DUSKULL           ,
    SPECIES_DUSCLOPS          ,
    SPECIES_ROSELIA           ,
    SPECIES_SLAKOTH           ,
    SPECIES_VIGOROTH          ,
    SPECIES_SLAKING           ,
    SPECIES_GULPIN            ,
    SPECIES_SWALOT            ,
    SPECIES_TROPIUS           ,
    SPECIES_WHISMUR           ,
    SPECIES_LOUDRED           ,
    SPECIES_EXPLOUD           ,
    SPECIES_CLAMPERL          ,
    SPECIES_HUNTAIL           ,
    SPECIES_GOREBYSS          ,
    SPECIES_ABSOL             ,
    SPECIES_SHUPPET           ,
    SPECIES_BANETTE           ,
    SPECIES_SEVIPER           ,
    SPECIES_ZANGOOSE          ,
    SPECIES_RELICANTH         ,
    SPECIES_ARON              ,
    SPECIES_LAIRON            ,
    SPECIES_AGGRON            ,
    // SPECIES_CASTFORM          ,
    SPECIES_VOLBEAT           ,
    SPECIES_ILLUMISE          ,
    SPECIES_LILEEP            ,
    SPECIES_CRADILY           ,
    SPECIES_ANORITH           ,
    SPECIES_ARMALDO           ,
    SPECIES_RALTS             ,
    SPECIES_KIRLIA            ,
    SPECIES_GARDEVOIR         ,
    SPECIES_BAGON             ,
    SPECIES_SHELGON           ,
    SPECIES_SALAMENCE         ,
    SPECIES_BELDUM            ,
    SPECIES_METANG            ,
    SPECIES_METAGROSS         ,
    SPECIES_REGIROCK          ,
    SPECIES_REGICE            ,
    SPECIES_REGISTEEL         ,
    SPECIES_KYOGRE            ,
    SPECIES_GROUDON           ,
    SPECIES_RAYQUAZA          ,
    SPECIES_LATIAS            ,
    SPECIES_LATIOS            ,
    SPECIES_JIRACHI           ,
    SPECIES_DEOXYS            ,
    SPECIES_CHIMECHO          ,
    SPECIES_AMBIPOM           ,
    SPECIES_ARCEUS            ,
    SPECIES_BONSLY            ,
    SPECIES_BUDEW             ,
    SPECIES_CHINGLING         ,
    SPECIES_DUSKNOIR          ,
    SPECIES_ELECTIVIRE        ,
    SPECIES_FROSLASS          ,
    SPECIES_GALLADE           ,
    SPECIES_GLACEON           ,
    SPECIES_GLISCOR           ,
    SPECIES_HAPPINY           ,
    SPECIES_HONCHKROW         ,
    SPECIES_LEAFEON           ,
    SPECIES_LICKILICKY        ,
    SPECIES_MAGMORTAR         ,
    SPECIES_MAGNEZONE         ,
    SPECIES_MAMOSWINE         ,
    SPECIES_MANTYKE           ,
    SPECIES_MISMAGIUS         ,
    SPECIES_MIME_JR           ,
    SPECIES_MUNCHLAX          ,
    SPECIES_PORYGON_Z         ,
    SPECIES_PROBOPASS         ,
    SPECIES_REGIDRAGO         ,
    SPECIES_REGIELEKI         ,
    SPECIES_REGIGIGAS         ,
    SPECIES_RHYPERIOR         ,
    SPECIES_ROSERADE          ,
    SPECIES_SYLVEON           ,
    SPECIES_TANGROWTH         ,
    SPECIES_TOGEKISS          ,
    SPECIES_WEAVILE           ,
    SPECIES_YANMEGA           ,
    SPECIES_ANNIHILAPE           ,
    SPECIES_FARIGIRAF           ,
    SPECIES_DUDUNSPARCE           ,
    SPECIES_WYRDEER           ,
    SPECIES_URSALUNA           ,
    SPECIES_URSALUNA_BLOODMOON           ,
    SPECIES_KLEAVOR           ,
    //SPECIES_UNUSED_SPACE5           ,
    //SPECIES_UNUSED_SPACE6           ,
    //SPECIES_UNUSED_SPACE7           ,
    //SPECIES_UNUSED_SPACE8           ,
    //SPECIES_UNUSED_SPACE9           ,
    //SPECIES_UNUSED_SPACE10            ,
    SPECIES_DEOXYS_ATTACK     ,
    SPECIES_DEOXYS_DEFENSE    ,
    SPECIES_DEOXYS_SPEED      ,
};
#define RANDOM_SPECIES_EVO_0_COUNT ARRAY_COUNT(sRandomSpeciesEvo0)
static const u16 sRandomSpeciesEvo0[] =
{
    SPECIES_BULBASAUR       ,    //= EVO_TYPE_0,
    SPECIES_CHARMANDER      ,    //= EVO_TYPE_0,
    SPECIES_SQUIRTLE        ,    //= EVO_TYPE_0,
    SPECIES_CATERPIE        ,    //= EVO_TYPE_0,
    SPECIES_WEEDLE          ,    //= EVO_TYPE_0,
    SPECIES_PIDGEY          ,    //= EVO_TYPE_0,
    SPECIES_RATTATA         ,    //= EVO_TYPE_0,
    SPECIES_SPEAROW         ,    //= EVO_TYPE_0,
    SPECIES_EKANS           ,    //= EVO_TYPE_0,
    SPECIES_SANDSHREW       ,    //= EVO_TYPE_0,
    SPECIES_NIDORAN_F       ,    //= EVO_TYPE_0,
    SPECIES_NIDORAN_M       ,    //= EVO_TYPE_0,
    SPECIES_VULPIX          ,    //= EVO_TYPE_0,
    SPECIES_ZUBAT           ,    //= EVO_TYPE_0,
    SPECIES_ODDISH          ,    //= EVO_TYPE_0,
    SPECIES_PARAS           ,    //= EVO_TYPE_0,
    SPECIES_VENONAT         ,    //= EVO_TYPE_0,
    SPECIES_DIGLETT         ,    //= EVO_TYPE_0,
    SPECIES_MEOWTH          ,    //= EVO_TYPE_0,
    SPECIES_PSYDUCK         ,    //= EVO_TYPE_0,
    SPECIES_MANKEY          ,    //= EVO_TYPE_0,
    SPECIES_GROWLITHE       ,    //= EVO_TYPE_0,
    SPECIES_POLIWAG         ,    //= EVO_TYPE_0,
    SPECIES_ABRA            ,    //= EVO_TYPE_0,
    SPECIES_MACHOP          ,    //= EVO_TYPE_0,
    SPECIES_BELLSPROUT      ,    //= EVO_TYPE_0,
    SPECIES_TENTACOOL       ,    //= EVO_TYPE_0,
    SPECIES_GEODUDE         ,    //= EVO_TYPE_0,
    SPECIES_PONYTA          ,    //= EVO_TYPE_0,
    SPECIES_SLOWPOKE        ,    //= EVO_TYPE_0,
    SPECIES_MAGNEMITE       ,    //= EVO_TYPE_0,
    SPECIES_FARFETCHD       ,    //= EVO_TYPE_0,
    SPECIES_DODUO           ,    //= EVO_TYPE_0,
    SPECIES_SEEL            ,    //= EVO_TYPE_0,
    SPECIES_GRIMER          ,    //= EVO_TYPE_0,
    SPECIES_SHELLDER        ,    //= EVO_TYPE_0,
    SPECIES_GASTLY          ,    //= EVO_TYPE_0,
    SPECIES_ONIX            ,    //= EVO_TYPE_0,
    SPECIES_DROWZEE         ,    //= EVO_TYPE_0,
    SPECIES_KRABBY          ,    //= EVO_TYPE_0,
    SPECIES_VOLTORB         ,    //= EVO_TYPE_0,
    SPECIES_EXEGGCUTE       ,    //= EVO_TYPE_0,
    SPECIES_CUBONE          ,    //= EVO_TYPE_0,
    SPECIES_LICKITUNG       ,    //= EVO_TYPE_0,
    SPECIES_KOFFING         ,    //= EVO_TYPE_0,
    SPECIES_RHYHORN         ,    //= EVO_TYPE_0,
    SPECIES_TANGELA         ,    //= EVO_TYPE_0,
    SPECIES_KANGASKHAN      ,    //= EVO_TYPE_0,
    SPECIES_HORSEA          ,    //= EVO_TYPE_0,
    SPECIES_GOLDEEN         ,    //= EVO_TYPE_0,
    SPECIES_STARYU          ,    //= EVO_TYPE_0,
    SPECIES_SCYTHER         ,    //= EVO_TYPE_0,
    SPECIES_PINSIR          ,    //= EVO_TYPE_0,
    SPECIES_TAUROS          ,    //= EVO_TYPE_0,
    SPECIES_MAGIKARP        ,    //= EVO_TYPE_0,
    SPECIES_LAPRAS          ,    //= EVO_TYPE_0,
    SPECIES_DITTO           ,    //= EVO_TYPE_0,
    SPECIES_EEVEE           ,    //= EVO_TYPE_0,
    SPECIES_PORYGON         ,    //= EVO_TYPE_0,
    SPECIES_OMANYTE         ,    //= EVO_TYPE_0,
    SPECIES_KABUTO          ,    //= EVO_TYPE_0,
    SPECIES_AERODACTYL      ,    //= EVO_TYPE_0,
    SPECIES_DRATINI         ,    //= EVO_TYPE_0,
    SPECIES_CHIKORITA       ,    //= EVO_TYPE_0,
    SPECIES_CYNDAQUIL       ,    //= EVO_TYPE_0,
    SPECIES_TOTODILE        ,    //= EVO_TYPE_0,
    SPECIES_SENTRET         ,    //= EVO_TYPE_0,
    SPECIES_HOOTHOOT        ,    //= EVO_TYPE_0,
    SPECIES_LEDYBA          ,    //= EVO_TYPE_0,
    SPECIES_SPINARAK        ,    //= EVO_TYPE_0,
    SPECIES_CHINCHOU        ,    //= EVO_TYPE_0,
    SPECIES_PICHU           ,    //= EVO_TYPE_0,
    SPECIES_CLEFFA          ,    //= EVO_TYPE_0,
    SPECIES_IGGLYBUFF       ,    //= EVO_TYPE_0,
    SPECIES_TOGEPI          ,    //= EVO_TYPE_0,
    SPECIES_NATU            ,    //= EVO_TYPE_0,
    SPECIES_MAREEP          ,    //= EVO_TYPE_0,
    SPECIES_HOPPIP          ,    //= EVO_TYPE_0,
    SPECIES_AIPOM           ,    //= EVO_TYPE_0,
    SPECIES_SUNKERN         ,    //= EVO_TYPE_0,
    SPECIES_YANMA           ,    //= EVO_TYPE_0,
    SPECIES_WOOPER          ,    //= EVO_TYPE_0,
    SPECIES_MURKROW         ,    //= EVO_TYPE_0,
    SPECIES_MISDREAVUS      ,    //= EVO_TYPE_0,
    SPECIES_UNOWN           ,    //= EVO_TYPE_0,
    SPECIES_GIRAFARIG       ,    //= EVO_TYPE_0,
    SPECIES_PINECO          ,    //= EVO_TYPE_0,
    SPECIES_DUNSPARCE       ,    //= EVO_TYPE_0,
    SPECIES_GLIGAR          ,    //= EVO_TYPE_0,
    SPECIES_SNUBBULL        ,    //= EVO_TYPE_0,
    SPECIES_QWILFISH        ,    //= EVO_TYPE_0,
    SPECIES_SHUCKLE         ,    //= EVO_TYPE_0,
    SPECIES_HERACROSS       ,    //= EVO_TYPE_0,
    SPECIES_SNEASEL         ,    //= EVO_TYPE_0,
    SPECIES_TEDDIURSA       ,    //= EVO_TYPE_0,
    SPECIES_SLUGMA          ,    //= EVO_TYPE_0,
    SPECIES_SWINUB          ,    //= EVO_TYPE_0,
    SPECIES_CORSOLA         ,    //= EVO_TYPE_0,
    SPECIES_REMORAID        ,    //= EVO_TYPE_0,
    SPECIES_DELIBIRD        ,    //= EVO_TYPE_0,
    SPECIES_SKARMORY        ,    //= EVO_TYPE_0,
    SPECIES_HOUNDOUR        ,    //= EVO_TYPE_0,
    SPECIES_PHANPY          ,    //= EVO_TYPE_0,
    SPECIES_STANTLER        ,    //= EVO_TYPE_0,
    SPECIES_SMEARGLE        ,    //= EVO_TYPE_0,
    SPECIES_TYROGUE         ,    //= EVO_TYPE_0,
    SPECIES_SMOOCHUM        ,    //= EVO_TYPE_0,
    SPECIES_ELEKID          ,    //= EVO_TYPE_0,
    SPECIES_MAGBY           ,    //= EVO_TYPE_0,
    SPECIES_MILTANK         ,    //= EVO_TYPE_0,
    SPECIES_LARVITAR        ,    //= EVO_TYPE_0,
    SPECIES_TREECKO         ,    //= EVO_TYPE_0,
    SPECIES_TORCHIC         ,    //= EVO_TYPE_0,
    SPECIES_MUDKIP          ,    //= EVO_TYPE_0,
    SPECIES_POOCHYENA       ,    //= EVO_TYPE_0,
    SPECIES_ZIGZAGOON       ,    //= EVO_TYPE_0,
    SPECIES_WURMPLE         ,    //= EVO_TYPE_0,
    SPECIES_LOTAD           ,    //= EVO_TYPE_0,
    SPECIES_SEEDOT          ,    //= EVO_TYPE_0,
    SPECIES_NINCADA         ,    //= EVO_TYPE_0,
    SPECIES_TAILLOW         ,    //= EVO_TYPE_0,
    SPECIES_SHROOMISH       ,    //= EVO_TYPE_0,
    SPECIES_SPINDA          ,    //= EVO_TYPE_0,
    SPECIES_WINGULL         ,    //= EVO_TYPE_0,
    SPECIES_SURSKIT         ,    //= EVO_TYPE_0,
    SPECIES_WAILMER         ,    //= EVO_TYPE_0,
    SPECIES_SKITTY          ,    //= EVO_TYPE_0,
    SPECIES_KECLEON         ,    //= EVO_TYPE_0,
    SPECIES_BALTOY          ,    //= EVO_TYPE_0,
    SPECIES_NOSEPASS        ,    //= EVO_TYPE_0,
    SPECIES_TORKOAL         ,    //= EVO_TYPE_0,
    SPECIES_SABLEYE         ,    //= EVO_TYPE_0,
    SPECIES_BARBOACH        ,    //= EVO_TYPE_0,
    SPECIES_LUVDISC         ,    //= EVO_TYPE_0,
    SPECIES_CORPHISH        ,    //= EVO_TYPE_0,
    SPECIES_FEEBAS          ,    //= EVO_TYPE_0,
    SPECIES_CARVANHA        ,    //= EVO_TYPE_0,
    SPECIES_TRAPINCH        ,    //= EVO_TYPE_0,
    SPECIES_MAKUHITA        ,    //= EVO_TYPE_0,
    SPECIES_ELECTRIKE       ,    //= EVO_TYPE_0,
    SPECIES_NUMEL           ,    //= EVO_TYPE_0,
    SPECIES_SPHEAL          ,    //= EVO_TYPE_0,
    SPECIES_CACNEA          ,    //= EVO_TYPE_0,
    SPECIES_SNORUNT         ,    //= EVO_TYPE_0,
    SPECIES_LUNATONE        ,    //= EVO_TYPE_0,
    SPECIES_SOLROCK         ,    //= EVO_TYPE_0,
    SPECIES_AZURILL         ,    //= EVO_TYPE_0,
    SPECIES_SPOINK          ,    //= EVO_TYPE_0,
    SPECIES_PLUSLE          ,    //= EVO_TYPE_0,
    SPECIES_MINUN           ,    //= EVO_TYPE_0,
    SPECIES_MAWILE          ,    //= EVO_TYPE_0,
    SPECIES_MEDITITE        ,    //= EVO_TYPE_0,
    SPECIES_SWABLU          ,    //= EVO_TYPE_0,
    SPECIES_WYNAUT          ,    //= EVO_TYPE_0,
    SPECIES_DUSKULL         ,    //= EVO_TYPE_0,
    SPECIES_SLAKOTH         ,    //= EVO_TYPE_0,
    SPECIES_GULPIN          ,    //= EVO_TYPE_0,
    SPECIES_TROPIUS         ,    //= EVO_TYPE_0,
    SPECIES_WHISMUR         ,    //= EVO_TYPE_0,
    SPECIES_CLAMPERL        ,    //= EVO_TYPE_0,
    SPECIES_ABSOL           ,    //= EVO_TYPE_0,
    SPECIES_SHUPPET         ,    //= EVO_TYPE_0,
    SPECIES_SEVIPER         ,    //= EVO_TYPE_0,
    SPECIES_ZANGOOSE        ,    //= EVO_TYPE_0,
    SPECIES_RELICANTH       ,    //= EVO_TYPE_0,
    SPECIES_ARON            ,    //= EVO_TYPE_0,
    SPECIES_LILEEP          ,    //= EVO_TYPE_0,
    SPECIES_ANORITH         ,    //= EVO_TYPE_0,
    SPECIES_RALTS           ,    //= EVO_TYPE_0,
    SPECIES_BAGON           ,    //= EVO_TYPE_0,
    SPECIES_BELDUM          ,    //= EVO_TYPE_0,
    SPECIES_BONSLY            ,
    SPECIES_BUDEW             ,
    SPECIES_CHINGLING         ,
    SPECIES_HAPPINY           ,
    SPECIES_MANTYKE           ,
    SPECIES_MIME_JR           ,
    SPECIES_MUNCHLAX          ,
};
#define RANDOM_SPECIES_EVO_1_COUNT ARRAY_COUNT(sRandomSpeciesEvo1)
static const u16 sRandomSpeciesEvo1[] =
{
    SPECIES_IVYSAUR         , //= EVO_TYPE_1,
    SPECIES_CHARMELEON      , //= EVO_TYPE_1,
    SPECIES_WARTORTLE       , //= EVO_TYPE_1,
    SPECIES_METAPOD         , //= EVO_TYPE_1,
    SPECIES_KAKUNA          , //= EVO_TYPE_1,
    SPECIES_PIDGEOTTO       , //= EVO_TYPE_1,
    SPECIES_RATICATE        , //= EVO_TYPE_1,
    SPECIES_FEAROW          , //= EVO_TYPE_1,
    SPECIES_ARBOK           , //= EVO_TYPE_1,
    SPECIES_PIKACHU         , //= EVO_TYPE_1,
    SPECIES_SANDSLASH       , //= EVO_TYPE_1,
    SPECIES_NIDORINA        , //= EVO_TYPE_1,
    SPECIES_NIDORINO        , //= EVO_TYPE_1,
    SPECIES_CLEFAIRY        , //= EVO_TYPE_1,
    SPECIES_NINETALES       , //= EVO_TYPE_1,
    SPECIES_JIGGLYPUFF      , //= EVO_TYPE_1,
    SPECIES_GOLBAT          , //= EVO_TYPE_1,
    SPECIES_GLOOM           , //= EVO_TYPE_1,
    SPECIES_PARASECT        , //= EVO_TYPE_1,
    SPECIES_VENOMOTH        , //= EVO_TYPE_1,
    SPECIES_DUGTRIO         , //= EVO_TYPE_1,
    SPECIES_PERSIAN         , //= EVO_TYPE_1,
    SPECIES_GOLDUCK         , //= EVO_TYPE_1,
    SPECIES_PRIMEAPE        , //= EVO_TYPE_1,
    SPECIES_ARCANINE        , //= EVO_TYPE_1,
    SPECIES_POLIWHIRL       , //= EVO_TYPE_1,
    SPECIES_KADABRA         , //= EVO_TYPE_1,
    SPECIES_MACHOKE         , //= EVO_TYPE_1,
    SPECIES_WEEPINBELL      , //= EVO_TYPE_1,
    SPECIES_TENTACRUEL      , //= EVO_TYPE_1,
    SPECIES_GRAVELER        , //= EVO_TYPE_1,
    SPECIES_RAPIDASH        , //= EVO_TYPE_1,
    SPECIES_MAGNETON        , //= EVO_TYPE_1,
    SPECIES_DODRIO          , //= EVO_TYPE_1,
    SPECIES_DEWGONG         , //= EVO_TYPE_1,
    SPECIES_MUK             , //= EVO_TYPE_1,
    SPECIES_CLOYSTER        , //= EVO_TYPE_1,
    SPECIES_HAUNTER         , //= EVO_TYPE_1,
    SPECIES_HYPNO           , //= EVO_TYPE_1,
    SPECIES_KINGLER         , //= EVO_TYPE_1,
    SPECIES_ELECTRODE       , //= EVO_TYPE_1,
    SPECIES_EXEGGUTOR       , //= EVO_TYPE_1,
    SPECIES_MAROWAK         , //= EVO_TYPE_1,
    SPECIES_HITMONLEE       , //= EVO_TYPE_1,
    SPECIES_HITMONCHAN      , //= EVO_TYPE_1,
    SPECIES_WEEZING         , //= EVO_TYPE_1,
    SPECIES_RHYDON          , //= EVO_TYPE_1,
    SPECIES_CHANSEY         , //= EVO_TYPE_1,
    SPECIES_SEADRA          , //= EVO_TYPE_1,
    SPECIES_SEAKING         , //= EVO_TYPE_1,
    SPECIES_STARMIE         , //= EVO_TYPE_1,
    SPECIES_MR_MIME         , //= EVO_TYPE_1,
    SPECIES_JYNX            , //= EVO_TYPE_1,
    SPECIES_ELECTABUZZ      , //= EVO_TYPE_1,
    SPECIES_MAGMAR          , //= EVO_TYPE_1,
    SPECIES_VAPOREON        , //= EVO_TYPE_1,
    SPECIES_JOLTEON         , //= EVO_TYPE_1,
    SPECIES_FLAREON         , //= EVO_TYPE_1,
    SPECIES_OMASTAR         , //= EVO_TYPE_1,
    SPECIES_KABUTOPS        , //= EVO_TYPE_1,
    SPECIES_DRAGONAIR       , //= EVO_TYPE_1,
    SPECIES_BAYLEEF         , //= EVO_TYPE_1,
    SPECIES_QUILAVA         , //= EVO_TYPE_1,
    SPECIES_CROCONAW        , //= EVO_TYPE_1,
    SPECIES_FURRET          , //= EVO_TYPE_1,
    SPECIES_NOCTOWL         , //= EVO_TYPE_1,
    SPECIES_LEDIAN          , //= EVO_TYPE_1,
    SPECIES_ARIADOS         , //= EVO_TYPE_1,
    SPECIES_LANTURN         , //= EVO_TYPE_1,
    SPECIES_TOGETIC         , //= EVO_TYPE_1,
    SPECIES_XATU            , //= EVO_TYPE_1,
    SPECIES_FLAAFFY         , //= EVO_TYPE_1,
    SPECIES_MARILL          , //= EVO_TYPE_1,
    SPECIES_SKIPLOOM        , //= EVO_TYPE_1,
    SPECIES_SUNFLORA        , //= EVO_TYPE_1,
    SPECIES_QUAGSIRE        , //= EVO_TYPE_1,
    SPECIES_ESPEON          , //= EVO_TYPE_1,
    SPECIES_UMBREON         , //= EVO_TYPE_1,
    SPECIES_WOBBUFFET       , //= EVO_TYPE_1,
    SPECIES_FORRETRESS      , //= EVO_TYPE_1,
    SPECIES_STEELIX         , //= EVO_TYPE_1,
    SPECIES_GRANBULL        , //= EVO_TYPE_1,
    SPECIES_SCIZOR          , //= EVO_TYPE_1,
    SPECIES_URSARING        , //= EVO_TYPE_1,
    SPECIES_MAGCARGO        , //= EVO_TYPE_1,
    SPECIES_PILOSWINE       , //= EVO_TYPE_1,
    SPECIES_OCTILLERY       , //= EVO_TYPE_1,
    SPECIES_MANTINE         , //= EVO_TYPE_1,
    SPECIES_HOUNDOOM        , //= EVO_TYPE_1,
    SPECIES_DONPHAN         , //= EVO_TYPE_1,
    SPECIES_PORYGON2        , //= EVO_TYPE_1,
    SPECIES_HITMONTOP       , //= EVO_TYPE_1,
    SPECIES_PUPITAR         , //= EVO_TYPE_1,
    SPECIES_GROVYLE         , //= EVO_TYPE_1,
    SPECIES_COMBUSKEN       , //= EVO_TYPE_1,
    SPECIES_MARSHTOMP       , //= EVO_TYPE_1,
    SPECIES_MIGHTYENA       , //= EVO_TYPE_1,
    SPECIES_LINOONE         , //= EVO_TYPE_1,
    SPECIES_SILCOON         , //= EVO_TYPE_1,
    SPECIES_CASCOON         , //= EVO_TYPE_1,
    SPECIES_LOMBRE          , //= EVO_TYPE_1,
    SPECIES_NUZLEAF         , //= EVO_TYPE_1,
    SPECIES_NINJASK         , //= EVO_TYPE_1,
    SPECIES_SHEDINJA        , //= EVO_TYPE_1,
    SPECIES_SWELLOW         , //= EVO_TYPE_1,
    SPECIES_BRELOOM         , //= EVO_TYPE_1,
    SPECIES_PELIPPER        , //= EVO_TYPE_1,
    SPECIES_MASQUERAIN      , //= EVO_TYPE_1,
    SPECIES_WAILORD         , //= EVO_TYPE_1,
    SPECIES_DELCATTY        , //= EVO_TYPE_1,
    SPECIES_CLAYDOL         , //= EVO_TYPE_1,
    SPECIES_WHISCASH        , //= EVO_TYPE_1,
    SPECIES_CRAWDAUNT       , //= EVO_TYPE_1,
    SPECIES_MILOTIC         , //= EVO_TYPE_1,
    SPECIES_SHARPEDO        , //= EVO_TYPE_1,
    SPECIES_VIBRAVA         , //= EVO_TYPE_1,
    SPECIES_HARIYAMA        , //= EVO_TYPE_1,
    SPECIES_MANECTRIC       , //= EVO_TYPE_1,
    SPECIES_CAMERUPT        , //= EVO_TYPE_1,
    SPECIES_SEALEO          , //= EVO_TYPE_1,
    SPECIES_CACTURNE        , //= EVO_TYPE_1,
    SPECIES_GLALIE          , //= EVO_TYPE_1,
    SPECIES_GRUMPIG         , //= EVO_TYPE_1,
    SPECIES_MEDICHAM        , //= EVO_TYPE_1,
    SPECIES_ALTARIA         , //= EVO_TYPE_1,
    SPECIES_DUSCLOPS        , //= EVO_TYPE_1,
    SPECIES_ROSELIA         , //= EVO_TYPE_1,
    SPECIES_VIGOROTH        , //= EVO_TYPE_1,
    SPECIES_SWALOT          , //= EVO_TYPE_1,
    SPECIES_LOUDRED         , //= EVO_TYPE_1,
    SPECIES_HUNTAIL         , //= EVO_TYPE_1,
    SPECIES_GOREBYSS        , //= EVO_TYPE_1,
    SPECIES_BANETTE         , //= EVO_TYPE_1,
    SPECIES_LAIRON          , //= EVO_TYPE_1,
    SPECIES_VOLBEAT         , //= EVO_TYPE_1,
    SPECIES_ILLUMISE        , //= EVO_TYPE_1,
    SPECIES_CRADILY         , //= EVO_TYPE_1,
    SPECIES_ARMALDO         , //= EVO_TYPE_1,
    SPECIES_KIRLIA          , //= EVO_TYPE_1,
    SPECIES_SHELGON         , //= EVO_TYPE_1,
    SPECIES_METANG          , //= EVO_TYPE_1,
    SPECIES_CHIMECHO        , //= EVO_TYPE_1,
    SPECIES_AMBIPOM           ,
    SPECIES_FROSLASS          ,
    SPECIES_GLACEON           ,
    SPECIES_GLISCOR           ,
    SPECIES_HONCHKROW         ,
    SPECIES_LEAFEON           ,
    SPECIES_LICKILICKY        ,
    SPECIES_MISMAGIUS         ,
    SPECIES_PROBOPASS         ,
    SPECIES_SYLVEON           ,
    SPECIES_TANGROWTH         ,
    SPECIES_WEAVILE           ,
    SPECIES_YANMEGA           ,
    SPECIES_FARIGIRAF         ,
    SPECIES_DUDUNSPARCE       ,
    SPECIES_WYRDEER           ,
    SPECIES_URSALUNA           ,
    SPECIES_URSALUNA_BLOODMOON           ,
    SPECIES_KLEAVOR           ,
    //SPECIES_UNUSED_SPACE5           ,
    //SPECIES_UNUSED_SPACE6           ,
    //SPECIES_UNUSED_SPACE7           ,
    //SPECIES_UNUSED_SPACE8           ,
    //SPECIES_UNUSED_SPACE9           ,
    //SPECIES_UNUSED_SPACE10            ,
};
#define RANDOM_SPECIES_EVO_2_COUNT ARRAY_COUNT(sRandomSpeciesEvo2)
static const u16 sRandomSpeciesEvo2[] =
{
    SPECIES_VENUSAUR        , //= EVO_TYPE_2,
    SPECIES_CHARIZARD       , //= EVO_TYPE_2,
    SPECIES_BLASTOISE       , //= EVO_TYPE_2,
    SPECIES_BUTTERFREE      , //= EVO_TYPE_2,
    SPECIES_BEEDRILL        , //= EVO_TYPE_2,
    SPECIES_PIDGEOT         , //= EVO_TYPE_2,
    SPECIES_RAICHU          , //= EVO_TYPE_2,
    SPECIES_NIDOQUEEN       , //= EVO_TYPE_2,
    SPECIES_NIDOKING        , //= EVO_TYPE_2,
    SPECIES_CLEFABLE        , //= EVO_TYPE_2,
    SPECIES_WIGGLYTUFF      , //= EVO_TYPE_2,
    SPECIES_VILEPLUME       , //= EVO_TYPE_2,
    SPECIES_POLIWRATH       , //= EVO_TYPE_2,
    SPECIES_ALAKAZAM        , //= EVO_TYPE_2,
    SPECIES_MACHAMP         , //= EVO_TYPE_2,
    SPECIES_VICTREEBEL      , //= EVO_TYPE_2,
    SPECIES_GOLEM           , //= EVO_TYPE_2,
    SPECIES_SLOWBRO         , //= EVO_TYPE_2,
    SPECIES_GENGAR          , //= EVO_TYPE_2,
    SPECIES_GYARADOS        , //= EVO_TYPE_2,
    SPECIES_DRAGONITE       , //= EVO_TYPE_2,
    SPECIES_MEGANIUM        , //= EVO_TYPE_2,
    SPECIES_TYPHLOSION      , //= EVO_TYPE_2,
    SPECIES_FERALIGATR      , //= EVO_TYPE_2,
    SPECIES_CROBAT          , //= EVO_TYPE_2,
    SPECIES_AMPHAROS        , //= EVO_TYPE_2,
    SPECIES_BELLOSSOM       , //= EVO_TYPE_2,
    SPECIES_AZUMARILL       , //= EVO_TYPE_2,
    SPECIES_POLITOED        , //= EVO_TYPE_2,
    SPECIES_JUMPLUFF        , //= EVO_TYPE_2,
    SPECIES_SLOWKING        , //= EVO_TYPE_2,
    SPECIES_KINGDRA         , //= EVO_TYPE_2,
    SPECIES_BLISSEY         , //= EVO_TYPE_2,
    SPECIES_TYRANITAR       , //= EVO_TYPE_2,
    SPECIES_SCEPTILE        , //= EVO_TYPE_2,
    SPECIES_BLAZIKEN        , //= EVO_TYPE_2,
    SPECIES_SWAMPERT        , //= EVO_TYPE_2,
    SPECIES_BEAUTIFLY       , //= EVO_TYPE_2,
    SPECIES_DUSTOX          , //= EVO_TYPE_2,
    SPECIES_LUDICOLO        , //= EVO_TYPE_2,
    SPECIES_SHIFTRY         , //= EVO_TYPE_2,
    SPECIES_FLYGON          , //= EVO_TYPE_2,
    SPECIES_WALREIN         , //= EVO_TYPE_2,
    SPECIES_SLAKING         , //= EVO_TYPE_2,
    SPECIES_EXPLOUD         , //= EVO_TYPE_2,
    SPECIES_AGGRON          , //= EVO_TYPE_2,
    SPECIES_GARDEVOIR       , //= EVO_TYPE_2,
    SPECIES_SALAMENCE       , //= EVO_TYPE_2,
    SPECIES_METAGROSS       , //= EVO_TYPE_2,
    SPECIES_DUSKNOIR          ,
    SPECIES_ELECTIVIRE        ,
    SPECIES_GALLADE           ,
    SPECIES_MAGMORTAR         ,
    SPECIES_MAGNEZONE         ,
    SPECIES_MAMOSWINE         ,
    SPECIES_PORYGON_Z         ,
    SPECIES_RHYPERIOR         ,
    SPECIES_ROSERADE          ,
    SPECIES_TOGEKISS          ,
    SPECIES_ANNIHILAPE        ,
    SPECIES_WYRDEER           ,
    SPECIES_URSALUNA           ,
    SPECIES_URSALUNA_BLOODMOON           ,
    SPECIES_KLEAVOR           ,
    //SPECIES_UNUSED_SPACE5           ,
    //SPECIES_UNUSED_SPACE6           ,
    //SPECIES_UNUSED_SPACE7           ,
    //SPECIES_UNUSED_SPACE8           ,
    //SPECIES_UNUSED_SPACE9           ,
    //SPECIES_UNUSED_SPACE10            ,
};
#define RANDOM_SPECIES_EVO_LEGENDARY_COUNT ARRAY_COUNT(sRandomSpeciesEvoLegendary)
static const u16 sRandomSpeciesEvoLegendary[] =
{
    SPECIES_ARTICUNO                      , //= EVO_TYPE_LEGENDARY,
    SPECIES_ZAPDOS                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_MOLTRES                       , //= EVO_TYPE_LEGENDARY,
    SPECIES_MEWTWO                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_MEW                           , //= EVO_TYPE_LEGENDARY,
    SPECIES_RAIKOU                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_ENTEI                         , //= EVO_TYPE_LEGENDARY,
    SPECIES_SUICUNE                       , //= EVO_TYPE_LEGENDARY,
    SPECIES_LUGIA                         , //= EVO_TYPE_LEGENDARY,
    SPECIES_HO_OH                         , //= EVO_TYPE_LEGENDARY,
    SPECIES_CELEBI                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_REGIROCK                      , //= EVO_TYPE_LEGENDARY,
    SPECIES_REGICE                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_REGISTEEL                     , //= EVO_TYPE_LEGENDARY,
    SPECIES_KYOGRE                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_GROUDON                       , //= EVO_TYPE_LEGENDARY,
    SPECIES_RAYQUAZA                      , //= EVO_TYPE_LEGENDARY,
    SPECIES_LATIAS                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_LATIOS                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_JIRACHI                       , //= EVO_TYPE_LEGENDARY,
    SPECIES_DEOXYS                        , //= EVO_TYPE_LEGENDARY,
    SPECIES_ARCEUS            ,
    SPECIES_REGIDRAGO         ,
    SPECIES_REGIELEKI         ,
    SPECIES_REGIGIGAS         ,
    SPECIES_DEOXYS_ATTACK     ,
    SPECIES_DEOXYS_DEFENSE    ,
    SPECIES_DEOXYS_SPEED      ,
    SPECIES_WYRDEER           ,
    SPECIES_URSALUNA           ,
    SPECIES_URSALUNA_BLOODMOON           ,
    SPECIES_KLEAVOR           ,
    //SPECIES_UNUSED_SPACE5           ,
    //SPECIES_UNUSED_SPACE6           ,
    //SPECIES_UNUSED_SPACE7           ,
    //SPECIES_UNUSED_SPACE8           ,
    //SPECIES_UNUSED_SPACE9           ,
    //SPECIES_UNUSED_SPACE10            ,
};

const u16 gEvolutionLines[NUM_SPECIES][EVOS_PER_LINE] =
{
    [SPECIES_BULBASAUR ... SPECIES_VENUSAUR]    = {SPECIES_BULBASAUR, SPECIES_IVYSAUR, SPECIES_VENUSAUR},
    [SPECIES_CHARMANDER ... SPECIES_CHARIZARD]  = {SPECIES_CHARMANDER, SPECIES_CHARMELEON, SPECIES_CHARIZARD},
    [SPECIES_SQUIRTLE ... SPECIES_BLASTOISE]    = {SPECIES_SQUIRTLE, SPECIES_WARTORTLE, SPECIES_BLASTOISE},
    [SPECIES_CATERPIE ... SPECIES_BUTTERFREE]   = {SPECIES_CATERPIE, SPECIES_METAPOD, SPECIES_BUTTERFREE},
    [SPECIES_WEEDLE ... SPECIES_BEEDRILL]       = {SPECIES_WEEDLE, SPECIES_KAKUNA, SPECIES_BEEDRILL},
    [SPECIES_PIDGEY ... SPECIES_PIDGEOT]        = {SPECIES_PIDGEY, SPECIES_PIDGEOTTO, SPECIES_PIDGEOT},
    [SPECIES_RATTATA ... SPECIES_RATICATE]      = {SPECIES_RATTATA, SPECIES_RATICATE},
    [SPECIES_SPEAROW ... SPECIES_FEAROW]        = {SPECIES_SPEAROW, SPECIES_FEAROW},
    [SPECIES_EKANS ... SPECIES_ARBOK]           = {SPECIES_EKANS, SPECIES_ARBOK},
    [SPECIES_PIKACHU ... SPECIES_RAICHU]        = {SPECIES_PICHU, SPECIES_PIKACHU, SPECIES_RAICHU}, 
    [SPECIES_PICHU]                             = {SPECIES_PICHU, SPECIES_PIKACHU, SPECIES_RAICHU},
    [SPECIES_SANDSHREW ... SPECIES_SANDSLASH]   = {SPECIES_SANDSHREW, SPECIES_SANDSLASH},
    [SPECIES_NIDORAN_F ... SPECIES_NIDOQUEEN]   = {SPECIES_NIDORAN_F, SPECIES_NIDORINA, SPECIES_NIDOQUEEN},
    [SPECIES_NIDORAN_M ... SPECIES_NIDOKING]    = {SPECIES_NIDORAN_M, SPECIES_NIDORINO, SPECIES_NIDOKING},
    [SPECIES_CLEFAIRY ... SPECIES_CLEFABLE]     = {SPECIES_CLEFFA, SPECIES_CLEFAIRY, SPECIES_CLEFABLE},
    [SPECIES_CLEFFA]                            = {SPECIES_CLEFFA, SPECIES_CLEFAIRY, SPECIES_CLEFABLE},
    [SPECIES_VULPIX ... SPECIES_NINETALES]      = {SPECIES_VULPIX, SPECIES_NINETALES},
    [SPECIES_JIGGLYPUFF ... SPECIES_WIGGLYTUFF] = {SPECIES_IGGLYBUFF, SPECIES_JIGGLYPUFF, SPECIES_WIGGLYTUFF},
    [SPECIES_IGGLYBUFF]                         = {SPECIES_IGGLYBUFF, SPECIES_JIGGLYPUFF, SPECIES_WIGGLYTUFF},
    [SPECIES_ZUBAT ... SPECIES_GOLBAT]          = {SPECIES_ZUBAT, SPECIES_GOLBAT, SPECIES_CROBAT},
    [SPECIES_CROBAT]                            = {SPECIES_ZUBAT, SPECIES_GOLBAT, SPECIES_CROBAT},
    [SPECIES_ODDISH ... SPECIES_VILEPLUME]      = {SPECIES_ODDISH, SPECIES_GLOOM, SPECIES_VILEPLUME, SPECIES_BELLOSSOM},
    [SPECIES_BELLOSSOM]                         = {SPECIES_ODDISH, SPECIES_GLOOM, SPECIES_VILEPLUME, SPECIES_BELLOSSOM},
    [SPECIES_PARAS ... SPECIES_PARASECT]        = {SPECIES_PARAS, SPECIES_PARASECT},
    [SPECIES_VENONAT ... SPECIES_VENOMOTH]      = {SPECIES_VENONAT, SPECIES_VENOMOTH},
    [SPECIES_DIGLETT ... SPECIES_DUGTRIO]       = {SPECIES_DIGLETT, SPECIES_DUGTRIO},
    [SPECIES_MEOWTH ... SPECIES_PERSIAN]        = {SPECIES_MEOWTH, SPECIES_PERSIAN},
    [SPECIES_PSYDUCK ... SPECIES_GOLDUCK]       = {SPECIES_PSYDUCK, SPECIES_GOLDUCK},
    [SPECIES_MANKEY ... SPECIES_PRIMEAPE]       = {SPECIES_MANKEY, SPECIES_PRIMEAPE},
    [SPECIES_MANKEY ... SPECIES_PRIMEAPE]     = {SPECIES_MANKEY, SPECIES_PRIMEAPE, SPECIES_ANNIHILAPE},
    [SPECIES_ANNIHILAPE]                      = {SPECIES_MANKEY, SPECIES_PRIMEAPE, SPECIES_ANNIHILAPE},
    [SPECIES_GROWLITHE ... SPECIES_ARCANINE]    = {SPECIES_GROWLITHE, SPECIES_ARCANINE},
    [SPECIES_POLIWAG ... SPECIES_POLIWRATH]     = {SPECIES_POLIWAG, SPECIES_POLIWHIRL, SPECIES_POLIWRATH, SPECIES_POLITOED},
    [SPECIES_POLITOED]                          = {SPECIES_POLIWAG, SPECIES_POLIWHIRL, SPECIES_POLIWRATH, SPECIES_POLITOED},
    [SPECIES_ABRA ... SPECIES_ALAKAZAM]         = {SPECIES_ABRA, SPECIES_KADABRA, SPECIES_ALAKAZAM},
    [SPECIES_MACHOP ... SPECIES_MACHAMP]        = {SPECIES_MACHOP, SPECIES_MACHOKE, SPECIES_MACHAMP},
    [SPECIES_BELLSPROUT ... SPECIES_VICTREEBEL] = {SPECIES_BELLSPROUT, SPECIES_WEEPINBELL, SPECIES_VICTREEBEL},
    [SPECIES_TENTACOOL ... SPECIES_TENTACRUEL]  = {SPECIES_TENTACOOL, SPECIES_TENTACRUEL},
    [SPECIES_GEODUDE ... SPECIES_GOLEM]         = {SPECIES_GEODUDE, SPECIES_GRAVELER, SPECIES_GOLEM},
    [SPECIES_PONYTA ... SPECIES_RAPIDASH]       = {SPECIES_PONYTA, SPECIES_RAPIDASH},
    [SPECIES_SLOWPOKE ... SPECIES_SLOWBRO]      = {SPECIES_SLOWPOKE, SPECIES_SLOWBRO, SPECIES_SLOWKING},
    [SPECIES_SLOWKING]                          = {SPECIES_SLOWPOKE, SPECIES_SLOWBRO, SPECIES_SLOWKING},
    [SPECIES_MAGNEMITE ... SPECIES_MAGNETON]    = {SPECIES_MAGNEMITE, SPECIES_MAGNETON, SPECIES_MAGNEZONE},
    [SPECIES_MAGNEZONE]                         = {SPECIES_MAGNEMITE, SPECIES_MAGNETON, SPECIES_MAGNEZONE},
    [SPECIES_DODUO ... SPECIES_DODRIO]          = {SPECIES_DODUO, SPECIES_DODRIO},
    [SPECIES_SEEL ... SPECIES_DEWGONG]          = {SPECIES_SEEL, SPECIES_DEWGONG},
    [SPECIES_GRIMER ... SPECIES_MUK]            = {SPECIES_GRIMER, SPECIES_MUK},
    [SPECIES_SHELLDER ... SPECIES_CLOYSTER]     = {SPECIES_SHELLDER, SPECIES_CLOYSTER},
    [SPECIES_GASTLY ... SPECIES_GENGAR]         = {SPECIES_GASTLY, SPECIES_HAUNTER, SPECIES_GENGAR},
    [SPECIES_ONIX]                              = {SPECIES_ONIX, SPECIES_STEELIX},
    [SPECIES_STEELIX]                           = {SPECIES_ONIX, SPECIES_STEELIX},
    [SPECIES_DROWZEE ... SPECIES_HYPNO]         = {SPECIES_DROWZEE, SPECIES_HYPNO},
    [SPECIES_KRABBY ... SPECIES_KINGLER]        = {SPECIES_KRABBY, SPECIES_KINGLER},
    [SPECIES_VOLTORB ... SPECIES_ELECTRODE]     = {SPECIES_VOLTORB, SPECIES_ELECTRODE},
    [SPECIES_EXEGGCUTE ... SPECIES_EXEGGUTOR]   = {SPECIES_EXEGGCUTE, SPECIES_EXEGGUTOR},
    [SPECIES_CUBONE ... SPECIES_MAROWAK]        = {SPECIES_CUBONE, SPECIES_MAROWAK},
    [SPECIES_HITMONLEE ... SPECIES_HITMONCHAN]  = {SPECIES_TYROGUE, SPECIES_HITMONCHAN, SPECIES_HITMONLEE, SPECIES_HITMONTOP},
    [SPECIES_TYROGUE ... SPECIES_HITMONTOP]     = {SPECIES_TYROGUE, SPECIES_HITMONCHAN, SPECIES_HITMONLEE, SPECIES_HITMONTOP},
    [SPECIES_LICKITUNG]                         = {SPECIES_LICKITUNG, SPECIES_LICKILICKY},
    [SPECIES_LICKILICKY]                        = {SPECIES_LICKITUNG, SPECIES_LICKILICKY},
    [SPECIES_KOFFING ... SPECIES_WEEZING]       = {SPECIES_KOFFING, SPECIES_WEEZING},
    [SPECIES_RHYHORN ... SPECIES_RHYDON]        = {SPECIES_RHYHORN, SPECIES_RHYDON, SPECIES_RHYPERIOR},
    [SPECIES_RHYPERIOR]                         = {SPECIES_RHYHORN, SPECIES_RHYDON, SPECIES_RHYPERIOR},
    [SPECIES_CHANSEY]                           = {SPECIES_HAPPINY, SPECIES_CHANSEY, SPECIES_BLISSEY},
    [SPECIES_BLISSEY]                           = {SPECIES_HAPPINY, SPECIES_CHANSEY, SPECIES_BLISSEY},
    [SPECIES_HAPPINY]                           = {SPECIES_HAPPINY, SPECIES_CHANSEY, SPECIES_BLISSEY},
    [SPECIES_TANGELA]                           = {SPECIES_TANGELA, SPECIES_TANGROWTH},
    [SPECIES_TANGROWTH]                         = {SPECIES_TANGELA, SPECIES_TANGROWTH},
    [SPECIES_KOFFING ... SPECIES_WEEZING]       = {SPECIES_KOFFING, SPECIES_WEEZING},
    [SPECIES_HORSEA ... SPECIES_SEADRA]         = {SPECIES_HORSEA, SPECIES_SEADRA, SPECIES_KINGDRA},
    [SPECIES_KINGDRA]                           = {SPECIES_HORSEA, SPECIES_SEADRA, SPECIES_KINGDRA},
    [SPECIES_GOLDEEN ... SPECIES_SEAKING]       = {SPECIES_GOLDEEN, SPECIES_SEAKING},
    [SPECIES_STARYU ... SPECIES_STARMIE]        = {SPECIES_STARYU, SPECIES_STARMIE},
    [SPECIES_MR_MIME]                           = {SPECIES_MIME_JR, SPECIES_MR_MIME},
    [SPECIES_MIME_JR]                           = {SPECIES_MIME_JR, SPECIES_MR_MIME},
    [SPECIES_SCYTHER]                           = {SPECIES_SCYTHER, SPECIES_SCIZOR},
    [SPECIES_JYNX]                              = {SPECIES_SMOOCHUM, SPECIES_JYNX},
    [SPECIES_SMOOCHUM]                          = {SPECIES_SMOOCHUM, SPECIES_JYNX},
    [SPECIES_ELECTABUZZ]                        = {SPECIES_ELEKID, SPECIES_ELECTABUZZ, SPECIES_ELECTIVIRE},
    [SPECIES_ELEKID]                            = {SPECIES_ELEKID, SPECIES_ELECTABUZZ, SPECIES_ELECTIVIRE},
    [SPECIES_ELECTIVIRE]                        = {SPECIES_ELEKID, SPECIES_ELECTABUZZ, SPECIES_ELECTIVIRE},
    [SPECIES_MAGBY]                             = {SPECIES_MAGBY, SPECIES_MAGMAR, SPECIES_MAGMORTAR},
    [SPECIES_MAGMAR]                            = {SPECIES_MAGBY, SPECIES_MAGMAR, SPECIES_MAGMORTAR},
    [SPECIES_MAGMORTAR]                         = {SPECIES_MAGBY, SPECIES_MAGMAR, SPECIES_MAGMORTAR},
    [SPECIES_SCIZOR]                            = {SPECIES_SCYTHER, SPECIES_SCIZOR},
    [SPECIES_MAGIKARP ... SPECIES_GYARADOS]     = {SPECIES_MAGIKARP, SPECIES_GYARADOS},
    [SPECIES_EEVEE ... SPECIES_FLAREON]         = {SPECIES_EEVEE, SPECIES_JOLTEON, SPECIES_VAPOREON, SPECIES_FLAREON, SPECIES_ESPEON, SPECIES_UMBREON, SPECIES_LEAFEON, SPECIES_GLACEON, SPECIES_SYLVEON},
    [SPECIES_ESPEON ... SPECIES_UMBREON]        = {SPECIES_EEVEE, SPECIES_JOLTEON, SPECIES_VAPOREON, SPECIES_FLAREON, SPECIES_ESPEON, SPECIES_UMBREON, SPECIES_LEAFEON, SPECIES_GLACEON, SPECIES_SYLVEON},
    [SPECIES_LEAFEON]                           = {SPECIES_EEVEE, SPECIES_JOLTEON, SPECIES_VAPOREON, SPECIES_FLAREON, SPECIES_ESPEON, SPECIES_UMBREON, SPECIES_LEAFEON, SPECIES_GLACEON, SPECIES_SYLVEON},
    [SPECIES_GLACEON]                           = {SPECIES_EEVEE, SPECIES_JOLTEON, SPECIES_VAPOREON, SPECIES_FLAREON, SPECIES_ESPEON, SPECIES_UMBREON, SPECIES_LEAFEON, SPECIES_GLACEON, SPECIES_SYLVEON},
    [SPECIES_SYLVEON]                           = {SPECIES_EEVEE, SPECIES_JOLTEON, SPECIES_VAPOREON, SPECIES_FLAREON, SPECIES_ESPEON, SPECIES_UMBREON, SPECIES_LEAFEON, SPECIES_GLACEON, SPECIES_SYLVEON},
    [SPECIES_PORYGON]                           = {SPECIES_PORYGON, SPECIES_PORYGON2, SPECIES_PORYGON_Z},
    [SPECIES_PORYGON2]                          = {SPECIES_PORYGON, SPECIES_PORYGON2, SPECIES_PORYGON_Z},
    [SPECIES_PORYGON_Z]                         = {SPECIES_PORYGON, SPECIES_PORYGON2, SPECIES_PORYGON_Z},
    [SPECIES_OMANYTE ... SPECIES_OMASTAR]       = {SPECIES_OMANYTE, SPECIES_OMASTAR},
    [SPECIES_KABUTO ... SPECIES_KABUTOPS]       = {SPECIES_KABUTO, SPECIES_KABUTOPS},
    [SPECIES_SNORLAX]                           = {SPECIES_MUNCHLAX, SPECIES_SNORLAX},
    [SPECIES_MUNCHLAX]                          = {SPECIES_MUNCHLAX, SPECIES_SNORLAX},
    [SPECIES_DRATINI ... SPECIES_DRAGONITE]     = {SPECIES_DRATINI, SPECIES_DRAGONAIR, SPECIES_DRAGONITE},
    [SPECIES_CHIKORITA ... SPECIES_MEGANIUM]    = {SPECIES_CHIKORITA, SPECIES_BAYLEEF, SPECIES_MEGANIUM},
    [SPECIES_CYNDAQUIL ... SPECIES_TYPHLOSION]  = {SPECIES_CYNDAQUIL, SPECIES_QUILAVA, SPECIES_TYPHLOSION},
    [SPECIES_TOTODILE ... SPECIES_FERALIGATR]   = {SPECIES_TOTODILE, SPECIES_CROCONAW, SPECIES_FERALIGATR},
    [SPECIES_SENTRET ... SPECIES_FURRET]        = {SPECIES_SENTRET, SPECIES_FURRET},
    [SPECIES_HOOTHOOT ... SPECIES_NOCTOWL]      = {SPECIES_HOOTHOOT, SPECIES_NOCTOWL},
    [SPECIES_LEDYBA ... SPECIES_LEDIAN]         = {SPECIES_LEDYBA, SPECIES_LEDIAN},
    [SPECIES_SPINARAK ... SPECIES_ARIADOS]      = {SPECIES_SPINARAK, SPECIES_ARIADOS},
    [SPECIES_CHINCHOU ... SPECIES_LANTURN]      = {SPECIES_CHINCHOU, SPECIES_LANTURN},
    [SPECIES_TOGEPI ... SPECIES_TOGETIC]        = {SPECIES_TOGEPI, SPECIES_TOGETIC, SPECIES_TOGEKISS},
    [SPECIES_TOGEKISS]                          = {SPECIES_TOGEPI, SPECIES_TOGETIC, SPECIES_TOGEKISS},
    [SPECIES_NATU ... SPECIES_XATU]             = {SPECIES_NATU, SPECIES_XATU},
    [SPECIES_MAREEP ... SPECIES_AMPHAROS]       = {SPECIES_MAREEP, SPECIES_FLAAFFY, SPECIES_AMPHAROS},
    [SPECIES_MARILL ... SPECIES_AZUMARILL]      = {SPECIES_AZURILL, SPECIES_MARILL, SPECIES_AZUMARILL},
    [SPECIES_AZURILL]                           = {SPECIES_AZURILL, SPECIES_MARILL, SPECIES_AZUMARILL},
    [SPECIES_SUDOWOODO]                         = {SPECIES_BONSLY, SPECIES_SUDOWOODO},
    [SPECIES_BONSLY]                            = {SPECIES_BONSLY, SPECIES_SUDOWOODO},
    [SPECIES_HOPPIP ... SPECIES_JUMPLUFF]       = {SPECIES_HOPPIP, SPECIES_SKIPLOOM, SPECIES_JUMPLUFF},
    [SPECIES_AIPOM]                             = {SPECIES_AIPOM, SPECIES_AMBIPOM},
    [SPECIES_AMBIPOM]                           = {SPECIES_AIPOM, SPECIES_AMBIPOM},
    [SPECIES_SUNKERN ... SPECIES_SUNFLORA]      = {SPECIES_SUNKERN, SPECIES_SUNFLORA},
    [SPECIES_YANMA]                             = {SPECIES_YANMA, SPECIES_YANMEGA},
    [SPECIES_YANMEGA]                           = {SPECIES_YANMA, SPECIES_YANMEGA},
    [SPECIES_WOOPER ... SPECIES_QUAGSIRE]       = {SPECIES_WOOPER, SPECIES_QUAGSIRE},
    [SPECIES_MURKROW]                           = {SPECIES_MURKROW, SPECIES_HONCHKROW},
    [SPECIES_HONCHKROW]                         = {SPECIES_MURKROW, SPECIES_HONCHKROW},
    [SPECIES_MISDREAVUS]                        = {SPECIES_MISDREAVUS, SPECIES_MISMAGIUS},
    [SPECIES_MISMAGIUS]                         = {SPECIES_MISDREAVUS, SPECIES_MISMAGIUS},
    [SPECIES_WOBBUFFET]                         = {SPECIES_WYNAUT, SPECIES_WOBBUFFET},
    [SPECIES_WYNAUT]                            = {SPECIES_WYNAUT, SPECIES_WOBBUFFET},
    [SPECIES_PINECO ... SPECIES_FORRETRESS]     = {SPECIES_PINECO, SPECIES_FORRETRESS},
    [SPECIES_GLIGAR]                            = {SPECIES_GLIGAR, SPECIES_GLISCOR},
    [SPECIES_GLISCOR]                           = {SPECIES_GLIGAR, SPECIES_GLISCOR},
    [SPECIES_SNUBBULL ... SPECIES_GRANBULL]     = {SPECIES_SNUBBULL, SPECIES_GRANBULL},
    [SPECIES_SNEASEL]                           = {SPECIES_SNEASEL, SPECIES_WEAVILE},
    [SPECIES_WEAVILE]                           = {SPECIES_SNEASEL, SPECIES_WEAVILE},
    [SPECIES_TEDDIURSA ... SPECIES_URSARING]    = {SPECIES_TEDDIURSA, SPECIES_URSARING},
    [SPECIES_SLUGMA ... SPECIES_MAGCARGO]       = {SPECIES_SLUGMA, SPECIES_MAGCARGO},
    [SPECIES_SWINUB ... SPECIES_PILOSWINE]      = {SPECIES_SWINUB, SPECIES_PILOSWINE, SPECIES_MAMOSWINE},
    [SPECIES_MAMOSWINE]                         = {SPECIES_SWINUB, SPECIES_PILOSWINE, SPECIES_MAMOSWINE},
    [SPECIES_REMORAID ... SPECIES_OCTILLERY]    = {SPECIES_REMORAID, SPECIES_OCTILLERY},
    [SPECIES_MANTINE]                           = {SPECIES_MANTYKE, SPECIES_MANTINE},
    [SPECIES_MANTYKE]                           = {SPECIES_MANTYKE, SPECIES_MANTINE},
    [SPECIES_HOUNDOUR ... SPECIES_HOUNDOOM]     = {SPECIES_HOUNDOUR, SPECIES_HOUNDOOM},
    [SPECIES_PHANPY ... SPECIES_DONPHAN]        = {SPECIES_PHANPY, SPECIES_DONPHAN},
    [SPECIES_LARVITAR ... SPECIES_TYRANITAR]    = {SPECIES_LARVITAR, SPECIES_PUPITAR, SPECIES_TYRANITAR},
    [SPECIES_TREECKO ... SPECIES_SCEPTILE]      = {SPECIES_TREECKO, SPECIES_GROVYLE, SPECIES_SCEPTILE},
    [SPECIES_TORCHIC ... SPECIES_BLAZIKEN]      = {SPECIES_TORCHIC, SPECIES_COMBUSKEN, SPECIES_BLAZIKEN},
    [SPECIES_MUDKIP ... SPECIES_SWAMPERT]       = {SPECIES_MUDKIP, SPECIES_MARSHTOMP, SPECIES_SWAMPERT},
    [SPECIES_POOCHYENA ... SPECIES_MIGHTYENA]   = {SPECIES_POOCHYENA, SPECIES_MIGHTYENA},
    [SPECIES_ZIGZAGOON ... SPECIES_LINOONE]     = {SPECIES_ZIGZAGOON, SPECIES_LINOONE},
    [SPECIES_WURMPLE ... SPECIES_DUSTOX]        = {SPECIES_WURMPLE, SPECIES_SILCOON, SPECIES_BEAUTIFLY, SPECIES_CASCOON, SPECIES_DUSTOX},
    [SPECIES_LOTAD ... SPECIES_LUDICOLO]        = {SPECIES_LOTAD, SPECIES_LOMBRE, SPECIES_LUDICOLO},
    [SPECIES_SEEDOT ... SPECIES_SHIFTRY]        = {SPECIES_SEEDOT, SPECIES_NUZLEAF, SPECIES_SHIFTRY},
    [SPECIES_NINCADA ... SPECIES_SHEDINJA]      = {SPECIES_NINCADA, SPECIES_NINJASK, SPECIES_SHEDINJA},
    [SPECIES_TAILLOW ... SPECIES_SWELLOW]       = {SPECIES_TAILLOW, SPECIES_SWELLOW},
    [SPECIES_SHROOMISH ... SPECIES_BRELOOM]     = {SPECIES_SHROOMISH, SPECIES_BRELOOM},
    [SPECIES_WINGULL ... SPECIES_PELIPPER]      = {SPECIES_WINGULL, SPECIES_PELIPPER},
    [SPECIES_SURSKIT ... SPECIES_MASQUERAIN]    = {SPECIES_SURSKIT, SPECIES_MASQUERAIN},
    [SPECIES_WAILMER ... SPECIES_WAILORD]       = {SPECIES_WAILMER, SPECIES_WAILORD},
    [SPECIES_NOSEPASS]                          = {SPECIES_NOSEPASS, SPECIES_PROBOPASS},
    [SPECIES_PROBOPASS]                         = {SPECIES_NOSEPASS, SPECIES_PROBOPASS},
    [SPECIES_SKITTY ... SPECIES_DELCATTY]       = {SPECIES_SKITTY, SPECIES_DELCATTY},
    [SPECIES_BALTOY ... SPECIES_CLAYDOL]        = {SPECIES_BALTOY, SPECIES_CLAYDOL},
    [SPECIES_BARBOACH ... SPECIES_WHISCASH]     = {SPECIES_BARBOACH, SPECIES_WHISCASH},
    [SPECIES_CORPHISH ... SPECIES_CRAWDAUNT]    = {SPECIES_CORPHISH, SPECIES_CRAWDAUNT},
    [SPECIES_FEEBAS ... SPECIES_MILOTIC]        = {SPECIES_FEEBAS, SPECIES_MILOTIC},
    [SPECIES_CARVANHA ... SPECIES_SHARPEDO]     = {SPECIES_CARVANHA, SPECIES_SHARPEDO},
    [SPECIES_TRAPINCH ... SPECIES_FLYGON]       = {SPECIES_TRAPINCH, SPECIES_VIBRAVA, SPECIES_FLYGON},
    [SPECIES_MAKUHITA ... SPECIES_HARIYAMA]     = {SPECIES_MAKUHITA, SPECIES_HARIYAMA},
    [SPECIES_ELECTRIKE ... SPECIES_MANECTRIC]   = {SPECIES_ELECTRIKE, SPECIES_MANECTRIC},
    [SPECIES_NUMEL ... SPECIES_CAMERUPT]        = {SPECIES_NUMEL, SPECIES_CAMERUPT},
    [SPECIES_SPHEAL ... SPECIES_WALREIN]        = {SPECIES_SPHEAL, SPECIES_SEALEO, SPECIES_WALREIN},
    [SPECIES_CACNEA ... SPECIES_CACTURNE]       = {SPECIES_CACNEA, SPECIES_CACTURNE},
    [SPECIES_SNORUNT ... SPECIES_GLALIE]        = {SPECIES_SNORUNT, SPECIES_GLALIE, SPECIES_FROSLASS},
    [SPECIES_FROSLASS]                          = {SPECIES_SNORUNT, SPECIES_GLALIE, SPECIES_FROSLASS},
    [SPECIES_SPOINK ... SPECIES_GRUMPIG]        = {SPECIES_SPOINK, SPECIES_GRUMPIG},
    [SPECIES_MEDITITE ... SPECIES_MEDICHAM]     = {SPECIES_MEDITITE, SPECIES_MEDICHAM},
    [SPECIES_SWABLU ... SPECIES_ALTARIA]        = {SPECIES_SWABLU, SPECIES_ALTARIA},
    [SPECIES_DUSKULL ... SPECIES_DUSCLOPS]      = {SPECIES_DUSKULL, SPECIES_DUSCLOPS, SPECIES_DUSKNOIR},
    [SPECIES_DUSKNOIR]                          = {SPECIES_DUSKULL, SPECIES_DUSCLOPS, SPECIES_DUSKNOIR},
    [SPECIES_SLAKOTH ... SPECIES_SLAKING]       = {SPECIES_SLAKOTH, SPECIES_VIGOROTH, SPECIES_SLAKING},
    [SPECIES_ROSELIA]                           = {SPECIES_BUDEW, SPECIES_ROSELIA, SPECIES_ROSERADE},
    [SPECIES_BUDEW ... SPECIES_ROSERADE]        = {SPECIES_BUDEW, SPECIES_ROSELIA, SPECIES_ROSERADE},
    [SPECIES_ROSERADE]                          = {SPECIES_BUDEW, SPECIES_ROSELIA, SPECIES_ROSERADE},
    [SPECIES_GULPIN ... SPECIES_SWALOT]         = {SPECIES_GULPIN, SPECIES_SWALOT},
    [SPECIES_WHISMUR ... SPECIES_EXPLOUD]       = {SPECIES_WHISMUR, SPECIES_LOUDRED, SPECIES_EXPLOUD},
    [SPECIES_CLAMPERL ... SPECIES_GOREBYSS]     = {SPECIES_CLAMPERL, SPECIES_HUNTAIL, SPECIES_GOREBYSS},
    [SPECIES_SHUPPET ... SPECIES_BANETTE]       = {SPECIES_SHUPPET, SPECIES_BANETTE},
    [SPECIES_ARON ... SPECIES_AGGRON]           = {SPECIES_ARON, SPECIES_LAIRON, SPECIES_AGGRON},
    [SPECIES_LILEEP ... SPECIES_CRADILY]        = {SPECIES_LILEEP, SPECIES_CRADILY},
    [SPECIES_ANORITH ... SPECIES_ARMALDO]       = {SPECIES_ANORITH, SPECIES_ARMALDO},
    [SPECIES_RALTS ... SPECIES_GARDEVOIR]       = {SPECIES_RALTS, SPECIES_KIRLIA, SPECIES_GARDEVOIR, SPECIES_GALLADE},
    [SPECIES_GALLADE]                           = {SPECIES_RALTS, SPECIES_KIRLIA, SPECIES_GARDEVOIR, SPECIES_GALLADE},
    [SPECIES_BAGON ... SPECIES_SALAMENCE]       = {SPECIES_BAGON, SPECIES_SHELGON, SPECIES_SALAMENCE},
    [SPECIES_BELDUM ... SPECIES_METAGROSS]      = {SPECIES_BELDUM, SPECIES_METANG, SPECIES_METAGROSS},
    [SPECIES_DEOXYS]                            = {SPECIES_DEOXYS, SPECIES_DEOXYS_ATTACK, SPECIES_DEOXYS_DEFENSE, SPECIES_DEOXYS_SPEED},
    [SPECIES_DEOXYS_ATTACK ... SPECIES_DEOXYS_SPEED] = {SPECIES_DEOXYS, SPECIES_DEOXYS_ATTACK, SPECIES_DEOXYS_DEFENSE, SPECIES_DEOXYS_SPEED},
    [SPECIES_CHIMECHO]                          = {SPECIES_CHINGLING, SPECIES_CHIMECHO},
    [SPECIES_CHINGLING]                         = {SPECIES_CHINGLING, SPECIES_CHIMECHO},
    [SPECIES_DUNSPARCE]                         = {SPECIES_DUNSPARCE, SPECIES_DUDUNSPARCE},
    [SPECIES_DUDUNSPARCE]                       = {SPECIES_DUNSPARCE, SPECIES_DUDUNSPARCE},
    [SPECIES_GIRAFARIG]                         = {SPECIES_GIRAFARIG, SPECIES_FARIGIRAF},
    [SPECIES_FARIGIRAF]                         = {SPECIES_GIRAFARIG, SPECIES_FARIGIRAF},
};

#define RANDOM_TYPE_COUNT ARRAY_COUNT(sOneTypeChallengeValidTypes)
static const u8  sOneTypeChallengeValidTypes[NUMBER_OF_MON_TYPES-1] =
{
    TYPE_NORMAL   ,
    TYPE_FIGHTING ,
    TYPE_FLYING   ,
    TYPE_POISON   ,
    TYPE_GROUND   ,
    TYPE_ROCK     ,
    TYPE_BUG      ,
    TYPE_GHOST    ,
    TYPE_STEEL    ,
    TYPE_FIRE     ,
    TYPE_WATER    ,
    TYPE_GRASS    ,
    TYPE_ELECTRIC ,
    TYPE_PSYCHIC  ,
    TYPE_ICE      ,
    TYPE_DRAGON   ,
    TYPE_DARK     ,
    TYPE_FAIRY    ,

};

#define RANDOM_MOVES_COUNT ARRAY_COUNT(sRandomValidMoves)
static const u16 sRandomValidMoves[MOVES_COUNT-1] =
{
    MOVE_POUND,
    MOVE_KARATE_CHOP,
    MOVE_DOUBLE_SLAP,
    MOVE_COMET_PUNCH,
    MOVE_MEGA_PUNCH,
    MOVE_PAY_DAY,
    MOVE_FIRE_PUNCH,
    MOVE_ICE_PUNCH,
    MOVE_THUNDER_PUNCH,
    MOVE_SCRATCH,
    MOVE_VICE_GRIP,
    MOVE_GUILLOTINE,
    MOVE_RAZOR_WIND,
    MOVE_SWORDS_DANCE,
    MOVE_CUT,
    MOVE_GUST,
    MOVE_WING_ATTACK,
    MOVE_WHIRLWIND,
    MOVE_FLY,
    MOVE_BIND,
    MOVE_SLAM,
    MOVE_VINE_WHIP,
    MOVE_STOMP,
    MOVE_DOUBLE_KICK,
    MOVE_MEGA_KICK,
    MOVE_JUMP_KICK,
    MOVE_ROLLING_KICK,
    MOVE_SAND_ATTACK,
    MOVE_HEADBUTT,
    MOVE_HORN_ATTACK,
    MOVE_FURY_ATTACK,
    MOVE_HORN_DRILL,
    MOVE_TACKLE,
    MOVE_BODY_SLAM,
    MOVE_WRAP,
    MOVE_TAKE_DOWN,
    MOVE_THRASH,
    MOVE_DOUBLE_EDGE,
    MOVE_TAIL_WHIP,
    MOVE_POISON_STING,
    MOVE_TWINEEDLE,
    MOVE_PIN_MISSILE,
    MOVE_LEER,
    MOVE_BITE,
    MOVE_GROWL,
    MOVE_ROAR,
    MOVE_SING,
    MOVE_SUPERSONIC,
    MOVE_SONIC_BOOM,
    MOVE_DISABLE,
    MOVE_ACID,
    MOVE_EMBER,
    MOVE_FLAMETHROWER,
    MOVE_MIST,
    MOVE_WATER_GUN,
    MOVE_HYDRO_PUMP,
    MOVE_SURF,
    MOVE_ICE_BEAM,
    MOVE_BLIZZARD,
    MOVE_PSYBEAM,
    MOVE_BUBBLE_BEAM,
    MOVE_AURORA_BEAM,
    MOVE_HYPER_BEAM,
    MOVE_PECK,
    MOVE_DRILL_PECK,
    MOVE_SUBMISSION,
    MOVE_LOW_KICK,
    MOVE_COUNTER,
    MOVE_SEISMIC_TOSS,
    MOVE_STRENGTH,
    MOVE_ABSORB,
    MOVE_MEGA_DRAIN,
    MOVE_LEECH_SEED,
    MOVE_GROWTH,
    MOVE_RAZOR_LEAF,
    MOVE_SOLAR_BEAM,
    MOVE_POISON_POWDER,
    MOVE_STUN_SPORE,
    MOVE_SLEEP_POWDER,
    MOVE_PETAL_DANCE,
    MOVE_STRING_SHOT,
    MOVE_DRAGON_RAGE,
    MOVE_FIRE_SPIN,
    MOVE_THUNDER_SHOCK,
    MOVE_THUNDERBOLT,
    MOVE_THUNDER_WAVE,
    MOVE_THUNDER,
    MOVE_ROCK_THROW,
    MOVE_EARTHQUAKE,
    MOVE_FISSURE,
    MOVE_DIG,
    MOVE_TOXIC,
    MOVE_CONFUSION,
    MOVE_PSYCHIC,
    MOVE_HYPNOSIS,
    MOVE_MEDITATE,
    MOVE_AGILITY,
    MOVE_QUICK_ATTACK,
    MOVE_RAGE,
    MOVE_TELEPORT,
    MOVE_NIGHT_SHADE,
    MOVE_MIMIC,
    MOVE_SCREECH,
    MOVE_DOUBLE_TEAM,
    MOVE_RECOVER,
    MOVE_HARDEN,
    MOVE_MINIMIZE,
    MOVE_SMOKESCREEN,
    MOVE_CONFUSE_RAY,
    MOVE_WITHDRAW,
    MOVE_DEFENSE_CURL,
    MOVE_BARRIER,
    MOVE_LIGHT_SCREEN,
    MOVE_HAZE,
    MOVE_REFLECT,
    MOVE_FOCUS_ENERGY,
    MOVE_BIDE,
    MOVE_METRONOME,
    MOVE_MIRROR_MOVE,
    MOVE_SELF_DESTRUCT,
    MOVE_EGG_BOMB,
    MOVE_LICK,
    MOVE_SMOG,
    MOVE_SLUDGE,
    MOVE_BONE_CLUB,
    MOVE_FIRE_BLAST,
    MOVE_WATERFALL,
    MOVE_CLAMP,
    MOVE_SWIFT,
    MOVE_SKULL_BASH,
    MOVE_SPIKE_CANNON,
    MOVE_CONSTRICT,
    MOVE_AMNESIA,
    MOVE_KINESIS,
    MOVE_SOFT_BOILED,
    MOVE_HI_JUMP_KICK,
    MOVE_GLARE,
    MOVE_DREAM_EATER,
    MOVE_POISON_GAS,
    MOVE_BARRAGE,
    MOVE_LEECH_LIFE,
    MOVE_LOVELY_KISS,
    MOVE_SKY_ATTACK,
    MOVE_TRANSFORM,
    MOVE_BUBBLE,
    MOVE_DIZZY_PUNCH,
    MOVE_SPORE,
    MOVE_FLASH,
    MOVE_PSYWAVE,
    MOVE_SPLASH,
    MOVE_ACID_ARMOR,
    MOVE_CRABHAMMER,
    MOVE_EXPLOSION,
    MOVE_FURY_SWIPES,
    MOVE_BONEMERANG,
    MOVE_REST,
    MOVE_ROCK_SLIDE,
    MOVE_HYPER_FANG,
    MOVE_SHARPEN,
    MOVE_CONVERSION,
    MOVE_TRI_ATTACK,
    MOVE_SUPER_FANG,
    MOVE_SLASH,
    MOVE_SUBSTITUTE,
    MOVE_STRUGGLE,
    MOVE_SKETCH,
    MOVE_TRIPLE_KICK,
    MOVE_THIEF,
    MOVE_SPIDER_WEB,
    MOVE_MIND_READER,
    MOVE_NIGHTMARE,
    MOVE_FLAME_WHEEL,
    MOVE_SNORE,
    MOVE_CURSE,
    MOVE_FLAIL,
    MOVE_CONVERSION_2,
    MOVE_AEROBLAST,
    MOVE_COTTON_SPORE,
    MOVE_REVERSAL,
    MOVE_SPITE,
    MOVE_POWDER_SNOW,
    MOVE_PROTECT,
    MOVE_MACH_PUNCH,
    MOVE_SCARY_FACE,
    MOVE_FAINT_ATTACK,
    MOVE_SWEET_KISS,
    MOVE_BELLY_DRUM,
    MOVE_SLUDGE_BOMB,
    MOVE_MUD_SLAP,
    MOVE_OCTAZOOKA,
    MOVE_SPIKES,
    MOVE_ZAP_CANNON,
    MOVE_FORESIGHT,
    MOVE_DESTINY_BOND,
    MOVE_PERISH_SONG,
    MOVE_ICY_WIND,
    MOVE_DETECT,
    MOVE_BONE_RUSH,
    MOVE_LOCK_ON,
    MOVE_OUTRAGE,
    MOVE_SANDSTORM,
    MOVE_GIGA_DRAIN,
    MOVE_ENDURE,
    MOVE_CHARM,
    MOVE_ROLLOUT,
    MOVE_FALSE_SWIPE,
    MOVE_SWAGGER,
    MOVE_MILK_DRINK,
    MOVE_SPARK,
    MOVE_FURY_CUTTER,
    MOVE_STEEL_WING,
    MOVE_MEAN_LOOK,
    MOVE_ATTRACT,
    MOVE_SLEEP_TALK,
    MOVE_HEAL_BELL,
    MOVE_RETURN,
    MOVE_PRESENT,
    MOVE_FRUSTRATION,
    MOVE_SAFEGUARD,
    MOVE_PAIN_SPLIT,
    MOVE_SACRED_FIRE,
    MOVE_MAGNITUDE,
    MOVE_DYNAMIC_PUNCH,
    MOVE_MEGAHORN,
    MOVE_DRAGON_BREATH,
    MOVE_BATON_PASS,
    MOVE_ENCORE,
    MOVE_PURSUIT,
    MOVE_RAPID_SPIN,
    MOVE_SWEET_SCENT,
    MOVE_IRON_TAIL,
    MOVE_METAL_CLAW,
    MOVE_VITAL_THROW,
    MOVE_MORNING_SUN,
    MOVE_SYNTHESIS,
    MOVE_MOONLIGHT,
    MOVE_HIDDEN_POWER,
    MOVE_CROSS_CHOP,
    MOVE_TWISTER,
    MOVE_RAIN_DANCE,
    MOVE_SUNNY_DAY,
    MOVE_CRUNCH,
    MOVE_MIRROR_COAT,
    MOVE_PSYCH_UP,
    MOVE_EXTREME_SPEED,
    MOVE_ANCIENT_POWER,
    MOVE_SHADOW_BALL,
    MOVE_FUTURE_SIGHT,
    MOVE_ROCK_SMASH,
    MOVE_WHIRLPOOL,
    MOVE_BEAT_UP,
    MOVE_FAKE_OUT,
    MOVE_UPROAR,
    MOVE_STOCKPILE,
    MOVE_SPIT_UP,
    MOVE_SWALLOW,
    MOVE_HEAT_WAVE,
    MOVE_HAIL,
    MOVE_TORMENT,
    MOVE_FLATTER,
    MOVE_WILL_O_WISP,
    MOVE_MEMENTO,
    MOVE_FACADE,
    MOVE_FOCUS_PUNCH,
    MOVE_SMELLING_SALT,
    MOVE_FOLLOW_ME,
    MOVE_NATURE_POWER,
    MOVE_CHARGE,
    MOVE_TAUNT,
    MOVE_HELPING_HAND,
    MOVE_TRICK,
    MOVE_ROLE_PLAY,
    MOVE_WISH,
    MOVE_ASSIST,
    MOVE_INGRAIN,
    MOVE_SUPERPOWER,
    MOVE_MAGIC_COAT,
    MOVE_RECYCLE,
    MOVE_REVENGE,
    MOVE_BRICK_BREAK,
    MOVE_YAWN,
    MOVE_KNOCK_OFF,
    MOVE_ENDEAVOR,
    MOVE_ERUPTION,
    MOVE_SKILL_SWAP,
    MOVE_IMPRISON,
    MOVE_REFRESH,
    MOVE_GRUDGE,
    MOVE_SNATCH,
    MOVE_SECRET_POWER,
    MOVE_DIVE,
    MOVE_ARM_THRUST,
    MOVE_CAMOUFLAGE,
    MOVE_TAIL_GLOW,
    MOVE_LUSTER_PURGE,
    MOVE_MIST_BALL,
    MOVE_FEATHER_DANCE,
    MOVE_TEETER_DANCE,
    MOVE_BLAZE_KICK,
    MOVE_MUD_SPORT,
    MOVE_ICE_BALL,
    MOVE_NEEDLE_ARM,
    MOVE_SLACK_OFF,
    MOVE_HYPER_VOICE,
    MOVE_POISON_FANG,
    MOVE_CRUSH_CLAW,
    MOVE_BLAST_BURN,
    MOVE_HYDRO_CANNON,
    MOVE_METEOR_MASH,
    MOVE_ASTONISH,
    MOVE_WEATHER_BALL,
    MOVE_AROMATHERAPY,
    MOVE_FAKE_TEARS,
    MOVE_AIR_CUTTER,
    MOVE_OVERHEAT,
    MOVE_ODOR_SLEUTH,
    MOVE_ROCK_TOMB,
    MOVE_SILVER_WIND,
    MOVE_METAL_SOUND,
    MOVE_GRASS_WHISTLE,
    MOVE_TICKLE,
    MOVE_COSMIC_POWER,
    MOVE_WATER_SPOUT,
    MOVE_SIGNAL_BEAM,
    MOVE_SHADOW_PUNCH,
    MOVE_EXTRASENSORY,
    MOVE_SKY_UPPERCUT,
    MOVE_SAND_TOMB,
    MOVE_SHEER_COLD,
    MOVE_MUDDY_WATER,
    MOVE_BULLET_SEED,
    MOVE_AERIAL_ACE,
    MOVE_ICICLE_SPEAR,
    MOVE_IRON_DEFENSE,
    MOVE_BLOCK,
    MOVE_HOWL,
    MOVE_DRAGON_CLAW,
    MOVE_FRENZY_PLANT,
    MOVE_BULK_UP,
    MOVE_BOUNCE,
    MOVE_MUD_SHOT,
    MOVE_POISON_TAIL,
    MOVE_COVET,
    MOVE_VOLT_TACKLE,
    MOVE_MAGICAL_LEAF,
    MOVE_WATER_SPORT,
    MOVE_CALM_MIND,
    MOVE_LEAF_BLADE,
    MOVE_DRAGON_DANCE,
    MOVE_ROCK_BLAST,
    MOVE_SHOCK_WAVE,
    MOVE_WATER_PULSE,
    MOVE_DOOM_DESIRE,
    MOVE_PSYCHO_BOOST,
    MOVE_DARK_PULSE,
    MOVE_PSYCHO_CUT,
    MOVE_FOCUS_BLAST,
    MOVE_POWER_GEM,
    MOVE_SHADOW_CLAW,
    MOVE_FLASH_CANNON,
    MOVE_AIR_SLASH,
    MOVE_BUG_BUZZ,
    MOVE_DRAGON_PULSE,
    MOVE_EARTH_POWER,
    MOVE_PLAY_ROUGH,
    MOVE_MOONBLAST,
    MOVE_POISON_JAB,
};
//**********************

// code
=======
// NOTE: Reordering this array will break compatibility with existing
// saves.
static const u32 sCompressedStatuses[] =
{
    STATUS1_NONE,
    STATUS1_SLEEP_TURN(1),
    STATUS1_SLEEP_TURN(2),
    STATUS1_SLEEP_TURN(3),
    STATUS1_SLEEP_TURN(4),
    STATUS1_SLEEP_TURN(5),
    STATUS1_POISON,
    STATUS1_BURN,
    STATUS1_FREEZE,
    STATUS1_PARALYSIS,
    STATUS1_TOXIC_POISON,
    STATUS1_FROSTBITE,
};

// Attempt to detect situations where the BoxPokemon struct is unable to
// contain all the values.
// TODO: Is it possible to compute:
// - The maximum experience.
// - The maximum PP.
// - The maximum HP.
// - The maximum form countdown.

// The following STATIC_ASSERT will prevent developers from compiling the game if the value of the constant on the left does not fit within the number of bits defined in PokemonSubstruct0 (currently located in include/pokemon.h).

// To successfully compile, developers will need to do one of the following:
// 1) Decrease the size of the constant.
// 2) Increase the number of bits both on the struct AND in the corresponding assert. This will likely break user's saves unless there is free space after the member that is being adjsted.
// 3) Repurpose unused IDs.

// EXAMPLES
// If a developer has added enough new items so that ITEMS_COUNT now equals 1200, they could...
// 1) remove new items until ITEMS_COUNT is 1023, the max value that will fit in 10 bits.
// 2) change heldItem:10 to heldItem:11 AND change the below assert for ITEMS_COUNT to check for (1 << 11).
// 3) repurpose IDs from other items that aren't being used, like ITEM_GOLD_TEETH or ITEM_SS_TICKET until ITEMS_COUNT equals 1023, the max value that will fit in 10 bits.

STATIC_ASSERT(NUM_SPECIES < (1 << 11), PokemonSubstruct0_species_TooSmall);
STATIC_ASSERT(NUMBER_OF_MON_TYPES + 1 <= (1 << 5), PokemonSubstruct0_teraType_TooSmall);
STATIC_ASSERT(ITEMS_COUNT < (1 << 10), PokemonSubstruct0_heldItem_TooSmall);
STATIC_ASSERT(MAX_LEVEL <= 100, PokemonSubstruct0_experience_PotentiallTooSmall); // Maximum of ~2 million exp.
STATIC_ASSERT(POKEBALL_COUNT <= (1 << 6), PokemonSubstruct0_pokeball_TooSmall);
STATIC_ASSERT(MOVES_COUNT_ALL < (1 << 11), PokemonSubstruct1_moves_TooSmall);
STATIC_ASSERT(ARRAY_COUNT(sCompressedStatuses) <= (1 << 4), PokemonSubstruct3_compressedStatus_TooSmall);
STATIC_ASSERT(MAX_LEVEL < (1 << 7), PokemonSubstruct3_metLevel_TooSmall);
STATIC_ASSERT(NUM_VERSIONS < (1 << 4), PokemonSubstruct3_metGame_TooSmall);
STATIC_ASSERT(MAX_DYNAMAX_LEVEL < (1 << 4), PokemonSubstruct3_dynamaxLevel_TooSmall);
STATIC_ASSERT(MAX_PER_STAT_IVS < (1 << 5), PokemonSubstruct3_ivs_TooSmall);
STATIC_ASSERT(NUM_NATURES <= (1 << 5), BoxPokemon_hiddenNatureModifier_TooSmall);

static u32 CompressStatus(u32 status)
{
    s32 i;
    for (i = 0; i < ARRAY_COUNT(sCompressedStatuses); i++)
    {
        if (sCompressedStatuses[i] == status)
            return i;
    }
    return 0; // STATUS1_NONE
}

static u32 UncompressStatus(u32 compressedStatus)
{
    if (compressedStatus < ARRAY_COUNT(sCompressedStatuses))
        return sCompressedStatuses[compressedStatus];
    else
        return STATUS1_NONE;
}
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

void ZeroBoxMonData(struct BoxPokemon *boxMon)
{
    u8 *raw = (u8 *)boxMon;
    u32 i;
    for (i = 0; i < sizeof(struct BoxPokemon); i++)
        raw[i] = 0;
}

void ZeroMonData(struct Pokemon *mon)
{
    u32 arg;
    ZeroBoxMonData(&mon->box);
    arg = 0;
    SetMonData(mon, MON_DATA_STATUS, &arg);
    SetMonData(mon, MON_DATA_LEVEL, &arg);
    SetMonData(mon, MON_DATA_HP, &arg);
    SetMonData(mon, MON_DATA_MAX_HP, &arg);
    SetMonData(mon, MON_DATA_ATK, &arg);
    SetMonData(mon, MON_DATA_DEF, &arg);
    SetMonData(mon, MON_DATA_SPEED, &arg);
    SetMonData(mon, MON_DATA_SPATK, &arg);
    SetMonData(mon, MON_DATA_SPDEF, &arg);
    arg = MAIL_NONE;
    SetMonData(mon, MON_DATA_MAIL, &arg);
}

void ZeroPlayerPartyMons(void)
{
    s32 i;
    for (i = 0; i < PARTY_SIZE; i++)
        ZeroMonData(&gPlayerParty[i]);
}

void ZeroEnemyPartyMons(void)
{
    s32 i;
    for (i = 0; i < PARTY_SIZE; i++)
        ZeroMonData(&gEnemyParty[i]);
}

void CreateMon(struct Pokemon *mon, u16 species, u8 level, u8 fixedIV, u8 hasFixedPersonality, u32 fixedPersonality, u8 otIdType, u32 fixedOtId)
{
    u32 mail;
    ZeroMonData(mon);
    CreateBoxMon(&mon->box, species, level, fixedIV, hasFixedPersonality, fixedPersonality, otIdType, fixedOtId);
    SetMonData(mon, MON_DATA_LEVEL, &level);
    mail = MAIL_NONE;
    SetMonData(mon, MON_DATA_MAIL, &mail);
    CalculateMonStats(mon);
}

void CreateBoxMon(struct BoxPokemon *boxMon, u16 species, u8 level, u8 fixedIV, u8 hasFixedPersonality, u32 fixedPersonality, u8 otIdType, u32 fixedOtId)
{
<<<<<<< HEAD
    
    u8 speciesName[POKEMON_NAME_LENGTH + 1];
    u32 personality;
    u32 value;
    u16 checksum;
    u32 shinyValue;

    ZeroBoxMonData(boxMon);

    if (hasFixedPersonality)
        personality = fixedPersonality;
    else
        personality = Random32();

    //SetBoxMonData(boxMon, MON_DATA_PERSONALITY, &personality);

    // Determine original trainer ID
    if (otIdType == OT_ID_RANDOM_NO_SHINY)
    {
        u32 shinyValue;
        if (FlagGet(FLAG_NO_SHINY) == TRUE) // No shiny
            do
            {
                value = Random32();
                shinyValue = GET_SHINY_VALUE(value, personality);
            } while (shinyValue = 0);
        else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 0) // 1/8192
            do
            {
                // Choose random OT IDs until one that results in a non-shiny PokÃ©mon
                value = Random32();
                shinyValue = GET_SHINY_VALUE(value, personality);
            } while (shinyValue < SHINY_ODDS);
        else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 1) // 1/4096
            do
            {
                value = Random32();
                shinyValue = GET_SHINY_VALUE(value, personality);
            } while (shinyValue < 16);
        else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 2) // 1/2048
            do
            {
                value = Random32();
                shinyValue = GET_SHINY_VALUE(value, personality);
            } while (shinyValue < 32);
        else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 3) // 1/1024
            do
            {
                value = Random32();
                shinyValue = GET_SHINY_VALUE(value, personality);
            } while (shinyValue < 64);
        else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 4) // 1/512
            do
            {
                value = Random32();
                shinyValue = GET_SHINY_VALUE(value, personality);
            } while (shinyValue < 128);
=======
    u8 speciesName[POKEMON_NAME_LENGTH + 1];
    u32 personality = Random32();
    u32 value;
    u16 checksum;
    u8 i;
    u8 availableIVs[NUM_STATS];
    u8 selectedIvs[NUM_STATS];
    bool32 isShiny;

    ZeroBoxMonData(boxMon);

    // Determine original trainer ID
    if (otIdType == OT_ID_RANDOM_NO_SHINY)
    {
        value = Random32();
        isShiny = FALSE;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }
    else if (otIdType == OT_ID_PRESET)
    {
        value = fixedOtId;
<<<<<<< HEAD
    }
    else // Player is the OT
    {
        u32 rolls = 0;
        u32 shinyRolls = 0;

=======
        isShiny = GET_SHINY_VALUE(value, hasFixedPersonality ? fixedPersonality : personality) < SHINY_ODDS;
    }
    else // Player is the OT
    {
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        value = gSaveBlock2Ptr->playerTrainerId[0]
              | (gSaveBlock2Ptr->playerTrainerId[1] << 8)
              | (gSaveBlock2Ptr->playerTrainerId[2] << 16)
              | (gSaveBlock2Ptr->playerTrainerId[3] << 24);
<<<<<<< HEAD
        if (gIsFishingEncounter)
            //shinyRolls = 65536;
            shinyRolls += 1 + 2 * gChainFishingStreak; //1 + 2 rolls per streak count. max 41

        if (shinyRolls)
        {
            if (gSaveBlock1Ptr->tx_Features_ShinyChance == 0) // 1/8192
                do {
                    personality = Random32();
                    shinyValue = HIHALF(value) ^ LOHALF(value) ^ HIHALF(personality) ^ LOHALF(personality);
                    rolls++;
                } while (shinyValue >= SHINY_ODDS && rolls < shinyRolls);    
            else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 1) // 1/4096
                do {
                    personality = Random32();
                    shinyValue = HIHALF(value) ^ LOHALF(value) ^ HIHALF(personality) ^ LOHALF(personality);
                    rolls++;
                } while (shinyValue >= 16 && rolls < shinyRolls);
            else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 2) // 1/2048
                do {
                    personality = Random32();
                    shinyValue = HIHALF(value) ^ LOHALF(value) ^ HIHALF(personality) ^ LOHALF(personality);
                    rolls++;
                } while (shinyValue >= 32 && rolls < shinyRolls);
            else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 3) // 1/1024
                do {
                    personality = Random32();
                    shinyValue = HIHALF(value) ^ LOHALF(value) ^ HIHALF(personality) ^ LOHALF(personality);
                    rolls++;
                } while (shinyValue >= 64 && rolls < shinyRolls);
            else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 4) // 1/512
                do {
                    personality = Random32();
                    shinyValue = HIHALF(value) ^ LOHALF(value) ^ HIHALF(personality) ^ LOHALF(personality);
                    rolls++;
                } while (shinyValue >= 128 && rolls < shinyRolls);   
        }
    }

=======

        if (P_FLAG_FORCE_NO_SHINY != 0 && FlagGet(P_FLAG_FORCE_NO_SHINY))
        {
            isShiny = FALSE;
        }
        else if (P_FLAG_FORCE_SHINY != 0 && FlagGet(P_FLAG_FORCE_SHINY))
        {
            isShiny = TRUE;
        }
        else if (P_ONLY_OBTAINABLE_SHINIES && (CurrentBattlePyramidLocation() != PYRAMID_LOCATION_NONE || (B_FLAG_NO_CATCHING != 0 && FlagGet(B_FLAG_NO_CATCHING))))
        {
            isShiny = FALSE;
        }
        else if (P_NO_SHINIES_WITHOUT_POKEBALLS && !HasAtLeastOnePokeBall())
        {
            isShiny = FALSE;
        }
        else
        {
            u32 totalRerolls = 0;
            if (CheckBagHasItem(ITEM_SHINY_CHARM, 1))
                totalRerolls += I_SHINY_CHARM_ADDITIONAL_ROLLS;
            if (LURE_STEP_COUNT != 0)
                totalRerolls += 1;
            if (I_FISHING_CHAIN && gIsFishingEncounter)
                totalRerolls += CalculateChainFishingShinyRolls();
            if (gDexNavSpecies)
                totalRerolls += CalculateDexNavShinyRolls();

            while (GET_SHINY_VALUE(value, personality) >= SHINY_ODDS && totalRerolls > 0)
            {
                personality = Random32();
                totalRerolls--;
            }

            isShiny = GET_SHINY_VALUE(value, personality) < SHINY_ODDS;
        }
    }

    if (hasFixedPersonality)
        personality = fixedPersonality;

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    SetBoxMonData(boxMon, MON_DATA_PERSONALITY, &personality);
    SetBoxMonData(boxMon, MON_DATA_OT_ID, &value);

    checksum = CalculateBoxMonChecksum(boxMon);
    SetBoxMonData(boxMon, MON_DATA_CHECKSUM, &checksum);
    EncryptBoxMon(boxMon);
<<<<<<< HEAD
    GetSpeciesName(speciesName, species);
=======
    SetBoxMonData(boxMon, MON_DATA_IS_SHINY, &isShiny);
    StringCopy(speciesName, GetSpeciesName(species));
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    SetBoxMonData(boxMon, MON_DATA_NICKNAME, speciesName);
    SetBoxMonData(boxMon, MON_DATA_LANGUAGE, &gGameLanguage);
    SetBoxMonData(boxMon, MON_DATA_OT_NAME, gSaveBlock2Ptr->playerName);
    SetBoxMonData(boxMon, MON_DATA_SPECIES, &species);
    SetBoxMonData(boxMon, MON_DATA_EXP, &gExperienceTables[gSpeciesInfo[species].growthRate][level]);
    SetBoxMonData(boxMon, MON_DATA_FRIENDSHIP, &gSpeciesInfo[species].friendship);
    value = GetCurrentRegionMapSectionId();
    SetBoxMonData(boxMon, MON_DATA_MET_LOCATION, &value);
    SetBoxMonData(boxMon, MON_DATA_MET_LEVEL, &level);
    SetBoxMonData(boxMon, MON_DATA_MET_GAME, &gGameVersion);
    value = ITEM_POKE_BALL;
    SetBoxMonData(boxMon, MON_DATA_POKEBALL, &value);
    SetBoxMonData(boxMon, MON_DATA_OT_GENDER, &gSaveBlock2Ptr->playerGender);

<<<<<<< HEAD
    if (fixedIV < USE_RANDOM_IVS)
    {
        if (gSaveBlock1Ptr->tx_Challenges_MaxPartyIVs == 0)
        {
            SetBoxMonData(boxMon, MON_DATA_HP_IV, &fixedIV);
            SetBoxMonData(boxMon, MON_DATA_ATK_IV, &fixedIV);
            SetBoxMonData(boxMon, MON_DATA_DEF_IV, &fixedIV);
            SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &fixedIV);
            SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &fixedIV);
            SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &fixedIV);
        }
        else if (gSaveBlock1Ptr->tx_Challenges_MaxPartyIVs == 1)
        {
            u32 iv;
            iv = 31;
            
            SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv);
        }
        else if (gSaveBlock1Ptr->tx_Challenges_MaxPartyIVs == 2)
        {
            //Ugly, but it works. Can get improved.
            u32 iv30;
            u32 iv31;
            int ivRand;

            iv30 = 30;
            iv31 = 31;
            ivRand = (Random() % 2);
            
            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv31);

            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv31);
            
            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv31);
            
            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv31);
            
            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv31);
            
            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv31);
        }
    }
    else
    {
        if (gSaveBlock1Ptr->tx_Challenges_MaxPartyIVs == 0)
        {
            u32 iv;
            value = Random();

            iv = value & MAX_IV_MASK;
            SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv);
            iv = (value & (MAX_IV_MASK << 5)) >> 5;
            SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv);
            iv = (value & (MAX_IV_MASK << 10)) >> 10;
            SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv);

            value = Random();

            iv = value & MAX_IV_MASK;
            SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv);
            iv = (value & (MAX_IV_MASK << 5)) >> 5;
            SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv);
            iv = (value & (MAX_IV_MASK << 10)) >> 10;
            SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv);
        }
        else if (gSaveBlock1Ptr->tx_Challenges_MaxPartyIVs == 1)
        {
            u32 iv;
            iv = 31;

            SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv);
            SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv);
        }
        else if (gSaveBlock1Ptr->tx_Challenges_MaxPartyIVs == 2)
        {
            //Ugly, but it works. Can get improved.
            u32 iv30;
            u32 iv31;
            int ivRand;

            iv30 = 30;
            iv31 = 31;
            ivRand = (Random() % 2);
            
            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv31);

            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv31);

            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv31);

            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv31);

            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv31);

            ivRand = (Random() % 2);

            if (ivRand == 1)
                SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv30);
            else if (ivRand == 0)
                SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv31);
        }
    }

    if ((GetAbilityBySpecies(species, 1) != ABILITY_NONE)) //tx_randomizer_and_challenges
    //if ((GetAbilityBySpecies(species, 1) != ABILITY_NONE) && (species != SPECIES_SLAKING || species != SPECIES_MILOTIC || species != SPECIES_WHISCASH || species != SPECIES_KINGDRA || species != SPECIES_DUSKNOIR)) //tx_randomizer_and_challenges + norman slaking code for hard mode
=======
    u32 teraType = (boxMon->personality & 0x1) == 0 ? GetSpeciesType(species, 0) : GetSpeciesType(species, 1);
    SetBoxMonData(boxMon, MON_DATA_TERA_TYPE, &teraType);

    if (fixedIV < USE_RANDOM_IVS)
    {
        SetBoxMonData(boxMon, MON_DATA_HP_IV, &fixedIV);
        SetBoxMonData(boxMon, MON_DATA_ATK_IV, &fixedIV);
        SetBoxMonData(boxMon, MON_DATA_DEF_IV, &fixedIV);
        SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &fixedIV);
        SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &fixedIV);
        SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &fixedIV);
    }
    else
    {
        u32 iv;
        u32 ivRandom = Random32();
        value = (u16)ivRandom;

        iv = value & MAX_IV_MASK;
        SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv);
        iv = (value & (MAX_IV_MASK << 5)) >> 5;
        SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv);
        iv = (value & (MAX_IV_MASK << 10)) >> 10;
        SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv);

        value = (u16)(ivRandom >> 16);

        iv = value & MAX_IV_MASK;
        SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv);
        iv = (value & (MAX_IV_MASK << 5)) >> 5;
        SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv);
        iv = (value & (MAX_IV_MASK << 10)) >> 10;
        SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv);

        if (gSpeciesInfo[species].perfectIVCount != 0)
        {
            iv = MAX_PER_STAT_IVS;
            // Initialize a list of IV indices.
            for (i = 0; i < NUM_STATS; i++)
            {
                availableIVs[i] = i;
            }

            // Select the IVs that will be perfected.
            for (i = 0; i < NUM_STATS && i < gSpeciesInfo[species].perfectIVCount; i++)
            {
                u8 index = Random() % (NUM_STATS - i);
                selectedIvs[i] = availableIVs[index];
                RemoveIVIndexFromList(availableIVs, index);
            }
            for (i = 0; i < NUM_STATS && i < gSpeciesInfo[species].perfectIVCount; i++)
            {
                switch (selectedIvs[i])
                {
                case STAT_HP:
                    SetBoxMonData(boxMon, MON_DATA_HP_IV, &iv);
                    break;
                case STAT_ATK:
                    SetBoxMonData(boxMon, MON_DATA_ATK_IV, &iv);
                    break;
                case STAT_DEF:
                    SetBoxMonData(boxMon, MON_DATA_DEF_IV, &iv);
                    break;
                case STAT_SPEED:
                    SetBoxMonData(boxMon, MON_DATA_SPEED_IV, &iv);
                    break;
                case STAT_SPATK:
                    SetBoxMonData(boxMon, MON_DATA_SPATK_IV, &iv);
                    break;
                case STAT_SPDEF:
                    SetBoxMonData(boxMon, MON_DATA_SPDEF_IV, &iv);
                    break;
                }
            }
        }
    }

    if (GetSpeciesAbility(species, 1))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        value = personality & 1;
        SetBoxMonData(boxMon, MON_DATA_ABILITY_NUM, &value);
    }

<<<<<<< HEAD
    value = HIDDEN_NATURE_NONE;
    SetBoxMonData(boxMon, MON_DATA_HIDDEN_NATURE, &value);

=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    GiveBoxMonInitialMoveset(boxMon);
}

void CreateMonWithNature(struct Pokemon *mon, u16 species, u8 level, u8 fixedIV, u8 nature)
{
    u32 personality;

    do
    {
        personality = Random32();
    }
    while (nature != GetNatureFromPersonality(personality));

    CreateMon(mon, species, level, fixedIV, TRUE, personality, OT_ID_PLAYER_ID, 0);
}

void CreateMonWithGenderNatureLetter(struct Pokemon *mon, u16 species, u8 level, u8 fixedIV, u8 gender, u8 nature, u8 unownLetter)
{
    u32 personality;

    if ((u8)(unownLetter - 1) < NUM_UNOWN_FORMS)
    {
        u16 actualLetter;

        do
        {
            personality = Random32();
            actualLetter = GET_UNOWN_LETTER(personality);
        }
        while (nature != GetNatureFromPersonality(personality)
            || gender != GetGenderFromSpeciesAndPersonality(species, personality)
            || actualLetter != unownLetter - 1);
    }
    else
    {
        do
        {
            personality = Random32();
        }
        while (nature != GetNatureFromPersonality(personality)
            || gender != GetGenderFromSpeciesAndPersonality(species, personality));
    }

    CreateMon(mon, species, level, fixedIV, TRUE, personality, OT_ID_PLAYER_ID, 0);
}

// This is only used to create Wally's Ralts.
void CreateMaleMon(struct Pokemon *mon, u16 species, u8 level)
{
    u32 personality;
    u32 otId;

    do
    {
        otId = Random32();
        personality = Random32();
    }
    while (GetGenderFromSpeciesAndPersonality(species, personality) != MON_MALE);
    CreateMon(mon, species, level, USE_RANDOM_IVS, TRUE, personality, OT_ID_PRESET, otId);
}

void CreateMonWithIVsPersonality(struct Pokemon *mon, u16 species, u8 level, u32 ivs, u32 personality)
{
    CreateMon(mon, species, level, 0, TRUE, personality, OT_ID_PLAYER_ID, 0);
    SetMonData(mon, MON_DATA_IVS, &ivs);
    CalculateMonStats(mon);
}

void CreateMonWithIVsOTID(struct Pokemon *mon, u16 species, u8 level, u8 *ivs, u32 otId)
{
    CreateMon(mon, species, level, 0, FALSE, 0, OT_ID_PRESET, otId);
    SetMonData(mon, MON_DATA_HP_IV, &ivs[STAT_HP]);
    SetMonData(mon, MON_DATA_ATK_IV, &ivs[STAT_ATK]);
    SetMonData(mon, MON_DATA_DEF_IV, &ivs[STAT_DEF]);
    SetMonData(mon, MON_DATA_SPEED_IV, &ivs[STAT_SPEED]);
    SetMonData(mon, MON_DATA_SPATK_IV, &ivs[STAT_SPATK]);
    SetMonData(mon, MON_DATA_SPDEF_IV, &ivs[STAT_SPDEF]);
    CalculateMonStats(mon);
}

void CreateMonWithEVSpread(struct Pokemon *mon, u16 species, u8 level, u8 fixedIV, u8 evSpread)
{
    s32 i;
    s32 statCount = 0;
    u16 evAmount;
    u8 evsBits;

    CreateMon(mon, species, level, fixedIV, FALSE, 0, OT_ID_PLAYER_ID, 0);

    evsBits = evSpread;

    for (i = 0; i < NUM_STATS; i++)
    {
        if (evsBits & 1)
            statCount++;
        evsBits >>= 1;
    }

    evAmount = MAX_TOTAL_EVS / statCount;

    evsBits = 1;

<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Challenges_NoEVs == 0)
    {
        for (i = 0; i < NUM_STATS; i++)
        {
            if (evSpread & evsBits)
                SetMonData(mon, MON_DATA_HP_EV + i, &evAmount);
            evsBits <<= 1;
        }
=======
    for (i = 0; i < NUM_STATS; i++)
    {
        if (evSpread & evsBits)
            SetMonData(mon, MON_DATA_HP_EV + i, &evAmount);
        evsBits <<= 1;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    CalculateMonStats(mon);
}

void CreateBattleTowerMon(struct Pokemon *mon, struct BattleTowerPokemon *src)
{
    s32 i;
    u8 nickname[max(32, POKEMON_NAME_BUFFER_SIZE)];
    u8 language;
    u8 value;

    CreateMon(mon, src->species, src->level, 0, TRUE, src->personality, OT_ID_PRESET, src->otId);

    for (i = 0; i < MAX_MON_MOVES; i++)
        SetMonMoveSlot(mon, src->moves[i], i);

    SetMonData(mon, MON_DATA_PP_BONUSES, &src->ppBonuses);
    SetMonData(mon, MON_DATA_HELD_ITEM, &src->heldItem);
    SetMonData(mon, MON_DATA_FRIENDSHIP, &src->friendship);

    StringCopy(nickname, src->nickname);

    if (nickname[0] == EXT_CTRL_CODE_BEGIN && nickname[1] == EXT_CTRL_CODE_JPN)
    {
        language = LANGUAGE_JAPANESE;
        StripExtCtrlCodes(nickname);
    }
    else
    {
        language = GAME_LANGUAGE;
    }

    SetMonData(mon, MON_DATA_LANGUAGE, &language);
    SetMonData(mon, MON_DATA_NICKNAME, nickname);
    SetMonData(mon, MON_DATA_HP_EV, &src->hpEV);
    SetMonData(mon, MON_DATA_ATK_EV, &src->attackEV);
    SetMonData(mon, MON_DATA_DEF_EV, &src->defenseEV);
    SetMonData(mon, MON_DATA_SPEED_EV, &src->speedEV);
    SetMonData(mon, MON_DATA_SPATK_EV, &src->spAttackEV);
    SetMonData(mon, MON_DATA_SPDEF_EV, &src->spDefenseEV);
    value = src->abilityNum;
    SetMonData(mon, MON_DATA_ABILITY_NUM, &value);
    value = src->hpIV;
    SetMonData(mon, MON_DATA_HP_IV, &value);
    value = src->attackIV;
    SetMonData(mon, MON_DATA_ATK_IV, &value);
    value = src->defenseIV;
    SetMonData(mon, MON_DATA_DEF_IV, &value);
    value = src->speedIV;
    SetMonData(mon, MON_DATA_SPEED_IV, &value);
    value = src->spAttackIV;
    SetMonData(mon, MON_DATA_SPATK_IV, &value);
    value = src->spDefenseIV;
    SetMonData(mon, MON_DATA_SPDEF_IV, &value);
    MonRestorePP(mon);
    CalculateMonStats(mon);
}

void CreateBattleTowerMon_HandleLevel(struct Pokemon *mon, struct BattleTowerPokemon *src, bool8 lvl50)
{
    s32 i;
    u8 nickname[max(32, POKEMON_NAME_BUFFER_SIZE)];
    u8 level;
    u8 language;
    u8 value;

    if (gSaveBlock2Ptr->frontier.lvlMode != FRONTIER_LVL_50)
        level = GetFrontierEnemyMonLevel(gSaveBlock2Ptr->frontier.lvlMode);
    else if (lvl50)
        level = FRONTIER_MAX_LEVEL_50;
    else
        level = src->level;

    CreateMon(mon, src->species, level, 0, TRUE, src->personality, OT_ID_PRESET, src->otId);

    for (i = 0; i < MAX_MON_MOVES; i++)
        SetMonMoveSlot(mon, src->moves[i], i);

    SetMonData(mon, MON_DATA_PP_BONUSES, &src->ppBonuses);
    SetMonData(mon, MON_DATA_HELD_ITEM, &src->heldItem);
    SetMonData(mon, MON_DATA_FRIENDSHIP, &src->friendship);

    StringCopy(nickname, src->nickname);

    if (nickname[0] == EXT_CTRL_CODE_BEGIN && nickname[1] == EXT_CTRL_CODE_JPN)
    {
        language = LANGUAGE_JAPANESE;
        StripExtCtrlCodes(nickname);
    }
    else
    {
        language = GAME_LANGUAGE;
    }

    SetMonData(mon, MON_DATA_LANGUAGE, &language);
    SetMonData(mon, MON_DATA_NICKNAME, nickname);
    SetMonData(mon, MON_DATA_HP_EV, &src->hpEV);
    SetMonData(mon, MON_DATA_ATK_EV, &src->attackEV);
    SetMonData(mon, MON_DATA_DEF_EV, &src->defenseEV);
    SetMonData(mon, MON_DATA_SPEED_EV, &src->speedEV);
    SetMonData(mon, MON_DATA_SPATK_EV, &src->spAttackEV);
    SetMonData(mon, MON_DATA_SPDEF_EV, &src->spDefenseEV);
    value = src->abilityNum;
    SetMonData(mon, MON_DATA_ABILITY_NUM, &value);
    value = src->hpIV;
    SetMonData(mon, MON_DATA_HP_IV, &value);
    value = src->attackIV;
    SetMonData(mon, MON_DATA_ATK_IV, &value);
    value = src->defenseIV;
    SetMonData(mon, MON_DATA_DEF_IV, &value);
    value = src->speedIV;
    SetMonData(mon, MON_DATA_SPEED_IV, &value);
    value = src->spAttackIV;
    SetMonData(mon, MON_DATA_SPATK_IV, &value);
    value = src->spDefenseIV;
    SetMonData(mon, MON_DATA_SPDEF_IV, &value);
    MonRestorePP(mon);
    CalculateMonStats(mon);
}

void CreateApprenticeMon(struct Pokemon *mon, const struct Apprentice *src, u8 monId)
{
    s32 i;
    u16 evAmount;
    u8 language;
    u32 otId = gApprentices[src->id].otId;
    u32 personality = ((gApprentices[src->id].otId >> 8) | ((gApprentices[src->id].otId & 0xFF) << 8))
                    + src->party[monId].species + src->number;

    CreateMon(mon,
              src->party[monId].species,
              GetFrontierEnemyMonLevel(src->lvlMode - 1),
              MAX_PER_STAT_IVS,
              TRUE,
              personality,
              OT_ID_PRESET,
              otId);

    SetMonData(mon, MON_DATA_HELD_ITEM, &src->party[monId].item);
    for (i = 0; i < MAX_MON_MOVES; i++)
        SetMonMoveSlot(mon, src->party[monId].moves[i], i);

<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Challenges_NoEVs == 0)
    {
        evAmount = MAX_TOTAL_EVS / NUM_STATS;
        for (i = 0; i < NUM_STATS; i++)
            SetMonData(mon, MON_DATA_HP_EV + i, &evAmount);
    }
=======
    evAmount = MAX_TOTAL_EVS / NUM_STATS;
    for (i = 0; i < NUM_STATS; i++)
        SetMonData(mon, MON_DATA_HP_EV + i, &evAmount);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    language = src->language;
    SetMonData(mon, MON_DATA_LANGUAGE, &language);
    SetMonData(mon, MON_DATA_OT_NAME, GetApprenticeNameInLanguage(src->id, language));
    CalculateMonStats(mon);
}

void CreateMonWithEVSpreadNatureOTID(struct Pokemon *mon, u16 species, u8 level, u8 nature, u8 fixedIV, u8 evSpread, u32 otId)
{
    s32 i;
    s32 statCount = 0;
    u8 evsBits;
    u16 evAmount;

    // i is reused as personality value
    do
    {
        i = Random32();
    } while (nature != GetNatureFromPersonality(i));

    CreateMon(mon, species, level, fixedIV, TRUE, i, OT_ID_PRESET, otId);
    evsBits = evSpread;
    for (i = 0; i < NUM_STATS; i++)
    {
        if (evsBits & 1)
            statCount++;
        evsBits >>= 1;
    }

<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Challenges_NoEVs == 0)
    {
        evAmount = MAX_TOTAL_EVS / statCount;
        evsBits = 1;
        for (i = 0; i < NUM_STATS; i++)
        {
            if (evSpread & evsBits)
                SetMonData(mon, MON_DATA_HP_EV + i, &evAmount);
            evsBits <<= 1;
        }
=======
    evAmount = MAX_TOTAL_EVS / statCount;
    evsBits = 1;
    for (i = 0; i < NUM_STATS; i++)
    {
        if (evSpread & evsBits)
            SetMonData(mon, MON_DATA_HP_EV + i, &evAmount);
        evsBits <<= 1;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    CalculateMonStats(mon);
}

void ConvertPokemonToBattleTowerPokemon(struct Pokemon *mon, struct BattleTowerPokemon *dest)
{
    s32 i;
    u16 heldItem;

    dest->species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, NULL);

<<<<<<< HEAD
    if (heldItem == ITEM_ENIGMA_BERRY)
=======
    if (heldItem == ITEM_ENIGMA_BERRY_E_READER)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        heldItem = ITEM_NONE;

    dest->heldItem = heldItem;

    for (i = 0; i < MAX_MON_MOVES; i++)
        dest->moves[i] = GetMonData(mon, MON_DATA_MOVE1 + i, NULL);

    dest->level = GetMonData(mon, MON_DATA_LEVEL, NULL);
    dest->ppBonuses = GetMonData(mon, MON_DATA_PP_BONUSES, NULL);
    dest->otId = GetMonData(mon, MON_DATA_OT_ID, NULL);
    dest->hpEV = GetMonData(mon, MON_DATA_HP_EV, NULL);
    dest->attackEV = GetMonData(mon, MON_DATA_ATK_EV, NULL);
    dest->defenseEV = GetMonData(mon, MON_DATA_DEF_EV, NULL);
    dest->speedEV = GetMonData(mon, MON_DATA_SPEED_EV, NULL);
    dest->spAttackEV = GetMonData(mon, MON_DATA_SPATK_EV, NULL);
    dest->spDefenseEV = GetMonData(mon, MON_DATA_SPDEF_EV, NULL);
    dest->friendship = GetMonData(mon, MON_DATA_FRIENDSHIP, NULL);
    dest->hpIV = GetMonData(mon, MON_DATA_HP_IV, NULL);
    dest->attackIV = GetMonData(mon, MON_DATA_ATK_IV, NULL);
    dest->defenseIV = GetMonData(mon, MON_DATA_DEF_IV, NULL);
    dest->speedIV  = GetMonData(mon, MON_DATA_SPEED_IV, NULL);
    dest->spAttackIV  = GetMonData(mon, MON_DATA_SPATK_IV, NULL);
    dest->spDefenseIV  = GetMonData(mon, MON_DATA_SPDEF_IV, NULL);
    dest->abilityNum = GetMonData(mon, MON_DATA_ABILITY_NUM, NULL);
    dest->personality = GetMonData(mon, MON_DATA_PERSONALITY, NULL);
<<<<<<< HEAD
    GetMonData(mon, MON_DATA_NICKNAME, dest->nickname);
=======
    GetMonData(mon, MON_DATA_NICKNAME10, dest->nickname);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

static void CreateEventMon(struct Pokemon *mon, u16 species, u8 level, u8 fixedIV, u8 hasFixedPersonality, u32 fixedPersonality, u8 otIdType, u32 fixedOtId)
{
    bool32 isModernFatefulEncounter = TRUE;

    CreateMon(mon, species, level, fixedIV, hasFixedPersonality, fixedPersonality, otIdType, fixedOtId);
    SetMonData(mon, MON_DATA_MODERN_FATEFUL_ENCOUNTER, &isModernFatefulEncounter);
}

// If FALSE, should load this game's Deoxys form. If TRUE, should load normal Deoxys form
<<<<<<< HEAD
bool8 ShouldIgnoreDeoxysForm(u8 caseId, u8 battlerId)
=======
bool8 ShouldIgnoreDeoxysForm(u8 caseId, u8 battler)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    switch (caseId)
    {
    case 0:
    default:
        return FALSE;
    case 1: // Player's side in battle
        if (!(gBattleTypeFlags & BATTLE_TYPE_MULTI))
            return FALSE;
        if (!gMain.inBattle)
            return FALSE;
<<<<<<< HEAD
        if (gLinkPlayers[GetMultiplayerId()].id == battlerId)
=======
        if (gLinkPlayers[GetMultiplayerId()].id == battler)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            return FALSE;
        break;
    case 2:
        break;
    case 3: // Summary Screen
        if (!(gBattleTypeFlags & BATTLE_TYPE_MULTI))
            return FALSE;
        if (!gMain.inBattle)
            return FALSE;
<<<<<<< HEAD
        if (battlerId == 1 || battlerId == 4 || battlerId == 5)
=======
        if (battler == 1 || battler == 4 || battler == 5)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            return TRUE;
        return FALSE;
    case 4:
        break;
    case 5: // In move animation, e.g. in Role Play or Snatch
        if (gBattleTypeFlags & BATTLE_TYPE_LINK)
        {
            if (!gMain.inBattle)
                return FALSE;
            if (gBattleTypeFlags & BATTLE_TYPE_MULTI)
            {
<<<<<<< HEAD
                if (gLinkPlayers[GetMultiplayerId()].id == battlerId)
=======
                if (gLinkPlayers[GetMultiplayerId()].id == battler)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                    return FALSE;
            }
            else
            {
<<<<<<< HEAD
                if (GetBattlerSide(battlerId) == B_SIDE_PLAYER)
=======
                if (IsOnPlayerSide(battler))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                    return FALSE;
            }
        }
        else
        {
            if (!gMain.inBattle)
                return FALSE;
<<<<<<< HEAD
            if (GetBattlerSide(battlerId) == B_SIDE_PLAYER)
=======
            if (IsOnPlayerSide(battler))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                return FALSE;
        }
        break;
    }

    return TRUE;
}

<<<<<<< HEAD
/*static u16 GetDeoxysStat(struct Pokemon *mon, s32 statId)
{
    s32 ivVal, evVal;
    u16 statValue = 0;
    u8 nature;

    if (gBattleTypeFlags & BATTLE_TYPE_LINK_IN_BATTLE || GetMonData(mon, MON_DATA_SPECIES, NULL) != SPECIES_DEOXYS)
        return 0;

    ivVal = GetMonData(mon, MON_DATA_HP_IV + statId, NULL);
    evVal = GetMonData(mon, MON_DATA_HP_EV + statId, NULL);
    statValue = ((sDeoxysBaseStats[statId] * 2 + ivVal + evVal / 4) * mon->level) / 100 + 5;
    nature = GetNature(mon, TRUE);
    statValue = ModifyStatByNature(nature, statValue, (u8)statId);
    return statValue;
}

void SetDeoxysStats(void)
{
    s32 i, value;

    for (i = 0; i < PARTY_SIZE; i++)
    {
        struct Pokemon *mon = &gPlayerParty[i];

        if (GetMonData(mon, MON_DATA_SPECIES, NULL) != SPECIES_DEOXYS)
            continue;

        value = GetMonData(mon, MON_DATA_ATK, NULL);
        SetMonData(mon, MON_DATA_ATK, &value);

        value = GetMonData(mon, MON_DATA_DEF, NULL);
        SetMonData(mon, MON_DATA_DEF, &value);

        value = GetMonData(mon, MON_DATA_SPEED, NULL);
        SetMonData(mon, MON_DATA_SPEED, &value);

        value = GetMonData(mon, MON_DATA_SPATK, NULL);
        SetMonData(mon, MON_DATA_SPATK, &value);

        value = GetMonData(mon, MON_DATA_SPDEF, NULL);
        SetMonData(mon, MON_DATA_SPDEF, &value);
    }
}*/

=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
u16 GetUnionRoomTrainerPic(void)
{
    u8 linkId;
    u32 arrId;

    if (gBattleTypeFlags & BATTLE_TYPE_RECORDED_LINK)
        linkId = gRecordedBattleMultiplayerId ^ 1;
    else
        linkId = GetMultiplayerId() ^ 1;

    arrId = gLinkPlayers[linkId].trainerId % NUM_UNION_ROOM_CLASSES;
    arrId |= gLinkPlayers[linkId].gender * NUM_UNION_ROOM_CLASSES;
    return FacilityClassToPicIndex(gUnionRoomFacilityClasses[arrId]);
}

<<<<<<< HEAD
u16 GetUnionRoomTrainerClass(void)
=======
enum TrainerClassID GetUnionRoomTrainerClass(void)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u8 linkId;
    u32 arrId;

    if (gBattleTypeFlags & BATTLE_TYPE_RECORDED_LINK)
        linkId = gRecordedBattleMultiplayerId ^ 1;
    else
        linkId = GetMultiplayerId() ^ 1;

    arrId = gLinkPlayers[linkId].trainerId % NUM_UNION_ROOM_CLASSES;
    arrId |= gLinkPlayers[linkId].gender * NUM_UNION_ROOM_CLASSES;
    return gFacilityClassToTrainerClass[gUnionRoomFacilityClasses[arrId]];
}

void CreateEnemyEventMon(void)
{
    s32 species = gSpecialVar_0x8004;
    s32 level = gSpecialVar_0x8005;
    s32 itemId = gSpecialVar_0x8006;

    ZeroEnemyPartyMons();
    CreateEventMon(&gEnemyParty[0], species, level, USE_RANDOM_IVS, FALSE, 0, OT_ID_PLAYER_ID, 0);
    if (itemId)
    {
        u8 heldItem[2];
        heldItem[0] = itemId;
        heldItem[1] = itemId >> 8;
        SetMonData(&gEnemyParty[0], MON_DATA_HELD_ITEM, heldItem);
    }
}

static u16 CalculateBoxMonChecksum(struct BoxPokemon *boxMon)
{
<<<<<<< HEAD
    u16 checksum = 0;
    union PokemonSubstruct *substruct0 = GetSubstruct(boxMon, boxMon->personality, 0);
    union PokemonSubstruct *substruct1 = GetSubstruct(boxMon, boxMon->personality, 1);
    union PokemonSubstruct *substruct2 = GetSubstruct(boxMon, boxMon->personality, 2);
    union PokemonSubstruct *substruct3 = GetSubstruct(boxMon, boxMon->personality, 3);
    s32 i;

    for (i = 0; i < (s32)ARRAY_COUNT(substruct0->raw); i++)
        checksum += substruct0->raw[i];

    for (i = 0; i < (s32)ARRAY_COUNT(substruct1->raw); i++)
        checksum += substruct1->raw[i];

    for (i = 0; i < (s32)ARRAY_COUNT(substruct2->raw); i++)
        checksum += substruct2->raw[i];

    for (i = 0; i < (s32)ARRAY_COUNT(substruct3->raw); i++)
        checksum += substruct3->raw[i];
=======
    u32 checksum = 0;

    for (u32 i = 0; i < ARRAY_COUNT(boxMon->secure.raw); i++)
        checksum += boxMon->secure.raw[i] + (boxMon->secure.raw[i] >> 16);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    return checksum;
}

<<<<<<< HEAD
#define CALC_STAT(base, iv, ev, statIndex, field)               \
{                                                               \
    u8 baseStat = gSpeciesInfo[species].base;                   \
    s32 n = (((2 * baseStat + iv + ev / 4) * level) / 100) + 5; \
    u8 nature = GetNature(mon, TRUE);                                 \
    n = ModifyStatByNature(nature, n, statIndex);               \
    SetMonData(mon, field, &n);                                 \
}

#define CALC_STAT50(base, iv, ev, statIndex, field)               \
{                                                               \
    u8 baseStat = gSpeciesInfo[species].base;                   \
    s32 n = (((2 * baseStat + iv + ev / 4) * 50) / 100) + 5; \
    u8 nature = GetNature(mon, TRUE);                                 \
    n = ModifyStatByNature(nature, n, statIndex);               \
    SetMonData(mon, field, &n);                                 \
}

#define CALC_STAT_EQUALIZED(base, iv, ev, statIndex, field, option)\
{                                                               \
    u16 baseStat[] = {100, 255, 500};                                         \
    s32 n = (((2 * baseStat[option] + iv + ev / 4) * level) / 100) + 5; \
    u8 nature = GetNature(mon, TRUE);                                 \
    n = ModifyStatByNature(nature, n, statIndex);               \
    SetMonData(mon, field, &n);                                 \
}

#define CALC_STAT_EQUALIZED50(base, iv, ev, statIndex, field, option)\
{                                                               \
    u16 baseStat[] = {100, 255, 500};                                         \
    s32 n = (((2 * baseStat[option] + iv + ev / 4) * 50) / 100) + 5; \
    u8 nature = GetNature(mon, TRUE);                                 \
    n = ModifyStatByNature(nature, n, statIndex);               \
    SetMonData(mon, field, &n);                                 \
=======
static u16 CalculateBoxMonChecksumDecrypt(struct BoxPokemon *boxMon)
{
    u32 checksum = 0;

    for (u32 i = 0; i < ARRAY_COUNT(boxMon->secure.raw); i++)
    {
        boxMon->secure.raw[i] ^= (boxMon->otId ^ boxMon->personality);
        checksum += boxMon->secure.raw[i] + (boxMon->secure.raw[i] >> 16);
    }

    return checksum;
}

static u16 CalculateBoxMonChecksumReencrypt(struct BoxPokemon *boxMon)
{
    u32 checksum = 0;

    for (u32 i = 0; i < ARRAY_COUNT(boxMon->secure.raw); i++)
    {
        checksum += boxMon->secure.raw[i] + (boxMon->secure.raw[i] >> 16);
        boxMon->secure.raw[i] ^= (boxMon->otId ^ boxMon->personality);
    }

    return checksum;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void CalculateMonStats(struct Pokemon *mon)
{
    s32 oldMaxHP = GetMonData(mon, MON_DATA_MAX_HP, NULL);
    s32 currentHP = GetMonData(mon, MON_DATA_HP, NULL);
<<<<<<< HEAD
    s32 hpIV = GetMonData(mon, MON_DATA_HP_IV, NULL);
    s32 hpEV = GetMonData(mon, MON_DATA_HP_EV, NULL);
    s32 attackIV = GetMonData(mon, MON_DATA_ATK_IV, NULL);
    s32 attackEV = GetMonData(mon, MON_DATA_ATK_EV, NULL);
    s32 defenseIV = GetMonData(mon, MON_DATA_DEF_IV, NULL);
    s32 defenseEV = GetMonData(mon, MON_DATA_DEF_EV, NULL);
    s32 speedIV = GetMonData(mon, MON_DATA_SPEED_IV, NULL);
    s32 speedEV = GetMonData(mon, MON_DATA_SPEED_EV, NULL);
    s32 spAttackIV = GetMonData(mon, MON_DATA_SPATK_IV, NULL);
    s32 spAttackEV = GetMonData(mon, MON_DATA_SPATK_EV, NULL);
    s32 spDefenseIV = GetMonData(mon, MON_DATA_SPDEF_IV, NULL);
    s32 spDefenseEV = GetMonData(mon, MON_DATA_SPDEF_EV, NULL);
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    s32 level = GetLevelFromMonExp(mon);
    s32 newMaxHP;

    {
        if (FlagGet(FLAG_LIMIT_TO_50) == TRUE) //Try to limit mons to level 50 for frontier)
        {
            level = 50;
            SetMonData(mon, MON_DATA_LEVEL, &level);
        }
        else
        {
        SetMonData(mon, MON_DATA_LEVEL, &level);
        }
    }

=======
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    u8 friendship = GetMonData(mon, MON_DATA_FRIENDSHIP, NULL);
    s32 level = GetLevelFromMonExp(mon);
    s32 newMaxHP;

    u8 nature = GetMonData(mon, MON_DATA_HIDDEN_NATURE, NULL);

    SetMonData(mon, MON_DATA_LEVEL, &level);

    bool32 hyperTrained[NUM_STATS]; //In a battle test, hyper training flag indicates a fixed stat
    s32 iv[NUM_STATS];
    s32 ev[NUM_STATS];
    for (u32 i = 0; i < NUM_STATS; i++)
    {
        hyperTrained[i] = GetMonData(mon, MON_DATA_HYPER_TRAINED_HP + i);
        iv[i] = GetMonData(mon, MON_DATA_HP_IV + i);
        ev[i] = GetMonData(mon, MON_DATA_HP_EV + i);

        if (hyperTrained[i])
        {
        #if TESTING
            if (gMain.inBattle)
                continue;
        #endif
            iv[i] = MAX_PER_STAT_IVS;
        }

        if (i == STAT_HP)
            continue;

        u8 baseStat = GetSpeciesBaseStat(species, i);
        s32 n = (((2 * baseStat + iv[i] + ev[i] / 4) * level) / 100) + 5;
        n = ModifyStatByNature(nature, n, i);
        if (B_FRIENDSHIP_BOOST == TRUE)
            n = n + ((n * 10 * friendship) / (MAX_FRIENDSHIP * 100));
        SetMonData(mon, MON_DATA_MAX_HP + i, &n);
    }

#if TESTING
    if (hyperTrained[STAT_HP] && gMain.inBattle)
        return;
#endif

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    if (species == SPECIES_SHEDINJA)
    {
        newMaxHP = 1;
    }
    else
    {
<<<<<<< HEAD
        s32 n = 2 * gSpeciesInfo[species].baseHP + hpIV;
        s32 n_old = 2 * gSpeciesInfo[species].baseHP_old + hpIV;
        switch(gSaveBlock1Ptr->tx_Challenges_BaseStatEqualizer)
        {
        case 0:
            break;
        case 1: 
            if ((gSpeciesInfo[species].baseHP_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
                n_old = 2 * 100 + hpIV;
            else
                n = 2 * 100 + hpIV;
            break;
        case 2: 
            if ((gSpeciesInfo[species].baseHP_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
                n_old = 2 * 255 + hpIV;
            else
                n = 2 * 255 + hpIV;
            break;
        case 3: 
            n = 2 * 500 + hpIV;
            break;
        default:
            break;
        }
        if (FlagGet(FLAG_LIMIT_TO_50) == TRUE) //Try to limit mons to level 50 for frontier)
        {
            if ((gSpeciesInfo[species].baseHP_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
                newMaxHP = (((n_old + hpEV / 4) * 50) / 100) + 50 + 10;
            else
                newMaxHP = (((n + hpEV / 4) * 50) / 100) + 50 + 10;
        }
        else
        {
            if ((gSpeciesInfo[species].baseHP_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
                newMaxHP = (((n_old + hpEV / 4) * level) / 100) + level + 10;
            else
                newMaxHP = (((n + hpEV / 4) * level) / 100) + level + 10;
        }
=======
        s32 n = 2 * GetSpeciesBaseHP(species) + iv[STAT_HP];
        newMaxHP = (((n + ev[STAT_HP] / 4) * level) / 100) + level + 10;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    gBattleScripting.levelUpHP = newMaxHP - oldMaxHP;
    if (gBattleScripting.levelUpHP == 0)
        gBattleScripting.levelUpHP = 1;
<<<<<<< HEAD

    SetMonData(mon, MON_DATA_MAX_HP, &newMaxHP);

    if (gSaveBlock1Ptr->tx_Challenges_BaseStatEqualizer)
    {
        u8 option = gSaveBlock1Ptr->tx_Challenges_BaseStatEqualizer - 1;
        CALC_STAT_EQUALIZED(baseAttack, attackIV, attackEV, STAT_ATK, MON_DATA_ATK, option)
        CALC_STAT_EQUALIZED(baseDefense, defenseIV, defenseEV, STAT_DEF, MON_DATA_DEF, option)
        CALC_STAT_EQUALIZED(baseSpeed, speedIV, speedEV, STAT_SPEED, MON_DATA_SPEED, option)
        CALC_STAT_EQUALIZED(baseSpAttack, spAttackIV, spAttackEV, STAT_SPATK, MON_DATA_SPATK, option)
        CALC_STAT_EQUALIZED(baseSpDefense, spDefenseIV, spDefenseEV, STAT_SPDEF, MON_DATA_SPDEF, option)
    }
    else if (FlagGet(FLAG_LIMIT_TO_50) == TRUE) //Try to limit mons to level 50 for frontier)
    {
        if ((gSpeciesInfo[species].baseAttack_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT50(baseAttack_old, attackIV, attackEV, STAT_ATK, MON_DATA_ATK)
        }
        else
        {
            CALC_STAT50(baseAttack, attackIV, attackEV, STAT_ATK, MON_DATA_ATK)
        }

        if ((gSpeciesInfo[species].baseDefense_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT50(baseDefense_old, defenseIV, defenseEV, STAT_DEF, MON_DATA_DEF)
        }
        else
        {
            CALC_STAT50(baseDefense, defenseIV, defenseEV, STAT_DEF, MON_DATA_DEF)
        }

        if ((gSpeciesInfo[species].baseSpeed_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT50(baseSpeed_old, speedIV, speedEV, STAT_SPEED, MON_DATA_SPEED)
        }
        else
        {
            CALC_STAT50(baseSpeed, speedIV, speedEV, STAT_SPEED, MON_DATA_SPEED)
        }

        if ((gSpeciesInfo[species].baseSpAttack_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT50(baseSpAttack_old, spAttackIV, spAttackEV, STAT_SPATK, MON_DATA_SPATK)
        }
        else
        {
            CALC_STAT50(baseSpAttack, spAttackIV, spAttackEV, STAT_SPATK, MON_DATA_SPATK)
        }

        if ((gSpeciesInfo[species].baseSpDefense_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT50(baseSpDefense_old, spDefenseIV, spDefenseEV, STAT_SPDEF, MON_DATA_SPDEF)
        }
        else
        {
            CALC_STAT50(baseSpDefense, spDefenseIV, spDefenseEV, STAT_SPDEF, MON_DATA_SPDEF)
        } 
    }
    else if ((FlagGet(FLAG_LIMIT_TO_50) == TRUE) && (gSaveBlock1Ptr->tx_Challenges_BaseStatEqualizer)) //Try to limit mons to level 50 for frontier)
    {
        u8 option = gSaveBlock1Ptr->tx_Challenges_BaseStatEqualizer - 1;
        CALC_STAT_EQUALIZED50(baseAttack, attackIV, attackEV, STAT_ATK, MON_DATA_ATK, option)
        CALC_STAT_EQUALIZED50(baseDefense, defenseIV, defenseEV, STAT_DEF, MON_DATA_DEF, option)
        CALC_STAT_EQUALIZED50(baseSpeed, speedIV, speedEV, STAT_SPEED, MON_DATA_SPEED, option)
        CALC_STAT_EQUALIZED50(baseSpAttack, spAttackIV, spAttackEV, STAT_SPATK, MON_DATA_SPATK, option)
        CALC_STAT_EQUALIZED50(baseSpDefense, spDefenseIV, spDefenseEV, STAT_SPDEF, MON_DATA_SPDEF, option)
    }
    else
    {
        if ((gSpeciesInfo[species].baseAttack_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT(baseAttack_old, attackIV, attackEV, STAT_ATK, MON_DATA_ATK)
        }
        else
        {
            CALC_STAT(baseAttack, attackIV, attackEV, STAT_ATK, MON_DATA_ATK)
        }

        if ((gSpeciesInfo[species].baseDefense_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT(baseDefense_old, defenseIV, defenseEV, STAT_DEF, MON_DATA_DEF)
        }
        else
        {
            CALC_STAT(baseDefense, defenseIV, defenseEV, STAT_DEF, MON_DATA_DEF)
        }

        if ((gSpeciesInfo[species].baseSpeed_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT(baseSpeed_old, speedIV, speedEV, STAT_SPEED, MON_DATA_SPEED)
        }
        else
        {
            CALC_STAT(baseSpeed, speedIV, speedEV, STAT_SPEED, MON_DATA_SPEED)
        }

        if ((gSpeciesInfo[species].baseSpAttack_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT(baseSpAttack_old, spAttackIV, spAttackEV, STAT_SPATK, MON_DATA_SPATK)
        }
        else
        {
            CALC_STAT(baseSpAttack, spAttackIV, spAttackEV, STAT_SPATK, MON_DATA_SPATK)
        }

        if ((gSpeciesInfo[species].baseSpDefense_old != 0) && (gSaveBlock1Ptr->tx_Mode_New_Stats == 0))
        {
            CALC_STAT(baseSpDefense_old, spDefenseIV, spDefenseEV, STAT_SPDEF, MON_DATA_SPDEF)
        }
        else
        {
            CALC_STAT(baseSpDefense, spDefenseIV, spDefenseEV, STAT_SPDEF, MON_DATA_SPDEF)
        } 
    }

    if (species == SPECIES_SHEDINJA)
    {
        if (currentHP != 0 || oldMaxHP == 0)
            currentHP = 1;
        else
            return;
    }
    else
    {
        if (currentHP == 0 && oldMaxHP == 0)
            currentHP = newMaxHP;
        else if (currentHP != 0) {
            // BUG: currentHP is unintentionally able to become <= 0 after the instruction below. This causes the pomeg berry glitch.
            currentHP += newMaxHP - oldMaxHP;
            #ifdef BUGFIX
            if (currentHP <= 0)
                currentHP = 1;
            #endif
        }
        else
            return;
    }
=======
    SetMonData(mon, MON_DATA_MAX_HP, &newMaxHP);

    // Since a pokemon's maxHP data could either not have
    // been initialized at this point or this pokemon is
    // just fainted, the check for oldMaxHP is important.
    if (currentHP == 0 && oldMaxHP != 0)
        return;

    // Only add to currentHP if newMaxHP went up.
    if (newMaxHP > oldMaxHP)
        currentHP += newMaxHP - oldMaxHP;

    // Ensure currentHP does not surpass newMaxHP.
    if (currentHP > newMaxHP)
        currentHP = newMaxHP;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    SetMonData(mon, MON_DATA_HP, &currentHP);
}

void BoxMonToMon(const struct BoxPokemon *src, struct Pokemon *dest)
{
    u32 value = 0;
    dest->box = *src;
<<<<<<< HEAD
    SetMonData(dest, MON_DATA_STATUS, &value);
    SetMonData(dest, MON_DATA_HP, &value);
    SetMonData(dest, MON_DATA_MAX_HP, &value);
    value = MAIL_NONE;
    SetMonData(dest, MON_DATA_MAIL, &value);
    CalculateMonStats(dest);
=======
    dest->status = GetBoxMonData(&dest->box, MON_DATA_STATUS, NULL);
    dest->hp = 0;
    dest->maxHP = 0;
    value = MAIL_NONE;
    SetMonData(dest, MON_DATA_MAIL, &value);
    value = GetBoxMonData(&dest->box, MON_DATA_HP_LOST);
    CalculateMonStats(dest);
    value = GetMonData(dest, MON_DATA_MAX_HP) - value;
    SetMonData(dest, MON_DATA_HP, &value);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

u8 GetLevelFromMonExp(struct Pokemon *mon)
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    u32 exp = GetMonData(mon, MON_DATA_EXP, NULL);
    s32 level = 1;

    while (level <= MAX_LEVEL && gExperienceTables[gSpeciesInfo[species].growthRate][level] <= exp)
        level++;

    return level - 1;
}

u8 GetLevelFromBoxMonExp(struct BoxPokemon *boxMon)
{
    u16 species = GetBoxMonData(boxMon, MON_DATA_SPECIES, NULL);
    u32 exp = GetBoxMonData(boxMon, MON_DATA_EXP, NULL);
    s32 level = 1;

    while (level <= MAX_LEVEL && gExperienceTables[gSpeciesInfo[species].growthRate][level] <= exp)
        level++;

    return level - 1;
}

u16 GiveMoveToMon(struct Pokemon *mon, u16 move)
{
    return GiveMoveToBoxMon(&mon->box, move);
}

<<<<<<< HEAD
static u16 GiveMoveToBoxMon(struct BoxPokemon *boxMon, u16 move)
=======
u16 GiveMoveToBoxMon(struct BoxPokemon *boxMon, u16 move)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    s32 i;
    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        u16 existingMove = GetBoxMonData(boxMon, MON_DATA_MOVE1 + i, NULL);
        if (existingMove == MOVE_NONE)
        {
<<<<<<< HEAD
            SetBoxMonData(boxMon, MON_DATA_MOVE1 + i, &move);
            SetBoxMonData(boxMon, MON_DATA_PP1 + i, &gBattleMoves[move].pp);
=======
            u32 pp = GetMovePP(move);
            SetBoxMonData(boxMon, MON_DATA_MOVE1 + i, &move);
            SetBoxMonData(boxMon, MON_DATA_PP1 + i, &pp);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            return move;
        }
        if (existingMove == move)
            return MON_ALREADY_KNOWS_MOVE;
    }
    return MON_HAS_MAX_MOVES;
}

u16 GiveMoveToBattleMon(struct BattlePokemon *mon, u16 move)
{
    s32 i;

    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        if (mon->moves[i] == MOVE_NONE)
        {
            mon->moves[i] = move;
<<<<<<< HEAD
            mon->pp[i] = gBattleMoves[move].pp;
=======
            mon->pp[i] = GetMovePP(move);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            return move;
        }
    }

    return MON_HAS_MAX_MOVES;
}

void SetMonMoveSlot(struct Pokemon *mon, u16 move, u8 slot)
{
    SetMonData(mon, MON_DATA_MOVE1 + slot, &move);
<<<<<<< HEAD
    SetMonData(mon, MON_DATA_PP1 + slot, &gBattleMoves[move].pp);
=======
    u32 pp = GetMovePP(move);
    SetMonData(mon, MON_DATA_PP1 + slot, &pp);
}

static void SetMonMoveSlot_KeepPP(struct Pokemon *mon, u16 move, u8 slot)
{
    u8 ppBonuses = GetMonData(mon, MON_DATA_PP_BONUSES, NULL);
    u8 currPP = GetMonData(mon, MON_DATA_PP1 + slot, NULL);
    u8 newPP = CalculatePPWithBonus(move, ppBonuses, slot);
    u16 finalPP = min(currPP, newPP);

    SetMonData(mon, MON_DATA_MOVE1 + slot, &move);
    SetMonData(mon, MON_DATA_PP1 + slot, &finalPP);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void SetBattleMonMoveSlot(struct BattlePokemon *mon, u16 move, u8 slot)
{
    mon->moves[slot] = move;
<<<<<<< HEAD
    mon->pp[slot] = gBattleMoves[move].pp;
=======
    mon->pp[slot] = GetMovePP(move);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void GiveMonInitialMoveset(struct Pokemon *mon)
{
    GiveBoxMonInitialMoveset(&mon->box);
}

<<<<<<< HEAD
void GiveBoxMonInitialMoveset(struct BoxPokemon *boxMon)
=======
void GiveBoxMonInitialMoveset(struct BoxPokemon *boxMon) //Credit: AsparagusEduardo
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u16 species = GetBoxMonData(boxMon, MON_DATA_SPECIES, NULL);
    s32 level = GetLevelFromBoxMonExp(boxMon);
    s32 i;
<<<<<<< HEAD
    bool8 firstMoveGiven = FALSE;
    if (gSaveBlock1Ptr->tx_Mode_Modern_Moves == 0)
    {
        for (i = 0; gLevelUpLearnsets_Original[species][i] != LEVEL_UP_END; i++)
        {
            u16 moveLevel;
            u16 move;

            moveLevel = (gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_LV);

            if (moveLevel > (level << 9))
                break;

            move = (gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID);

            if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
            {
                move = GetRandomMove(move, species);
                if (!FlagGet(FLAG_SYS_POKEMON_GET) && !firstMoveGiven)
                {
                    u8 j;

                    #ifndef NDEBUG
                    MgbaPrintf(MGBA_LOG_DEBUG, "Generate 1 damaging move");
                    #endif

                    for (j=0; j<100; j++)
                    {
                        if (gBattleMoves[move].power <= 1)
                            move = GetRandomMove(move, species);
                        else
                            break;
                    }
                }
            }

            if (GiveMoveToBoxMon(boxMon, move) == MON_HAS_MAX_MOVES)
                DeleteFirstMoveAndGiveMoveToBoxMon(boxMon, move);
            if (!firstMoveGiven)
                firstMoveGiven = TRUE;
        }
    }
    else
    {
        for (i = 0; gLevelUpLearnsets[species][i] != LEVEL_UP_END; i++)
        {
            u16 moveLevel;
            u16 move;

            moveLevel = (gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_LV);
            
            if (moveLevel == 0)
                continue;

            if (moveLevel > (level << 9))
                break;

            move = (gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID);

            if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
            {
                move = GetRandomMove(move, species);
                if (!FlagGet(FLAG_SYS_POKEMON_GET) && !firstMoveGiven)
                {
                    u8 j;

                    #ifndef NDEBUG
                    MgbaPrintf(MGBA_LOG_DEBUG, "Generate 1 damaging move");
                    #endif

                    for (j=0; j<100; j++)
                    {
                        if (gBattleMoves[move].power <= 1)
                            move = GetRandomMove(move, species);
                        else
                            break;
                    }
                }
            }

            if (GiveMoveToBoxMon(boxMon, move) == MON_HAS_MAX_MOVES)
                DeleteFirstMoveAndGiveMoveToBoxMon(boxMon, move);
            if (!firstMoveGiven)
                firstMoveGiven = TRUE;
        }
    }
}

u16 MonTryLearningNewMove(struct Pokemon *mon, bool8 firstMove)
{
    u32 retVal = MOVE_NONE;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    u8 level = GetMonData(mon, MON_DATA_LEVEL, NULL);
=======
    u16 moves[MAX_MON_MOVES] = {MOVE_NONE};
    u8 addedMoves = 0;
    const struct LevelUpMove *learnset = GetSpeciesLevelUpLearnset(species);

    for (i = 0; learnset[i].move != LEVEL_UP_MOVE_END; i++)
    {
        s32 j;
        bool32 alreadyKnown = FALSE;

        if (learnset[i].level > level)
            break;
        if (learnset[i].level == 0)
            continue;

        for (j = 0; j < addedMoves; j++)
        {
            if (moves[j] == learnset[i].move)
            {
                alreadyKnown = TRUE;
                break;
            }
        }

        if (!alreadyKnown)
        {
            if (addedMoves < MAX_MON_MOVES)
            {
                moves[addedMoves] = learnset[i].move;
                addedMoves++;
            }
            else
            {
                for (j = 0; j < MAX_MON_MOVES - 1; j++)
                    moves[j] = moves[j + 1];
                moves[MAX_MON_MOVES - 1] = learnset[i].move;
            }
        }
    }
    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        SetBoxMonData(boxMon, MON_DATA_MOVE1 + i, &moves[i]);
        u32 pp = GetMovePP(moves[i]);
        SetBoxMonData(boxMon, MON_DATA_PP1 + i, &pp);
    }
}

u16 MonTryLearningNewMoveAtLevel(struct Pokemon *mon, bool32 firstMove, u32 level)
{
    u32 retVal = MOVE_NONE;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    const struct LevelUpMove *learnset = GetSpeciesLevelUpLearnset(species);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    // since you can learn more than one move per level
    // the game needs to know whether you decided to
    // learn it or keep the old set to avoid asking
    // you to learn the same move over and over again
<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Mode_Modern_Moves == 0)
    {
        if (firstMove)
        {
            sLearningMoveTableID = 0;

            while ((gLevelUpLearnsets_Original[species][sLearningMoveTableID] & LEVEL_UP_MOVE_LV) != (level << 9))
            {
                sLearningMoveTableID++;
                if (gLevelUpLearnsets_Original[species][sLearningMoveTableID] == LEVEL_UP_END)
                    return MOVE_NONE;
            }
        }

        if ((gLevelUpLearnsets_Original[species][sLearningMoveTableID] & LEVEL_UP_MOVE_LV) == (level << 9))
        {
            gMoveToLearn = (gLevelUpLearnsets_Original[species][sLearningMoveTableID] & LEVEL_UP_MOVE_ID);
            if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
                gMoveToLearn = GetRandomMove(gMoveToLearn, species);
            sLearningMoveTableID++;
            retVal = GiveMoveToMon(mon, gMoveToLearn);
        }
    }
    else
    {
        if (firstMove)
        {
            sLearningMoveTableID = 0;

            while ((gLevelUpLearnsets[species][sLearningMoveTableID] & LEVEL_UP_MOVE_LV) != (level << 9))
            {
                sLearningMoveTableID++;
                if (gLevelUpLearnsets[species][sLearningMoveTableID] == LEVEL_UP_END)
                    return MOVE_NONE;
            }
        }

        if ((gLevelUpLearnsets[species][sLearningMoveTableID] & LEVEL_UP_MOVE_LV) == (level << 9))
        {
            gMoveToLearn = (gLevelUpLearnsets[species][sLearningMoveTableID] & LEVEL_UP_MOVE_ID);
            if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
                gMoveToLearn = GetRandomMove(gMoveToLearn, species);
            sLearningMoveTableID++;
            retVal = GiveMoveToMon(mon, gMoveToLearn);
        }
=======
    if (firstMove)
    {
        sLearningMoveTableID = 0;

        while (learnset[sLearningMoveTableID].level != level)
        {
            sLearningMoveTableID++;
            if (learnset[sLearningMoveTableID].move == LEVEL_UP_MOVE_END)
                return MOVE_NONE;
        }
    }

    //  Handler for PokÃ©mon whose moves change upon form change.
    //  For example, if Zacian or Zamazenta should learn Iron Head,
    //  they're prevented from doing if they have Behemoth Blade/Bash,
    //  since it transforms into them while in their Crowned forms.
    const struct FormChange *formChanges = GetSpeciesFormChanges(species);

    for (u32 i = 0; formChanges != NULL && formChanges[i].method != FORM_CHANGE_TERMINATOR; i++)
    {
        if (formChanges[i].method == FORM_CHANGE_END_BATTLE
            && learnset[sLearningMoveTableID].move == formChanges[i].param3)
        {
            for (u32 j = 0; j < MAX_MON_MOVES; j++)
            {
                if (formChanges[i].param2 == GetMonData(mon, MON_DATA_MOVE1 + j))
                    return MOVE_NONE;
            }
        }
    }

    if (learnset[sLearningMoveTableID].level == level)
    {
        gMoveToLearn = learnset[sLearningMoveTableID].move;
        sLearningMoveTableID++;
        retVal = GiveMoveToMon(mon, gMoveToLearn);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    return retVal;
}

<<<<<<< HEAD
=======
u16 MonTryLearningNewMove(struct Pokemon *mon, bool8 firstMove)
{
    return MonTryLearningNewMoveAtLevel(mon, firstMove, GetMonData(mon, MON_DATA_LEVEL, NULL));
}

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
void DeleteFirstMoveAndGiveMoveToMon(struct Pokemon *mon, u16 move)
{
    s32 i;
    u16 moves[MAX_MON_MOVES];
    u8 pp[MAX_MON_MOVES];
    u8 ppBonuses;

    for (i = 0; i < MAX_MON_MOVES - 1; i++)
    {
        moves[i] = GetMonData(mon, MON_DATA_MOVE2 + i, NULL);
        pp[i] = GetMonData(mon, MON_DATA_PP2 + i, NULL);
    }

    ppBonuses = GetMonData(mon, MON_DATA_PP_BONUSES, NULL);
    ppBonuses >>= 2;
    moves[MAX_MON_MOVES - 1] = move;
<<<<<<< HEAD
    pp[MAX_MON_MOVES - 1] = gBattleMoves[move].pp;
=======
    pp[MAX_MON_MOVES - 1] = GetMovePP(move);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        SetMonData(mon, MON_DATA_MOVE1 + i, &moves[i]);
        SetMonData(mon, MON_DATA_PP1 + i, &pp[i]);
    }

    SetMonData(mon, MON_DATA_PP_BONUSES, &ppBonuses);
}

void DeleteFirstMoveAndGiveMoveToBoxMon(struct BoxPokemon *boxMon, u16 move)
{
    s32 i;
    u16 moves[MAX_MON_MOVES];
    u8 pp[MAX_MON_MOVES];
    u8 ppBonuses;

    for (i = 0; i < MAX_MON_MOVES - 1; i++)
    {
        moves[i] = GetBoxMonData(boxMon, MON_DATA_MOVE2 + i, NULL);
        pp[i] = GetBoxMonData(boxMon, MON_DATA_PP2 + i, NULL);
    }

    ppBonuses = GetBoxMonData(boxMon, MON_DATA_PP_BONUSES, NULL);
    ppBonuses >>= 2;
    moves[MAX_MON_MOVES - 1] = move;
<<<<<<< HEAD
    pp[MAX_MON_MOVES - 1] = gBattleMoves[move].pp;
=======
    pp[MAX_MON_MOVES - 1] = GetMovePP(move);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        SetBoxMonData(boxMon, MON_DATA_MOVE1 + i, &moves[i]);
        SetBoxMonData(boxMon, MON_DATA_PP1 + i, &pp[i]);
    }

    SetBoxMonData(boxMon, MON_DATA_PP_BONUSES, &ppBonuses);
}

<<<<<<< HEAD
#define APPLY_STAT_MOD(var, mon, stat, statIndex)                                   \
{                                                                                   \
    (var) = (stat) * (gStatStageRatios)[(mon)->statStages[(statIndex)]][0];         \
    (var) /= (gStatStageRatios)[(mon)->statStages[(statIndex)]][1];                 \
}

s32 CalculateBaseDamage(struct BattlePokemon *attacker, struct BattlePokemon *defender, u32 move, u16 sideStatus, u16 powerOverride, u8 typeOverride, u8 battlerIdAtk, u8 battlerIdDef)
{
    u32 i;
    s32 damage = 0;
    s32 damageHelper;
    u8 type;
    u16 attack, defense;
    u16 spAttack, spDefense;
    u8 defenderHoldEffect;
    u8 defenderHoldEffectParam;
    u8 attackerHoldEffect;
    u8 attackerHoldEffectParam;
    u32 moveType = gBattleMoves[gCurrentMove].type;
    u8 side = GetBattlerSide(gBattlerTarget);

    if (!powerOverride)
        gBattleMovePower = gBattleMoves[move].power;
    else
        gBattleMovePower = powerOverride;

    if (!typeOverride)
        type = gBattleMoves[move].type;
    else
        type = typeOverride & DYNAMIC_TYPE_MASK;

    attack = attacker->attack;
    defense = defender->defense;
    spAttack = attacker->spAttack;
    spDefense = defender->spDefense;

    // Get attacker hold item info
    if (attacker->item == ITEM_ENIGMA_BERRY)
    {
        attackerHoldEffect = gEnigmaBerries[battlerIdAtk].holdEffect;
        attackerHoldEffectParam = gEnigmaBerries[battlerIdAtk].holdEffectParam;
    }
    else
    {
        attackerHoldEffect = ItemId_GetHoldEffect(attacker->item);
        attackerHoldEffectParam = ItemId_GetHoldEffectParam(attacker->item);
    }

    // Get defender hold item info
    if (defender->item == ITEM_ENIGMA_BERRY)
    {
        defenderHoldEffect = gEnigmaBerries[battlerIdDef].holdEffect;
        defenderHoldEffectParam = gEnigmaBerries[battlerIdDef].holdEffectParam;
    }
    else
    {
        defenderHoldEffect = ItemId_GetHoldEffect(defender->item);
        defenderHoldEffectParam = ItemId_GetHoldEffectParam(defender->item);
    }

    if (attacker->ability == ABILITY_HUGE_POWER || attacker->ability == ABILITY_PURE_POWER)
        attack *= 2;

    if (ShouldGetStatBadgeBoost(FLAG_BADGE01_GET, battlerIdAtk))
        attack = (110 * attack) / 100;
    if (ShouldGetStatBadgeBoost(FLAG_BADGE03_GET, battlerIdDef))
        defense = (110 * defense) / 100;
    if (ShouldGetStatBadgeBoost(FLAG_BADGE06_GET, battlerIdDef))
        spDefense = (110 * spDefense) / 100;
        if (ShouldGetStatBadgeBoost(FLAG_BADGE07_GET, battlerIdAtk))
        spAttack = (110 * spAttack) / 100;

    // Apply type-bonus hold item
    for (i = 0; i < ARRAY_COUNT(sHoldEffectToType); i++)
    {
        if (gSaveBlock2Ptr->optionStyle == 1)
            if (attackerHoldEffect == sHoldEffectToType[i][0]
                && type == sHoldEffectToType[i][1])
            {
                if (IS_TYPE_PHYSICAL(type))
                    attack = (attack * (attackerHoldEffectParam + 100)) / 100;
                else
                    spAttack = (spAttack * (attackerHoldEffectParam + 100)) / 100;
                break;
            }
        if (gSaveBlock2Ptr->optionStyle == 0)
            if (attackerHoldEffect == sHoldEffectToType[i][0]
                && type == sHoldEffectToType[i][1])
            {
                attack = (attack * (attackerHoldEffectParam + 100)) / 100;
                spAttack = (spAttack * (attackerHoldEffectParam + 100)) / 100;
                break;
            }
    }

    // Apply boosts from hold items
    if (attackerHoldEffect == HOLD_EFFECT_CHOICE_BAND)
        attack = (150 * attack) / 100;
    if (attackerHoldEffect == HOLD_EFFECT_SOUL_DEW && !(gBattleTypeFlags & (BATTLE_TYPE_FRONTIER)) && (attacker->species == SPECIES_LATIAS || attacker->species == SPECIES_LATIOS))
        spAttack = (150 * spAttack) / 100;
    if (defenderHoldEffect == HOLD_EFFECT_SOUL_DEW && !(gBattleTypeFlags & (BATTLE_TYPE_FRONTIER)) && (defender->species == SPECIES_LATIAS || defender->species == SPECIES_LATIOS))
        spDefense = (150 * spDefense) / 100;
    if (attackerHoldEffect == HOLD_EFFECT_DEEP_SEA_TOOTH && attacker->species == SPECIES_CLAMPERL)
        spAttack *= 2;
    if (defenderHoldEffect == HOLD_EFFECT_DEEP_SEA_SCALE && defender->species == SPECIES_CLAMPERL)
        spDefense *= 2;
    if (attackerHoldEffect == HOLD_EFFECT_LIGHT_BALL && attacker->species == SPECIES_PIKACHU)
        spAttack *= 2;
    if (defenderHoldEffect == HOLD_EFFECT_METAL_POWDER && defender->species == SPECIES_DITTO)
        defense *= 2;
    if (attackerHoldEffect == HOLD_EFFECT_THICK_CLUB && (attacker->species == SPECIES_CUBONE || attacker->species == SPECIES_MAROWAK))
        attack *= 2;
    if ((attackerHoldEffect == HOLD_EFFECT_FAIRY_POWER && moveType == TYPE_FAIRY) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_BUG_POWER && moveType == TYPE_BUG) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_STEEL_POWER && moveType == TYPE_STEEL) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_GROUND_POWER && moveType == TYPE_GROUND) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_ROCK_POWER && moveType == TYPE_ROCK) && attacker->ability == ABILITY_MULTITYPE)
    {    
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_GRASS_POWER && moveType == TYPE_GRASS) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_DARK_POWER && moveType == TYPE_DARK) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_FIGHTING_POWER && moveType == TYPE_FIGHTING) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_ELECTRIC_POWER && moveType == TYPE_ELECTRIC) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_WATER_POWER && moveType == TYPE_WATER) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_FLYING_POWER && moveType == TYPE_FLYING) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_POISON_POWER && moveType == TYPE_POISON) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_ICE_POWER && moveType == TYPE_ICE) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_GHOST_POWER && moveType == TYPE_GHOST) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_PSYCHIC_POWER && moveType == TYPE_PSYCHIC) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_FIRE_POWER && moveType == TYPE_FIRE) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((attackerHoldEffect == HOLD_EFFECT_DRAGON_POWER && moveType == TYPE_DRAGON) && attacker->ability == ABILITY_MULTITYPE)
    {
        attack *= 1.365;
        spAttack *= 1.365;
    }
    else if ((defenderHoldEffect == HOLD_EFFECT_NORMAL_POWER) && defender->ability == ABILITY_MULTITYPE)
    {
        defense *= 1.25;
        spDefense *= 1.25;
    }
    // Apply abilities / field sports
    if (gSaveBlock2Ptr->optionStyle == 0)
        if (defender->ability == ABILITY_THICK_FAT && (type == TYPE_FIRE || type == TYPE_ICE))
            gBattleMovePower /= 2;
    if (gSaveBlock2Ptr->optionStyle == 1)
        if (defender->ability == ABILITY_THICK_FAT && (type == TYPE_FIRE || type == TYPE_ICE))
            spAttack /= 2;
    if ((defender->ability != ABILITY_NONE) 
    && (gSaveBlock2Ptr->optionsDifficulty == 2) 
    && (side == B_SIDE_PLAYER) 
    //&& !(gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_EREADER_TRAINER | BATTLE_TYPE_RECORDED_LINK | BATTLE_TYPE_FRONTIER))
    ) //FlagSet(FLAG_DIFFICULTY_HARD)
    {//HnS changed to 110
        if (FlagGet(FLAG_BADGE05_GET) == TRUE)
        {
            defense = (110 * defense) / 100; //+25%
            spDefense = (110 * spDefense) / 100;
        }
        else if (FlagGet(FLAG_BADGE04_GET) == TRUE)
        {
            defense = (110 * defense) / 100; //+25%
            spDefense = (110 * spDefense) / 100;
        }
        else if (FlagGet(FLAG_BADGE03_GET) == TRUE)
        {
            defense = (110 * defense) / 100; //+25%
            spDefense = (110 * spDefense) / 100;
        }
        else if (FlagGet(FLAG_BADGE02_GET) == TRUE)
        {
            defense = (110 * defense) / 100; //+25%
            spDefense = (110 * spDefense) / 100;
        }
        else if (FlagGet(FLAG_INCREASE_DIFFICULTY) == TRUE)
        {
            defense = (110 * defense) / 100; //+25%
            spDefense = (110 * spDefense) / 100;
        }
        else if (FlagGet(FLAG_BADGE01_GET) == TRUE)
        {
            defense = (110 * defense) / 100; //+25%
            spDefense = (110 * spDefense) / 100;
        }
        else
        {
            defense = (110 * defense) / 100; //+25%
            spDefense = (110 * spDefense) / 100;
        }
    }
    if (attacker->ability == ABILITY_HUSTLE)
        attack = (150 * attack) / 100;
    if (attacker->ability == ABILITY_CACOPHONY && (gCurrentMove == MOVE_SNORE || gCurrentMove == MOVE_UPROAR || gCurrentMove == MOVE_HYPER_VOICE || gCurrentMove == MOVE_BUG_BUZZ))
        spAttack = (150 * spAttack) / 100;
    if (attacker->ability == ABILITY_PLUS && ABILITY_ON_FIELD2(ABILITY_MINUS))
        spAttack = (150 * spAttack) / 100;
    if (attacker->ability == ABILITY_MINUS && ABILITY_ON_FIELD2(ABILITY_PLUS))
        spAttack = (150 * spAttack) / 100;
    if ((gSaveBlock2Ptr->optionsDifficulty == 2))
    {
        // Sceptile gets Thick Fat to reduce dmg from their weaknesses, and a 10% dmg increase.
        if ((attacker->species == SPECIES_SCEPTILE) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            attacker->ability = ABILITY_THICK_FAT;
            spAttack = (110 * spAttack) / 100;
            attack = (110 * attack) / 100;
        }

        //Blaziken gets Speed Boost and has a 25% def increase
        if ((attacker->species == SPECIES_BLAZIKEN) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            attacker->ability = ABILITY_SPEED_BOOST;
        }
        if ((defender->species == SPECIES_BLAZIKEN) && (defenderHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            defense = (125 * defense) / 100;
            spDefense = (125 * spDefense) / 100;
        }
        
        // Swampert only gets Hustle, as he is strong, and 25% def.
        if ((attacker->species == SPECIES_SWAMPERT) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            attacker->ability = ABILITY_HUSTLE;
        }
        if ((defender->species == SPECIES_SWAMPERT) && (defenderHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            defense = (125 * defense) / 100;
            spDefense = (125 * spDefense) / 100;
        }

        // Slaking gets Immunity. He does -20% damage in the first match vs Norman and does normal damage in the rematches. No sitrus berry.
        if ((attacker->species == SPECIES_SLAKING) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            attacker->ability = ABILITY_IMMUNITY;
            //attacker->ability = ABILITY_SPEED_BOOST;
            if (FlagGet(FLAG_BADGE05_GET) == FALSE)
                {
                    spAttack = (80 * spAttack) / 100;
                    attack = (80 * attack) / 100;
                }
        }

        // Altaria gets faster, and holds a Chesto for the rematches.
        if ((attacker->species == SPECIES_ALTARIA) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_CHESTO))
        {
            attacker->ability = ABILITY_SPEED_BOOST;
        }
        
        // Kingdra gets Drizzle
        if ((attacker->species == SPECIES_KINGDRA) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_CHESTO))
        {
            attacker->ability = ABILITY_DRIZZLE;
        }
        // Kingdra gets Drizzle, and Liechi modifier for rematches
        else if ((attacker->species == SPECIES_KINGDRA) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_LIECHI))
        {
            attacker->ability = ABILITY_DRIZZLE;
        }

        // Dusknoir gets Levitate
        if ((attacker->species == SPECIES_DUSKNOIR) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            attacker->ability = ABILITY_LEVITATE;
        }
        else if ((attacker->species == SPECIES_DUSKNOIR) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_LEFTOVERS))
        {
            attacker->ability = ABILITY_LEVITATE;
        }
        
        // Whiscash gets Drizzle, and Milotic gets Swift Swim together with Marvel Scale
        if ((attacker->species == SPECIES_WHISCASH) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            attacker->ability = ABILITY_DRIZZLE;
        }
        if ((attacker->species == SPECIES_MILOTIC) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            attacker->ability = ABILITY_SWIFT_SWIM;
        }
        else if ((attacker->species == SPECIES_MILOTIC) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_LEFTOVERS))
        {
            attacker->ability = ABILITY_SWIFT_SWIM;
        }
        if ((defender->species == SPECIES_MILOTIC) && (defenderHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER))
        {
            if (defender->status1)
                defense = (150 * defense) / 100;
        }
        else if ((defender->species == SPECIES_MILOTIC) && (defenderHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_LEFTOVERS))
        {
            if (defender->status1)
                defense = (150 * defense) / 100;
        }
        
        // Solrock and Lunatone get a 15% dmg boost if they are together on the field, and a Sitrus berry.
        if (attacker->species == SPECIES_SOLROCK && ((ABILITY_ON_FIELD2(ABILITY_LEVITATE)) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_SITRUS)))
        {
            attack = (115 * attack) / 100;
        }
        if (attacker->species == SPECIES_LUNATONE && ((ABILITY_ON_FIELD2(ABILITY_LEVITATE)) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_SITRUS)))
        {
            spAttack = (115 * spAttack) / 100;
        }
        // Lunatone with chesto for rematches
        else if (attacker->species == SPECIES_LUNATONE && ((ABILITY_ON_FIELD2(ABILITY_LEVITATE)) && (attackerHoldEffect == HOLD_EFFECT_HARD_MODE_MODIFIER_CHESTO)))
        {
            spAttack = (115 * spAttack) / 100;
        }
    }
        
    if (attacker->ability == ABILITY_GUTS && attacker->status1)
        attack = (150 * attack) / 100;
    if (attacker->ability == ABILITY_TRANSISTOR && moveType == TYPE_ELECTRIC)
        gBattleMovePower = (150 * gBattleMovePower) / 100;
    if (attacker->ability == ABILITY_DRAGONS_MAW && moveType == TYPE_DRAGON)
        gBattleMovePower = (150 * gBattleMovePower) / 100;
    if (attacker->ability == ABILITY_ILLUMINATE && moveType == TYPE_ELECTRIC)
        gBattleMovePower = (110 * gBattleMovePower) / 100;
    if (defender->ability == ABILITY_MARVEL_SCALE && defender->status1)
        defense = (150 * defense) / 100;
    if (type == TYPE_ELECTRIC && AbilityBattleEffects(ABILITYEFFECT_FIELD_SPORT, 0, 0, ABILITYEFFECT_MUD_SPORT, 0))
        gBattleMovePower /= 2;
    if (type == TYPE_FIRE && AbilityBattleEffects(ABILITYEFFECT_FIELD_SPORT, 0, 0, ABILITYEFFECT_WATER_SPORT, 0))
        gBattleMovePower /= 2;
    if (type == TYPE_GRASS && attacker->ability == ABILITY_OVERGROW && attacker->hp <= (attacker->maxHP / 3))
        gBattleMovePower = (150 * gBattleMovePower) / 100;
    if (type == TYPE_FIRE && attacker->ability == ABILITY_BLAZE && attacker->hp <= (attacker->maxHP / 3))
        gBattleMovePower = (150 * gBattleMovePower) / 100;
    if (type == TYPE_WATER && attacker->ability == ABILITY_TORRENT && attacker->hp <= (attacker->maxHP / 3))
        gBattleMovePower = (150 * gBattleMovePower) / 100;
    if (type == TYPE_BUG && attacker->ability == ABILITY_SWARM && attacker->hp <= (attacker->maxHP / 3))
        gBattleMovePower = (150 * gBattleMovePower) / 100;
    if ((attacker->species == SPECIES_SPINDA) && ((Random() % 100) <= 2))
        gBattleMovePower = (200 * gBattleMovePower) / 100;

    // Self-destruct / Explosion cut defense in half
    if (gBattleMoves[gCurrentMove].effect == EFFECT_EXPLOSION)
        defense /= 2;
    if (gSaveBlock2Ptr->optionStyle == 0)
        if (IS_MOVE_PHYSICAL(gCurrentMove))
        {
            if (gCritMultiplier == 2)
            {
                // Critical hit, if attacker has lost attack stat stages then ignore stat drop
                if (attacker->statStages[STAT_ATK] > DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damage, attacker, attack, STAT_ATK)
                else
                    damage = attack;
            }
            else
                APPLY_STAT_MOD(damage, attacker, attack, STAT_ATK)

            damage = damage * gBattleMovePower;
            damage *= (2 * attacker->level / 5 + 2);

            if (gCritMultiplier == 2)
            {
                // Critical hit, if defender has gained defense stat stages then ignore stat increase
                if (defender->statStages[STAT_DEF] < DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damageHelper, defender, defense, STAT_DEF)
                else
                    damageHelper = defense;
            }
            else
                APPLY_STAT_MOD(damageHelper, defender, defense, STAT_DEF)

            damage = damage / damageHelper;
            damage /= 50;

            // Burn cuts attack in half
            if ((attacker->status1 & STATUS1_BURN) && attacker->ability != ABILITY_GUTS)
                damage /= 2;

            // Apply Reflect
            if ((sideStatus & SIDE_STATUS_REFLECT) && gCritMultiplier == 1)
            {
                if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                    damage = 2 * (damage / 3);
                else
                    damage /= 2;
            }

            // Moves hitting both targets do half damage in double battles
            if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && gBattleMoves[move].target == MOVE_TARGET_BOTH && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                damage /= 2;

            // Moves always do at least 1 damage.
            if (damage == 0)
                damage = 1;
        }
    if (gSaveBlock2Ptr->optionStyle == 1)
        if (IS_TYPE_PHYSICAL(type))
        {
            if (gCritMultiplier == 2)
            {
                // Critical hit, if attacker has lost attack stat stages then ignore stat drop
                if (attacker->statStages[STAT_ATK] > DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damage, attacker, attack, STAT_ATK)
                else
                    damage = attack;
            }
            else
                APPLY_STAT_MOD(damage, attacker, attack, STAT_ATK)

            damage = damage * gBattleMovePower;
            damage *= (2 * attacker->level / 5 + 2);

            if (gCritMultiplier == 2)
            {
                // Critical hit, if defender has gained defense stat stages then ignore stat increase
                if (defender->statStages[STAT_DEF] < DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damageHelper, defender, defense, STAT_DEF)
                else
                    damageHelper = defense;
            }
            else
                APPLY_STAT_MOD(damageHelper, defender, defense, STAT_DEF)

            damage = damage / damageHelper;
            damage /= 50;

            // Burn cuts attack in half
            if ((attacker->status1 & STATUS1_BURN) && attacker->ability != ABILITY_GUTS)
                damage /= 2;

            // Apply Reflect
            if ((sideStatus & SIDE_STATUS_REFLECT) && gCritMultiplier == 1)
            {
                if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                    damage = 2 * (damage / 3);
                else
                    damage /= 2;
            }

            // Moves hitting both targets do half damage in double battles
            if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && gBattleMoves[move].target == MOVE_TARGET_BOTH && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                damage /= 2;

            // Moves always do at least 1 damage.
            if (damage == 0)
                damage = 1;
        }
    
    if (type == TYPE_MYSTERY)
        damage = 0; // is ??? type. does 0 damage.

    if (gSaveBlock2Ptr->optionStyle == 0)
        if (IS_MOVE_SPECIAL(gCurrentMove))
        {
            if (gCritMultiplier == 2)
            {
                // Critical hit, if attacker has lost sp. attack stat stages then ignore stat drop
                if (attacker->statStages[STAT_SPATK] > DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damage, attacker, spAttack, STAT_SPATK)
                else
                    damage = spAttack;
            }
            else
                APPLY_STAT_MOD(damage, attacker, spAttack, STAT_SPATK)

            damage = damage * gBattleMovePower;
            damage *= (2 * attacker->level / 5 + 2);

            if (gCritMultiplier == 2)
            {
                // Critical hit, if defender has gained sp. defense stat stages then ignore stat increase
                if (defender->statStages[STAT_SPDEF] < DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damageHelper, defender, spDefense, STAT_SPDEF)
                else
                    damageHelper = spDefense;
            }
            else
                APPLY_STAT_MOD(damageHelper, defender, spDefense, STAT_SPDEF)

            damage = (damage / damageHelper);
            damage /= 50;

            // Apply Lightscreen
            if ((sideStatus & SIDE_STATUS_LIGHTSCREEN) && gCritMultiplier == 1)
            {
                if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                    damage = 2 * (damage / 3);
                else
                    damage /= 2;
            }

            // Moves hitting both targets do half damage in double battles
            if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && gBattleMoves[move].target == MOVE_TARGET_BOTH && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                damage /= 2;
        }

    if (gSaveBlock2Ptr->optionStyle == 1)
        if (IS_TYPE_SPECIAL(type))
        {
            if (gCritMultiplier == 2)
            {
                // Critical hit, if attacker has lost sp. attack stat stages then ignore stat drop
                if (attacker->statStages[STAT_SPATK] > DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damage, attacker, spAttack, STAT_SPATK)
                else
                    damage = spAttack;
            }
            else
                APPLY_STAT_MOD(damage, attacker, spAttack, STAT_SPATK)

            damage = damage * gBattleMovePower;
            damage *= (2 * attacker->level / 5 + 2);

            if (gCritMultiplier == 2)
            {
                // Critical hit, if defender has gained sp. defense stat stages then ignore stat increase
                if (defender->statStages[STAT_SPDEF] < DEFAULT_STAT_STAGE)
                    APPLY_STAT_MOD(damageHelper, defender, spDefense, STAT_SPDEF)
                else
                    damageHelper = spDefense;
            }
            else
                APPLY_STAT_MOD(damageHelper, defender, spDefense, STAT_SPDEF)

            damage = (damage / damageHelper);
            damage /= 50;

            // Apply Lightscreen
            if ((sideStatus & SIDE_STATUS_LIGHTSCREEN) && gCritMultiplier == 1)
            {
                if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                    damage = 2 * (damage / 3);
                else
                    damage /= 2;
            }

            // Moves hitting both targets do half damage in double battles
            if ((gBattleTypeFlags & BATTLE_TYPE_DOUBLE) && gBattleMoves[move].target == MOVE_TARGET_BOTH && CountAliveMonsInBattle(BATTLE_ALIVE_DEF_SIDE) == 2)
                damage /= 2;
            // Are effects of weather negated with cloud nine or air lock
            if (WEATHER_HAS_EFFECT2)
            {
                // Rain weakens Fire, boosts Water
                if (gBattleWeather & B_WEATHER_RAIN_TEMPORARY)
                {
                    switch (type)
                    {
                    case TYPE_FIRE:
                        damage /= 2;
                        break;
                    case TYPE_WATER:
                        damage = (15 * damage) / 10;
                        break;
                    }
                }

                // Any weather except sun weakens solar beam
                if ((gBattleWeather & (B_WEATHER_RAIN | B_WEATHER_SANDSTORM | B_WEATHER_HAIL)) && gCurrentMove == MOVE_SOLAR_BEAM)
                    damage /= 2;

                // Sun boosts Fire, weakens Water
                if (gBattleWeather & B_WEATHER_SUN)
                {
                    switch (type)
                    {
                    case TYPE_FIRE:
                        damage = (15 * damage) / 10;
                        break;
                    case TYPE_WATER:
                        damage /= 2;
                        break;
                    }
                }
            }
            // Flash fire triggered
            if ((gBattleResources->flags->flags[battlerIdAtk] & RESOURCE_FLAG_FLASH_FIRE) && type == TYPE_FIRE)
                damage = (15 * damage) / 10;

            return damage + 2;
        }

    // Are effects of weather negated with cloud nine or air lock
    if (gSaveBlock2Ptr->optionStyle == 0)
        if (WEATHER_HAS_EFFECT2)
        {
            // Rain weakens Fire, boosts Water
            if (gBattleWeather & B_WEATHER_RAIN_TEMPORARY)
            {
                switch (type)
                {
                case TYPE_FIRE:
                    damage /= 2;
                    break;
                case TYPE_WATER:
                    damage = (15 * damage) / 10;
                    break;
                }
            }

            // Any weather except sun weakens solar beam
            if ((gBattleWeather & (B_WEATHER_RAIN | B_WEATHER_SANDSTORM | B_WEATHER_HAIL)) && gCurrentMove == MOVE_SOLAR_BEAM)
                damage /= 2;

            // Sun boosts Fire, weakens Water
            if (gBattleWeather & B_WEATHER_SUN)
            {
                switch (type)
                {
                case TYPE_FIRE:
                    damage = (15 * damage) / 10;
                    break;
                case TYPE_WATER:
                    damage /= 2;
                    break;
                }
            }
        }
        if ((gBattleResources->flags->flags[battlerIdAtk] & RESOURCE_FLAG_FLASH_FIRE) && type == TYPE_FIRE)
            damage = (15 * damage) / 10;

        return damage + 2;
}

u8 CountAliveMonsInBattle(u8 caseId)
{
    s32 i;
    u8 retVal = 0;

    switch (caseId)
    {
    case BATTLE_ALIVE_EXCEPT_ACTIVE:
        for (i = 0; i < MAX_BATTLERS_COUNT; i++)
        {
            if (i != gActiveBattler && !(gAbsentBattlerFlags & gBitTable[i]))
                retVal++;
        }
        break;
    case BATTLE_ALIVE_ATK_SIDE:
        for (i = 0; i < MAX_BATTLERS_COUNT; i++)
        {
            if (GetBattlerSide(i) == GetBattlerSide(gBattlerAttacker) && !(gAbsentBattlerFlags & gBitTable[i]))
                retVal++;
        }
        break;
    case BATTLE_ALIVE_DEF_SIDE:
        for (i = 0; i < MAX_BATTLERS_COUNT; i++)
        {
            if (GetBattlerSide(i) == GetBattlerSide(gBattlerTarget) && !(gAbsentBattlerFlags & gBitTable[i]))
=======
u8 CountAliveMonsInBattle(u8 caseId, u32 battler)
{
    u32 i;
    u32 retVal = 0;

    switch (caseId)
    {
    case BATTLE_ALIVE_EXCEPT_BATTLER:
        for (i = 0; i < gBattlersCount; i++)
        {
            if (i != battler && !(gAbsentBattlerFlags & (1u << i)))
                retVal++;
        }
        break;
    case BATTLE_ALIVE_EXCEPT_BATTLER_SIDE:
        for (i = 0; i < gBattlersCount; i++)
        {
            if (i != battler && i != BATTLE_PARTNER(battler) && !(gAbsentBattlerFlags & (1u << i)))
                retVal++;
        }
        break;
    case BATTLE_ALIVE_SIDE:
        for (i = 0; i < gBattlersCount; i++)
        {
            if (IsBattlerAlly(i, battler) && !(gAbsentBattlerFlags & (1u << i)))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                retVal++;
        }
        break;
    }

    return retVal;
}

<<<<<<< HEAD
static bool8 ShouldGetStatBadgeBoost(u16 badgeFlag, u8 battlerId)
{
    if (gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_EREADER_TRAINER | BATTLE_TYPE_RECORDED_LINK | BATTLE_TYPE_FRONTIER))
        return FALSE;
    if (gSaveBlock2Ptr->optionsDifficulty == 2)
        return FALSE;
    else if (GetBattlerSide(battlerId) != B_SIDE_PLAYER)
        return FALSE;
    else if (gBattleTypeFlags & BATTLE_TYPE_TRAINER && gTrainerBattleOpponent_A == TRAINER_SECRET_BASE)
        return FALSE;
    else if (FlagGet(badgeFlag))
        return TRUE;
    else
        return FALSE;
}

u8 GetDefaultMoveTarget(u8 battlerId)
{
    u8 opposing = BATTLE_OPPOSITE(GET_BATTLER_SIDE(battlerId));

    if (!(gBattleTypeFlags & BATTLE_TYPE_DOUBLE))
        return GetBattlerAtPosition(opposing);
    if (CountAliveMonsInBattle(BATTLE_ALIVE_EXCEPT_ACTIVE) > 1)
=======
u8 GetDefaultMoveTarget(u8 battlerId)
{
    u8 opposing = BATTLE_OPPOSITE(GetBattlerSide(battlerId));

    if (!IsDoubleBattle())
        return GetBattlerAtPosition(opposing);
    if (CountAliveMonsInBattle(BATTLE_ALIVE_EXCEPT_BATTLER, battlerId) > 1)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        u8 position;

        if ((Random() & 1) == 0)
            position = BATTLE_PARTNER(opposing);
        else
            position = opposing;

        return GetBattlerAtPosition(position);
    }
    else
    {
<<<<<<< HEAD
        if ((gAbsentBattlerFlags & gBitTable[opposing]))
=======
        if ((gAbsentBattlerFlags & (1u << opposing)))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            return GetBattlerAtPosition(BATTLE_PARTNER(opposing));
        else
            return GetBattlerAtPosition(opposing);
    }
}

u8 GetMonGender(struct Pokemon *mon)
{
    return GetBoxMonGender(&mon->box);
}

u8 GetBoxMonGender(struct BoxPokemon *boxMon)
{
    u16 species = GetBoxMonData(boxMon, MON_DATA_SPECIES, NULL);
    u32 personality = GetBoxMonData(boxMon, MON_DATA_PERSONALITY, NULL);

    switch (gSpeciesInfo[species].genderRatio)
    {
    case MON_MALE:
    case MON_FEMALE:
    case MON_GENDERLESS:
        return gSpeciesInfo[species].genderRatio;
    }

    if (gSpeciesInfo[species].genderRatio > (personality & 0xFF))
        return MON_FEMALE;
    else
        return MON_MALE;
}

u8 GetGenderFromSpeciesAndPersonality(u16 species, u32 personality)
{
    switch (gSpeciesInfo[species].genderRatio)
    {
    case MON_MALE:
    case MON_FEMALE:
    case MON_GENDERLESS:
        return gSpeciesInfo[species].genderRatio;
    }

    if (gSpeciesInfo[species].genderRatio > (personality & 0xFF))
        return MON_FEMALE;
    else
        return MON_MALE;
}

<<<<<<< HEAD
=======
bool32 IsPersonalityFemale(u16 species, u32 personality)
{
    return GetGenderFromSpeciesAndPersonality(species, personality) == MON_FEMALE;
}

u32 GetUnownSpeciesId(u32 personality)
{
    u16 unownLetter = GetUnownLetterByPersonality(personality);

    if (unownLetter == 0)
        return SPECIES_UNOWN;
    return unownLetter + SPECIES_UNOWN_B - 1;
}

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
void SetMultiuseSpriteTemplateToPokemon(u16 speciesTag, u8 battlerPosition)
{
    if (gMonSpritesGfxPtr != NULL)
        gMultiuseSpriteTemplate = gMonSpritesGfxPtr->templates[battlerPosition];
    else if (sMonSpritesGfxManagers[MON_SPR_GFX_MANAGER_A])
        gMultiuseSpriteTemplate = sMonSpritesGfxManagers[MON_SPR_GFX_MANAGER_A]->templates[battlerPosition];
    else if (sMonSpritesGfxManagers[MON_SPR_GFX_MANAGER_B])
        gMultiuseSpriteTemplate = sMonSpritesGfxManagers[MON_SPR_GFX_MANAGER_B]->templates[battlerPosition];
    else
        gMultiuseSpriteTemplate = gBattlerSpriteTemplates[battlerPosition];

    gMultiuseSpriteTemplate.paletteTag = speciesTag;
    if (battlerPosition == B_POSITION_PLAYER_LEFT || battlerPosition == B_POSITION_PLAYER_RIGHT)
        gMultiuseSpriteTemplate.anims = gAnims_MonPic;
<<<<<<< HEAD
    else if (speciesTag > SPECIES_SHINY_TAG)
        gMultiuseSpriteTemplate.anims = gMonFrontAnimsPtrTable[speciesTag - SPECIES_SHINY_TAG];
    else
        gMultiuseSpriteTemplate.anims = gMonFrontAnimsPtrTable[speciesTag];
=======
    else
    {
        if (speciesTag > SPECIES_SHINY_TAG)
            speciesTag = speciesTag - SPECIES_SHINY_TAG;

        speciesTag = SanitizeSpeciesId(speciesTag);
        if (gSpeciesInfo[speciesTag].frontAnimFrames != NULL)
            gMultiuseSpriteTemplate.anims = gSpeciesInfo[speciesTag].frontAnimFrames;
        else
            gMultiuseSpriteTemplate.anims = gSpeciesInfo[SPECIES_NONE].frontAnimFrames;
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void SetMultiuseSpriteTemplateToTrainerBack(u16 trainerPicId, u8 battlerPosition)
{
    gMultiuseSpriteTemplate.paletteTag = trainerPicId;
    if (battlerPosition == B_POSITION_PLAYER_LEFT || battlerPosition == B_POSITION_PLAYER_RIGHT)
    {
<<<<<<< HEAD
        gMultiuseSpriteTemplate = sTrainerBackSpriteTemplates[trainerPicId];
        gMultiuseSpriteTemplate.anims = gTrainerBackAnimsPtrTable[trainerPicId];
=======
        gMultiuseSpriteTemplate = sTrainerBackSpriteTemplate;
        gMultiuseSpriteTemplate.images = &gTrainerBacksprites[trainerPicId].backPic;
        gMultiuseSpriteTemplate.anims = gTrainerBacksprites[trainerPicId].animation;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }
    else
    {
        if (gMonSpritesGfxPtr != NULL)
            gMultiuseSpriteTemplate = gMonSpritesGfxPtr->templates[battlerPosition];
        else
            gMultiuseSpriteTemplate = gBattlerSpriteTemplates[battlerPosition];
<<<<<<< HEAD
        gMultiuseSpriteTemplate.anims = gTrainerFrontAnimsPtrTable[trainerPicId];
=======
        gMultiuseSpriteTemplate.anims = gAnims_Trainer;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }
}

void SetMultiuseSpriteTemplateToTrainerFront(u16 trainerPicId, u8 battlerPosition)
{
    if (gMonSpritesGfxPtr != NULL)
        gMultiuseSpriteTemplate = gMonSpritesGfxPtr->templates[battlerPosition];
    else
        gMultiuseSpriteTemplate = gBattlerSpriteTemplates[battlerPosition];

    gMultiuseSpriteTemplate.paletteTag = trainerPicId;
<<<<<<< HEAD
    gMultiuseSpriteTemplate.anims = gTrainerFrontAnimsPtrTable[trainerPicId];
=======
    gMultiuseSpriteTemplate.anims = gAnims_Trainer;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

static void EncryptBoxMon(struct BoxPokemon *boxMon)
{
<<<<<<< HEAD
    u32 i;
    for (i = 0; i < ARRAY_COUNT(boxMon->secure.raw); i++)
=======
    for (u32 i = 0; i < ARRAY_COUNT(boxMon->secure.raw); i++)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        boxMon->secure.raw[i] ^= boxMon->personality;
        boxMon->secure.raw[i] ^= boxMon->otId;
    }
}

static void DecryptBoxMon(struct BoxPokemon *boxMon)
{
<<<<<<< HEAD
    u32 i;
    for (i = 0; i < ARRAY_COUNT(boxMon->secure.raw); i++)
=======
    for (u32 i = 0; i < ARRAY_COUNT(boxMon->secure.raw); i++)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        boxMon->secure.raw[i] ^= boxMon->otId;
        boxMon->secure.raw[i] ^= boxMon->personality;
    }
}

<<<<<<< HEAD
#define SUBSTRUCT_CASE(n, v1, v2, v3, v4)                               \
case n:                                                                 \
    {                                                                   \
    union PokemonSubstruct *substructs0 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs1 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs2 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs3 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs4 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs5 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs6 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs7 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs8 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs9 = boxMon->secure.substructs;    \
    union PokemonSubstruct *substructs10 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs11 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs12 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs13 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs14 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs15 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs16 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs17 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs18 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs19 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs20 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs21 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs22 = boxMon->secure.substructs;   \
    union PokemonSubstruct *substructs23 = boxMon->secure.substructs;   \
                                                                        \
        switch (substructType)                                          \
        {                                                               \
        case 0:                                                         \
            substruct = &substructs ## n [v1];                          \
            break;                                                      \
        case 1:                                                         \
            substruct = &substructs ## n [v2];                          \
            break;                                                      \
        case 2:                                                         \
            substruct = &substructs ## n [v3];                          \
            break;                                                      \
        case 3:                                                         \
            substruct = &substructs ## n [v4];                          \
            break;                                                      \
        }                                                               \
        break;                                                          \
    }                                                                   \


static union PokemonSubstruct *GetSubstruct(struct BoxPokemon *boxMon, u32 personality, u8 substructType)
{
    union PokemonSubstruct *substruct = NULL;

    switch (personality % 24)
    {
        SUBSTRUCT_CASE( 0,0,1,2,3)
        SUBSTRUCT_CASE( 1,0,1,3,2)
        SUBSTRUCT_CASE( 2,0,2,1,3)
        SUBSTRUCT_CASE( 3,0,3,1,2)
        SUBSTRUCT_CASE( 4,0,2,3,1)
        SUBSTRUCT_CASE( 5,0,3,2,1)
        SUBSTRUCT_CASE( 6,1,0,2,3)
        SUBSTRUCT_CASE( 7,1,0,3,2)
        SUBSTRUCT_CASE( 8,2,0,1,3)
        SUBSTRUCT_CASE( 9,3,0,1,2)
        SUBSTRUCT_CASE(10,2,0,3,1)
        SUBSTRUCT_CASE(11,3,0,2,1)
        SUBSTRUCT_CASE(12,1,2,0,3)
        SUBSTRUCT_CASE(13,1,3,0,2)
        SUBSTRUCT_CASE(14,2,1,0,3)
        SUBSTRUCT_CASE(15,3,1,0,2)
        SUBSTRUCT_CASE(16,2,3,0,1)
        SUBSTRUCT_CASE(17,3,2,0,1)
        SUBSTRUCT_CASE(18,1,2,3,0)
        SUBSTRUCT_CASE(19,1,3,2,0)
        SUBSTRUCT_CASE(20,2,1,3,0)
        SUBSTRUCT_CASE(21,3,1,2,0)
        SUBSTRUCT_CASE(22,2,3,1,0)
        SUBSTRUCT_CASE(23,3,2,1,0)
    }

    return substruct;
=======
static const u8 sSubstructOffsets[4][24] =
{
    [SUBSTRUCT_TYPE_0] = {0, 0, 0, 0, 0, 0, 1, 1, 2, 3, 2, 3, 1, 1, 2, 3, 2, 3, 1, 1, 2, 3, 2, 3},
    [SUBSTRUCT_TYPE_1] = {1, 1, 2, 3, 2, 3, 0, 0, 0, 0, 0, 0, 2, 3, 1, 1, 3, 2, 2, 3, 1, 1, 3, 2},
    [SUBSTRUCT_TYPE_2] = {2, 3, 1, 1, 3, 2, 2, 3, 1, 1, 3, 2, 0, 0, 0, 0, 0, 0, 3, 2, 3, 2, 1, 1},
    [SUBSTRUCT_TYPE_3] = {3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 3, 2, 3, 2, 1, 1, 0, 0, 0, 0, 0, 0},
};

ARM_FUNC NOINLINE static u32 ConstantMod24(u32 a) { return a % 24; }

static union PokemonSubstruct *GetSubstruct(struct BoxPokemon *boxMon, u32 personality, enum SubstructType substructType)
{
    return &boxMon->secure.substructs[sSubstructOffsets[substructType][ConstantMod24(personality)]];
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

/* GameFreak called GetMonData with either 2 or 3 arguments, for type
 * safety we have a GetMonData macro (in include/pokemon.h) which
 * dispatches to either GetMonData2 or GetMonData3 based on the number
 * of arguments. */
u32 GetMonData3(struct Pokemon *mon, s32 field, u8 *data)
{
    u32 ret;

    switch (field)
    {
    case MON_DATA_STATUS:
        ret = mon->status;
        break;
    case MON_DATA_LEVEL:
        ret = mon->level;
        break;
    case MON_DATA_HP:
        ret = mon->hp;
        break;
    case MON_DATA_MAX_HP:
        ret = mon->maxHP;
        break;
    case MON_DATA_ATK:
<<<<<<< HEAD
        //ret = GetDeoxysStat(mon, STAT_ATK);
        //if (!ret)
        ret = mon->attack;
        break;
    case MON_DATA_DEF:
        //ret = GetDeoxysStat(mon, STAT_DEF);
        //if (!ret)
        ret = mon->defense;
        break;
    case MON_DATA_SPEED:
        //ret = GetDeoxysStat(mon, STAT_SPEED);
        //if (!ret)
        ret = mon->speed;
        break;
    case MON_DATA_SPATK:
        //ret = GetDeoxysStat(mon, STAT_SPATK);
        //if (!ret)
        ret = mon->spAttack;
        break;
    case MON_DATA_SPDEF:
        //ret = GetDeoxysStat(mon, STAT_SPDEF);
        //if (!ret)
=======
        ret = mon->attack;
        break;
    case MON_DATA_DEF:
        ret = mon->defense;
        break;
    case MON_DATA_SPEED:
        ret = mon->speed;
        break;
    case MON_DATA_SPATK:
        ret = mon->spAttack;
        break;
    case MON_DATA_SPDEF:
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        ret = mon->spDefense;
        break;
    case MON_DATA_ATK2:
        ret = mon->attack;
        break;
    case MON_DATA_DEF2:
        ret = mon->defense;
        break;
    case MON_DATA_SPEED2:
        ret = mon->speed;
        break;
    case MON_DATA_SPATK2:
        ret = mon->spAttack;
        break;
    case MON_DATA_SPDEF2:
        ret = mon->spDefense;
        break;
    case MON_DATA_MAIL:
        ret = mon->mail;
        break;
    default:
        ret = GetBoxMonData(&mon->box, field, data);
        break;
    }
    return ret;
}

<<<<<<< HEAD
u32 GetMonData2(struct Pokemon *mon, s32 field) __attribute__((alias("GetMonData3")));
=======
u32 GetMonData2(struct Pokemon *mon, s32 field)
{
    return GetMonData3(mon, field, NULL);
}


union EvolutionTracker
{
    u16 combinedValue:10;
    struct {
        u16 tracker1: 5;
        u16 tracker2: 5;
    };
};

static ALWAYS_INLINE struct PokemonSubstruct0 *GetSubstruct0(struct BoxPokemon *boxMon)
{
    return &(GetSubstruct(boxMon, boxMon->personality, SUBSTRUCT_TYPE_0)->type0);
}

static ALWAYS_INLINE struct PokemonSubstruct1 *GetSubstruct1(struct BoxPokemon *boxMon)
{
    return &(GetSubstruct(boxMon, boxMon->personality, SUBSTRUCT_TYPE_1)->type1);
}

static ALWAYS_INLINE struct PokemonSubstruct2 *GetSubstruct2(struct BoxPokemon *boxMon)
{
    return &(GetSubstruct(boxMon, boxMon->personality, SUBSTRUCT_TYPE_2)->type2);
}

static ALWAYS_INLINE struct PokemonSubstruct3 *GetSubstruct3(struct BoxPokemon *boxMon)
{
    return &(GetSubstruct(boxMon, boxMon->personality, SUBSTRUCT_TYPE_3)->type3);
}

static bool32 IsBadEgg(struct BoxPokemon *boxMon)
{
    if (boxMon->isBadEgg)
        return TRUE;

    if (CalculateBoxMonChecksum(boxMon) != boxMon->checksum)
    {
        boxMon->isBadEgg = TRUE;
        boxMon->isEgg = TRUE;
        GetSubstruct3(boxMon)->isEgg = TRUE;

        return TRUE;
    }

    return FALSE;
}

static ALWAYS_INLINE bool32 IsEggOrBadEgg(struct BoxPokemon *boxMon)
{
    return GetSubstruct3(boxMon)->isEgg || IsBadEgg(boxMon);
}
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

/* GameFreak called GetBoxMonData with either 2 or 3 arguments, for type
 * safety we have a GetBoxMonData macro (in include/pokemon.h) which
 * dispatches to either GetBoxMonData2 or GetBoxMonData3 based on the
 * number of arguments. */
u32 GetBoxMonData3(struct BoxPokemon *boxMon, s32 field, u8 *data)
{
    s32 i;
    u32 retVal = 0;
<<<<<<< HEAD
    struct PokemonSubstruct0 *substruct0 = NULL;
    struct PokemonSubstruct1 *substruct1 = NULL;
    struct PokemonSubstruct2 *substruct2 = NULL;
    struct PokemonSubstruct3 *substruct3 = NULL;
=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    // Any field greater than MON_DATA_ENCRYPT_SEPARATOR is encrypted and must be treated as such
    if (field > MON_DATA_ENCRYPT_SEPARATOR)
    {
<<<<<<< HEAD
        substruct0 = &(GetSubstruct(boxMon, boxMon->personality, 0)->type0);
        substruct1 = &(GetSubstruct(boxMon, boxMon->personality, 1)->type1);
        substruct2 = &(GetSubstruct(boxMon, boxMon->personality, 2)->type2);
        substruct3 = &(GetSubstruct(boxMon, boxMon->personality, 3)->type3);

        DecryptBoxMon(boxMon);

        if (CalculateBoxMonChecksum(boxMon) != boxMon->checksum)
        {
            boxMon->isBadEgg = TRUE;
            boxMon->isEgg = TRUE;
            substruct3->isEgg = TRUE;
        }
    }

    switch (field)
    {
    case MON_DATA_PERSONALITY:
        retVal = boxMon->personality;
        break;
    case MON_DATA_OT_ID:
        retVal = boxMon->otId;
        break;
    case MON_DATA_NICKNAME:
    {
        if (boxMon->isBadEgg)
        {
            for (retVal = 0;
                retVal < POKEMON_NAME_LENGTH && gText_BadEgg[retVal] != EOS;
                data[retVal] = gText_BadEgg[retVal], retVal++) {}

            data[retVal] = EOS;
        }
        else if (boxMon->isEgg)
        {
            StringCopy(data, gText_EggNickname);
            retVal = StringLength(data);
        }
        else if (boxMon->language == LANGUAGE_JAPANESE)
        {
            data[0] = EXT_CTRL_CODE_BEGIN;
            data[1] = EXT_CTRL_CODE_JPN;

            for (retVal = 2, i = 0;
                i < 5 && boxMon->nickname[i] != EOS;
                data[retVal] = boxMon->nickname[i], retVal++, i++) {}

            data[retVal++] = EXT_CTRL_CODE_BEGIN;
            data[retVal++] = EXT_CTRL_CODE_ENG;
            data[retVal] = EOS;
        }
        else
        {
            for (retVal = 0;
                retVal < POKEMON_NAME_LENGTH;
                data[retVal] = boxMon->nickname[retVal], retVal++){}

            data[retVal] = EOS;
        }
        break;
    }
    case MON_DATA_LANGUAGE:
        retVal = boxMon->language;
        break;
    case MON_DATA_SANITY_IS_BAD_EGG:
        retVal = boxMon->isBadEgg;
        break;
    case MON_DATA_SANITY_HAS_SPECIES:
        retVal = boxMon->hasSpecies;
        break;
    case MON_DATA_SANITY_IS_EGG:
        retVal = boxMon->isEgg;
        break;
    case MON_DATA_IN_PC:
        retVal = boxMon->inPC;
        break;
    case MON_DATA_OT_NAME:
    {
        retVal = 0;

        while (retVal < PLAYER_NAME_LENGTH)
        {
            data[retVal] = boxMon->otName[retVal];
            retVal++;
        }

        data[retVal] = EOS;
        break;
    }
    case MON_DATA_MARKINGS:
        retVal = boxMon->markings;
        break;
    case MON_DATA_CHECKSUM:
        retVal = boxMon->checksum;
        break;
    case MON_DATA_ENCRYPT_SEPARATOR:
        retVal = boxMon->unknown;
        break;
    case MON_DATA_SPECIES:
        retVal = boxMon->isBadEgg ? SPECIES_EGG : substruct0->species;
        break;
    case MON_DATA_HELD_ITEM:
        retVal = substruct0->heldItem;
        break;
    case MON_DATA_EXP:
        retVal = substruct0->experience;
        break;
    case MON_DATA_PP_BONUSES:
        retVal = substruct0->ppBonuses;
        break;
    case MON_DATA_FRIENDSHIP:
        retVal = substruct0->friendship;
        break;
    case MON_DATA_MOVE1:
    case MON_DATA_MOVE2:
    case MON_DATA_MOVE3:
    case MON_DATA_MOVE4:
        retVal = substruct1->moves[field - MON_DATA_MOVE1];
        break;
    case MON_DATA_PP1:
    case MON_DATA_PP2:
    case MON_DATA_PP3:
    case MON_DATA_PP4:
        retVal = substruct1->pp[field - MON_DATA_PP1];
        break;
    case MON_DATA_HP_EV:
        retVal = substruct2->hpEV;
        break;
    case MON_DATA_ATK_EV:
        retVal = substruct2->attackEV;
        break;
    case MON_DATA_DEF_EV:
        retVal = substruct2->defenseEV;
        break;
    case MON_DATA_SPEED_EV:
        retVal = substruct2->speedEV;
        break;
    case MON_DATA_SPATK_EV:
        retVal = substruct2->spAttackEV;
        break;
    case MON_DATA_SPDEF_EV:
        retVal = substruct2->spDefenseEV;
        break;
    case MON_DATA_COOL:
        retVal = substruct2->cool;
        break;
    case MON_DATA_BEAUTY:
        retVal = substruct2->beauty;
        break;
    case MON_DATA_CUTE:
        retVal = substruct2->cute;
        break;
    case MON_DATA_SMART:
        retVal = substruct2->smart;
        break;
    case MON_DATA_TOUGH:
        retVal = substruct2->tough;
        break;
    case MON_DATA_SHEEN:
        retVal = substruct2->sheen;
        break;
    case MON_DATA_POKERUS:
        retVal = substruct3->pokerus;
        break;
    case MON_DATA_MET_LOCATION:
        retVal = substruct3->metLocation;
        break;
    case MON_DATA_MET_LEVEL:
        retVal = substruct3->metLevel;
        break;
    case MON_DATA_MET_GAME:
        retVal = substruct3->metGame;
        break;
    case MON_DATA_POKEBALL:
        retVal = substruct3->pokeball;
        break;
    case MON_DATA_OT_GENDER:
        retVal = substruct3->otGender;
        break;
    case MON_DATA_HP_IV:
        retVal = substruct3->hpIV;
        break;
    case MON_DATA_ATK_IV:
        retVal = substruct3->attackIV;
        break;
    case MON_DATA_DEF_IV:
        retVal = substruct3->defenseIV;
        break;
    case MON_DATA_SPEED_IV:
        retVal = substruct3->speedIV;
        break;
    case MON_DATA_SPATK_IV:
        retVal = substruct3->spAttackIV;
        break;
    case MON_DATA_SPDEF_IV:
        retVal = substruct3->spDefenseIV;
        break;
    case MON_DATA_IS_EGG:
        retVal = substruct3->isEgg;
        break;
    case MON_DATA_ABILITY_NUM:
        retVal = substruct3->abilityNum;
        break;
    case MON_DATA_COOL_RIBBON:
        retVal = substruct3->coolRibbon;
        break;
    case MON_DATA_BEAUTY_RIBBON:
        retVal = substruct3->beautyRibbon;
        break;
    case MON_DATA_CUTE_RIBBON:
        retVal = substruct3->cuteRibbon;
        break;
    case MON_DATA_SMART_RIBBON:
        retVal = substruct3->smartRibbon;
        break;
    case MON_DATA_TOUGH_RIBBON:
        retVal = substruct3->toughRibbon;
        break;
    case MON_DATA_CHAMPION_RIBBON:
        retVal = substruct3->championRibbon;
        break;
    case MON_DATA_WINNING_RIBBON:
        retVal = substruct3->winningRibbon;
        break;
    case MON_DATA_VICTORY_RIBBON:
        retVal = substruct3->victoryRibbon;
        break;
    case MON_DATA_ARTIST_RIBBON:
        retVal = substruct3->artistRibbon;
        break;
    case MON_DATA_EFFORT_RIBBON:
        retVal = substruct3->effortRibbon;
        break;
    case MON_DATA_MARINE_RIBBON:
        retVal = substruct3->marineRibbon;
        break;
    case MON_DATA_LAND_RIBBON:
        retVal = substruct3->landRibbon;
        break;
    case MON_DATA_SKY_RIBBON:
        retVal = substruct3->skyRibbon;
        break;
    case MON_DATA_COUNTRY_RIBBON:
        retVal = substruct3->countryRibbon;
        break;
    case MON_DATA_NATIONAL_RIBBON:
        retVal = substruct3->nationalRibbon;
        break;
    case MON_DATA_EARTH_RIBBON:
        retVal = substruct3->earthRibbon;
        break;
    case MON_DATA_WORLD_RIBBON:
        retVal = substruct3->worldRibbon;
        break;
    case MON_DATA_UNUSED_RIBBONS:
        retVal = substruct3->unusedRibbons;
        break;
    case MON_DATA_NUZLOCKE_RIBBON:
        retVal = substruct3->nuzlockeRibbon;
        break;
    case MON_DATA_MODERN_FATEFUL_ENCOUNTER:
        retVal = substruct3->modernFatefulEncounter;
        break;
    case MON_DATA_SPECIES_OR_EGG:
        retVal = substruct0->species;
        if (substruct0->species && (substruct3->isEgg || boxMon->isBadEgg))
            retVal = SPECIES_EGG;
        break;
    case MON_DATA_IVS:
        retVal = substruct3->hpIV
              | (substruct3->attackIV << 5)
              | (substruct3->defenseIV << 10)
              | (substruct3->speedIV << 15)
              | (substruct3->spAttackIV << 20)
              | (substruct3->spDefenseIV << 25);
        break;
    case MON_DATA_KNOWN_MOVES:
        if (substruct0->species && !substruct3->isEgg)
        {
            u16 *moves = (u16 *)data;
            s32 i = 0;

            while (moves[i] != MOVES_COUNT)
            {
                u16 move = moves[i];
                if (substruct1->moves[0] == move
                 || substruct1->moves[1] == move
                 || substruct1->moves[2] == move
                 || substruct1->moves[3] == move)
                    retVal |= gBitTable[i];
                i++;
            }
        }
        break;
    case MON_DATA_RIBBON_COUNT:
        retVal = 0;
        if (substruct0->species && !substruct3->isEgg)
        {
            retVal += substruct3->coolRibbon;
            retVal += substruct3->beautyRibbon;
            retVal += substruct3->cuteRibbon;
            retVal += substruct3->smartRibbon;
            retVal += substruct3->toughRibbon;
            retVal += substruct3->championRibbon;
            retVal += substruct3->winningRibbon;
            retVal += substruct3->victoryRibbon;
            retVal += substruct3->artistRibbon;
            retVal += substruct3->effortRibbon;
            retVal += substruct3->marineRibbon;
            retVal += substruct3->landRibbon;
            retVal += substruct3->skyRibbon;
            retVal += substruct3->countryRibbon;
            retVal += substruct3->nationalRibbon;
            retVal += substruct3->earthRibbon;
            retVal += substruct3->worldRibbon;
        }
        break;
    case MON_DATA_RIBBONS:
        retVal = 0;
        if (substruct0->species && !substruct3->isEgg)
        {
            retVal = substruct3->championRibbon
                | (substruct3->coolRibbon << 1)
                | (substruct3->beautyRibbon << 4)
                | (substruct3->cuteRibbon << 7)
                | (substruct3->smartRibbon << 10)
                | (substruct3->toughRibbon << 13)
                | (substruct3->winningRibbon << 16)
                | (substruct3->victoryRibbon << 17)
                | (substruct3->artistRibbon << 18)
                | (substruct3->effortRibbon << 19)
                | (substruct3->marineRibbon << 20)
                | (substruct3->landRibbon << 21)
                | (substruct3->skyRibbon << 22)
                | (substruct3->countryRibbon << 23)
                | (substruct3->nationalRibbon << 24)
                | (substruct3->earthRibbon << 25)
                | (substruct3->worldRibbon << 26);
        }
        break;
    case MON_DATA_HIDDEN_NATURE:
        retVal = substruct0->hiddenNature;
        break;
    case MON_DATA_BOX_HP:
        retVal = substruct0->box_hp;
        break;
    case MON_DATA_BOX_AILMENT:
        retVal = substruct0->box_ailment;
        break;
    default:
        break;
=======
        DecryptBoxMon(boxMon);

        switch (field)
        {
        case MON_DATA_NICKNAME:
        case MON_DATA_NICKNAME10:
        {
            if (IsBadEgg(boxMon))
            {
                for (retVal = 0;
                    retVal < POKEMON_NAME_LENGTH && gText_BadEgg[retVal] != EOS;
                    data[retVal] = gText_BadEgg[retVal], retVal++) {}

                data[retVal] = EOS;
            }
            else if (boxMon->isEgg)
            {
                StringCopy(data, gText_EggNickname);
                retVal = StringLength(data);
            }
            else if (boxMon->language == LANGUAGE_JAPANESE)
            {
                data[0] = EXT_CTRL_CODE_BEGIN;
                data[1] = EXT_CTRL_CODE_JPN;

                for (retVal = 2, i = 0;
                    i < 5 && boxMon->nickname[i] != EOS;
                    data[retVal] = boxMon->nickname[i], retVal++, i++) {}

                data[retVal++] = EXT_CTRL_CODE_BEGIN;
                data[retVal++] = EXT_CTRL_CODE_ENG;
                data[retVal] = EOS;
            }
            else
            {
                retVal = 0;
                while (retVal < min(sizeof(boxMon->nickname), POKEMON_NAME_LENGTH))
                {
                    data[retVal] = boxMon->nickname[retVal];
                    retVal++;
                }

                // Vanilla PokÃ©mon have 0s in nickname11 and nickname12
                // so if both are 0 we assume that this is a vanilla
                // PokÃ©mon and replace them with EOS. This means that
                // two CHAR_SPACE at the end of a nickname are trimmed.
                struct PokemonSubstruct0 *substruct0 = GetSubstruct0(boxMon);
                if (field != MON_DATA_NICKNAME10 && POKEMON_NAME_LENGTH >= 12)
                {
                    if (substruct0->nickname11 == 0 && substruct0->nickname12 == 0)
                    {
                        data[retVal++] = EOS;
                        data[retVal++] = EOS;
                    }
                    else
                    {
                        data[retVal++] = substruct0->nickname11;
                        data[retVal++] = substruct0->nickname12;
                    }
                }
                else if (POKEMON_NAME_LENGTH >= 11)
                {
                    if (substruct0->nickname11 == 0)
                    {
                        data[retVal++] = EOS;
                    }
                    else
                    {
                        data[retVal++] = substruct0->nickname11;
                    }
                }

                data[retVal] = EOS;
            }
            break;
        }
        case MON_DATA_SPECIES:
            retVal = IsBadEgg(boxMon) ? SPECIES_EGG : GetSubstruct0(boxMon)->species;
            break;
        case MON_DATA_HELD_ITEM:
            retVal = GetSubstruct0(boxMon)->heldItem;
            break;
        case MON_DATA_EXP:
            retVal = GetSubstruct0(boxMon)->experience;
            break;
        case MON_DATA_PP_BONUSES:
            retVal = GetSubstruct0(boxMon)->ppBonuses;
            break;
        case MON_DATA_FRIENDSHIP:
            retVal = GetSubstruct0(boxMon)->friendship;
            break;
        case MON_DATA_MOVE1:
            retVal = GetSubstruct1(boxMon)->move1;
            break;
        case MON_DATA_MOVE2:
            retVal = GetSubstruct1(boxMon)->move2;
            break;
        case MON_DATA_MOVE3:
            retVal = GetSubstruct1(boxMon)->move3;
            break;
        case MON_DATA_MOVE4:
            retVal = GetSubstruct1(boxMon)->move4;
            break;
        case MON_DATA_PP1:
            retVal = GetSubstruct1(boxMon)->pp1;
            break;
        case MON_DATA_PP2:
            retVal = GetSubstruct1(boxMon)->pp2;
            break;
        case MON_DATA_PP3:
            retVal = GetSubstruct1(boxMon)->pp3;
            break;
        case MON_DATA_PP4:
            retVal = GetSubstruct1(boxMon)->pp4;
            break;
        case MON_DATA_HP_EV:
            retVal = GetSubstruct2(boxMon)->hpEV;
            break;
        case MON_DATA_ATK_EV:
            retVal = GetSubstruct2(boxMon)->attackEV;
            break;
        case MON_DATA_DEF_EV:
            retVal = GetSubstruct2(boxMon)->defenseEV;
            break;
        case MON_DATA_SPEED_EV:
            retVal = GetSubstruct2(boxMon)->speedEV;
            break;
        case MON_DATA_SPATK_EV:
            retVal = GetSubstruct2(boxMon)->spAttackEV;
            break;
        case MON_DATA_SPDEF_EV:
            retVal = GetSubstruct2(boxMon)->spDefenseEV;
            break;
        case MON_DATA_COOL:
            retVal = GetSubstruct2(boxMon)->cool;
            break;
        case MON_DATA_BEAUTY:
            retVal = GetSubstruct2(boxMon)->beauty;
            break;
        case MON_DATA_CUTE:
            retVal = GetSubstruct2(boxMon)->cute;
            break;
        case MON_DATA_SMART:
            retVal = GetSubstruct2(boxMon)->smart;
            break;
        case MON_DATA_TOUGH:
            retVal = GetSubstruct2(boxMon)->tough;
            break;
        case MON_DATA_SHEEN:
            retVal = GetSubstruct2(boxMon)->sheen;
            break;
        case MON_DATA_POKERUS:
            retVal = GetSubstruct3(boxMon)->pokerus;
            break;
        case MON_DATA_MET_LOCATION:
            retVal = GetSubstruct3(boxMon)->metLocation;
            break;
        case MON_DATA_MET_LEVEL:
            retVal = GetSubstruct3(boxMon)->metLevel;
            break;
        case MON_DATA_MET_GAME:
            retVal = GetSubstruct3(boxMon)->metGame;
            break;
        case MON_DATA_POKEBALL:
            retVal = GetSubstruct0(boxMon)->pokeball;
            break;
        case MON_DATA_OT_GENDER:
            retVal = GetSubstruct3(boxMon)->otGender;
            break;
        case MON_DATA_HP_IV:
            retVal = GetSubstruct3(boxMon)->hpIV;
            break;
        case MON_DATA_ATK_IV:
            retVal = GetSubstruct3(boxMon)->attackIV;
            break;
        case MON_DATA_DEF_IV:
            retVal = GetSubstruct3(boxMon)->defenseIV;
            break;
        case MON_DATA_SPEED_IV:
            retVal = GetSubstruct3(boxMon)->speedIV;
            break;
        case MON_DATA_SPATK_IV:
            retVal = GetSubstruct3(boxMon)->spAttackIV;
            break;
        case MON_DATA_SPDEF_IV:
            retVal = GetSubstruct3(boxMon)->spDefenseIV;
            break;
        case MON_DATA_IS_EGG:
            retVal = IsEggOrBadEgg(boxMon);
            break;
        case MON_DATA_ABILITY_NUM:
            retVal = GetSubstruct3(boxMon)->abilityNum;
            break;
        case MON_DATA_COOL_RIBBON:
            retVal = GetSubstruct3(boxMon)->coolRibbon;
            break;
        case MON_DATA_BEAUTY_RIBBON:
            retVal = GetSubstruct3(boxMon)->beautyRibbon;
            break;
        case MON_DATA_CUTE_RIBBON:
            retVal = GetSubstruct3(boxMon)->cuteRibbon;
            break;
        case MON_DATA_SMART_RIBBON:
            retVal = GetSubstruct3(boxMon)->smartRibbon;
            break;
        case MON_DATA_TOUGH_RIBBON:
            retVal = GetSubstruct3(boxMon)->toughRibbon;
            break;
        case MON_DATA_CHAMPION_RIBBON:
            retVal = GetSubstruct3(boxMon)->championRibbon;
            break;
        case MON_DATA_WINNING_RIBBON:
            retVal = GetSubstruct3(boxMon)->winningRibbon;
            break;
        case MON_DATA_VICTORY_RIBBON:
            retVal = GetSubstruct3(boxMon)->victoryRibbon;
            break;
        case MON_DATA_ARTIST_RIBBON:
            retVal = GetSubstruct3(boxMon)->artistRibbon;
            break;
        case MON_DATA_EFFORT_RIBBON:
            retVal = GetSubstruct3(boxMon)->effortRibbon;
            break;
        case MON_DATA_MARINE_RIBBON:
            retVal = GetSubstruct3(boxMon)->marineRibbon;
            break;
        case MON_DATA_LAND_RIBBON:
            retVal = GetSubstruct3(boxMon)->landRibbon;
            break;
        case MON_DATA_SKY_RIBBON:
            retVal = GetSubstruct3(boxMon)->skyRibbon;
            break;
        case MON_DATA_COUNTRY_RIBBON:
            retVal = GetSubstruct3(boxMon)->countryRibbon;
            break;
        case MON_DATA_NATIONAL_RIBBON:
            retVal = GetSubstruct3(boxMon)->nationalRibbon;
            break;
        case MON_DATA_EARTH_RIBBON:
            retVal = GetSubstruct3(boxMon)->earthRibbon;
            break;
        case MON_DATA_WORLD_RIBBON:
            retVal = GetSubstruct3(boxMon)->worldRibbon;
            break;
        case MON_DATA_MODERN_FATEFUL_ENCOUNTER:
            retVal = GetSubstruct3(boxMon)->modernFatefulEncounter;
            break;
        case MON_DATA_SPECIES_OR_EGG:
            retVal = GetSubstruct0(boxMon)->species;
            if (retVal && IsEggOrBadEgg(boxMon))
                retVal = SPECIES_EGG;
            break;
        case MON_DATA_IVS:
        {
            struct PokemonSubstruct3 *substruct3 = GetSubstruct3(boxMon);
            retVal = substruct3->hpIV
                    | (substruct3->attackIV << 5)
                    | (substruct3->defenseIV << 10)
                    | (substruct3->speedIV << 15)
                    | (substruct3->spAttackIV << 20)
                    | (substruct3->spDefenseIV << 25);
            break;
        }
        case MON_DATA_KNOWN_MOVES:
            if (GetSubstruct0(boxMon)->species && !IsEggOrBadEgg(boxMon))
            {
                struct PokemonSubstruct1 *substruct1 = GetSubstruct1(boxMon);
                u16 *moves = (u16 *)data;
                s32 i = 0;

                while (moves[i] != MOVES_COUNT)
                {
                    u16 move = moves[i];
                    if (substruct1->move1 == move
                        || substruct1->move2 == move
                        || substruct1->move3 == move
                        || substruct1->move4 == move)
                        retVal |= (1u << i);
                    i++;
                }
            }
            break;
        case MON_DATA_RIBBON_COUNT:
            if (GetSubstruct0(boxMon)->species && !IsEggOrBadEgg(boxMon))
            {
                struct PokemonSubstruct3 *substruct3 = GetSubstruct3(boxMon);
                retVal = 0;
                retVal += substruct3->coolRibbon;
                retVal += substruct3->beautyRibbon;
                retVal += substruct3->cuteRibbon;
                retVal += substruct3->smartRibbon;
                retVal += substruct3->toughRibbon;
                retVal += substruct3->championRibbon;
                retVal += substruct3->winningRibbon;
                retVal += substruct3->victoryRibbon;
                retVal += substruct3->artistRibbon;
                retVal += substruct3->effortRibbon;
                retVal += substruct3->marineRibbon;
                retVal += substruct3->landRibbon;
                retVal += substruct3->skyRibbon;
                retVal += substruct3->countryRibbon;
                retVal += substruct3->nationalRibbon;
                retVal += substruct3->earthRibbon;
                retVal += substruct3->worldRibbon;
            }
            break;
        case MON_DATA_RIBBONS:
            if (GetSubstruct0(boxMon)->species && !IsEggOrBadEgg(boxMon))
            {
                struct PokemonSubstruct3 *substruct3 = GetSubstruct3(boxMon);
                retVal = substruct3->championRibbon
                       | (substruct3->coolRibbon << 1)
                       | (substruct3->beautyRibbon << 4)
                       | (substruct3->cuteRibbon << 7)
                       | (substruct3->smartRibbon << 10)
                       | (substruct3->toughRibbon << 13)
                       | (substruct3->winningRibbon << 16)
                       | (substruct3->victoryRibbon << 17)
                       | (substruct3->artistRibbon << 18)
                       | (substruct3->effortRibbon << 19)
                       | (substruct3->marineRibbon << 20)
                       | (substruct3->landRibbon << 21)
                       | (substruct3->skyRibbon << 22)
                       | (substruct3->countryRibbon << 23)
                       | (substruct3->nationalRibbon << 24)
                       | (substruct3->earthRibbon << 25)
                       | (substruct3->worldRibbon << 26);
            }
            break;
        case MON_DATA_HYPER_TRAINED_HP:
            retVal = GetSubstruct1(boxMon)->hyperTrainedHP;
            break;
        case MON_DATA_HYPER_TRAINED_ATK:
            retVal = GetSubstruct1(boxMon)->hyperTrainedAttack;
            break;
        case MON_DATA_HYPER_TRAINED_DEF:
            retVal = GetSubstruct1(boxMon)->hyperTrainedDefense;
            break;
        case MON_DATA_HYPER_TRAINED_SPEED:
            retVal = GetSubstruct1(boxMon)->hyperTrainedSpeed;
            break;
        case MON_DATA_HYPER_TRAINED_SPATK:
            retVal = GetSubstruct1(boxMon)->hyperTrainedSpAttack;
            break;
        case MON_DATA_HYPER_TRAINED_SPDEF:
            retVal = GetSubstruct1(boxMon)->hyperTrainedSpDefense;
            break;
        case MON_DATA_IS_SHADOW:
            retVal = GetSubstruct3(boxMon)->isShadow;
            break;
        case MON_DATA_DYNAMAX_LEVEL:
            retVal = GetSubstruct3(boxMon)->dynamaxLevel;
            break;
        case MON_DATA_GIGANTAMAX_FACTOR:
            retVal = GetSubstruct3(boxMon)->gigantamaxFactor;
            break;
        case MON_DATA_TERA_TYPE:
            {
                struct PokemonSubstruct0 *substruct0 = GetSubstruct0(boxMon);
                if (gSpeciesInfo[substruct0->species].forceTeraType)
                {
                    retVal = gSpeciesInfo[substruct0->species].forceTeraType;
                }
                else if (substruct0->teraType == TYPE_NONE) // Tera Type hasn't been modified so we can just use the personality
                {
                    const u8 *types = gSpeciesInfo[substruct0->species].types;
                    retVal = (boxMon->personality & 0x1) == 0 ? types[0] : types[1];
                }
                else
                {
                    retVal = substruct0->teraType;
                }
            }
            break;
        case MON_DATA_EVOLUTION_TRACKER:
            {
                struct PokemonSubstruct1 *substruct1 = GetSubstruct1(boxMon);
                retVal = (union EvolutionTracker) {
                    .tracker1 = substruct1->evolutionTracker1,
                    .tracker2 = substruct1->evolutionTracker2,
                }.combinedValue;
            }
            break;
        default:
            break;
        }
    }
    else
    {
        switch (field)
        {
        case MON_DATA_STATUS:
            retVal = UncompressStatus(boxMon->compressedStatus);
            break;
        case MON_DATA_HP_LOST:
            retVal = boxMon->hpLost;
            break;
        case MON_DATA_PERSONALITY:
            retVal = boxMon->personality;
            break;
        case MON_DATA_OT_ID:
            retVal = boxMon->otId;
            break;
        case MON_DATA_LANGUAGE:
            retVal = boxMon->language;
            break;
        case MON_DATA_SANITY_IS_BAD_EGG:
            retVal = boxMon->isBadEgg;
            break;
        case MON_DATA_SANITY_HAS_SPECIES:
            retVal = boxMon->hasSpecies;
            break;
        case MON_DATA_SANITY_IS_EGG:
            retVal = boxMon->isEgg;
            break;
        case MON_DATA_OT_NAME:
        {
            retVal = 0;

            while (retVal < PLAYER_NAME_LENGTH)
            {
                data[retVal] = boxMon->otName[retVal];
                retVal++;
            }

            data[retVal] = EOS;
            break;
        }
        case MON_DATA_MARKINGS:
            retVal = boxMon->markings;
            break;
        case MON_DATA_CHECKSUM:
            retVal = boxMon->checksum;
            break;
        case MON_DATA_IS_SHINY:
        {
            u32 shinyValue = GET_SHINY_VALUE(boxMon->otId, boxMon->personality);
            retVal = (shinyValue < SHINY_ODDS) ^ boxMon->shinyModifier;
            break;
        }
        case MON_DATA_HIDDEN_NATURE:
        {
            u32 nature = GetNatureFromPersonality(boxMon->personality);
            retVal = nature ^ boxMon->hiddenNatureModifier;
            break;
        }
        case MON_DATA_DAYS_SINCE_FORM_CHANGE:
            retVal = boxMon->daysSinceFormChange;
            break;
        default:
            break;
        }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    if (field > MON_DATA_ENCRYPT_SEPARATOR)
        EncryptBoxMon(boxMon);

    return retVal;
}

<<<<<<< HEAD
u32 GetBoxMonData2(struct BoxPokemon *boxMon, s32 field) __attribute__((alias("GetBoxMonData3")));
=======
u32 GetBoxMonData2(struct BoxPokemon *boxMon, s32 field)
{
    return GetBoxMonData3(boxMon, field, NULL);
}
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

#define SET8(lhs) (lhs) = *data
#define SET16(lhs) (lhs) = data[0] + (data[1] << 8)
#define SET32(lhs) (lhs) = data[0] + (data[1] << 8) + (data[2] << 16) + (data[3] << 24)
<<<<<<< HEAD
=======
//
// Prefer SET_BY_WIDTH for fields whose types might be extended (e.g. 
// anything whose typedef is in gametypes.h).
//
#define SET_BY_WIDTH(lhs) \
    do { \
       if (sizeof(lhs) == 1) \
          SET8(lhs); \
       else if (sizeof(lhs) == 2) \
          SET16(lhs); \
       else if (sizeof(lhs) == 4) \
          SET32(lhs); \
   } while (0)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

void SetMonData(struct Pokemon *mon, s32 field, const void *dataArg)
{
    const u8 *data = dataArg;

    switch (field)
    {
    case MON_DATA_STATUS:
        SET32(mon->status);
<<<<<<< HEAD
=======
        SetBoxMonData(&mon->box, MON_DATA_STATUS, dataArg);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        break;
    case MON_DATA_LEVEL:
        SET8(mon->level);
        break;
    case MON_DATA_HP:
<<<<<<< HEAD
        SET16(mon->hp);
        break;
=======
    {
        u32 hpLost;
        SET16(mon->hp);
        hpLost = mon->maxHP - mon->hp;
        SetBoxMonData(&mon->box, MON_DATA_HP_LOST, &hpLost);
        break;
    }
    case MON_DATA_HP_LOST:
    {
        u32 hpLost;
        SET16(hpLost);
        mon->hp = mon->maxHP - hpLost;
        SetBoxMonData(&mon->box, MON_DATA_HP_LOST, &hpLost);
        break;
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    case MON_DATA_MAX_HP:
        SET16(mon->maxHP);
        break;
    case MON_DATA_ATK:
        SET16(mon->attack);
        break;
    case MON_DATA_DEF:
        SET16(mon->defense);
        break;
    case MON_DATA_SPEED:
        SET16(mon->speed);
        break;
    case MON_DATA_SPATK:
        SET16(mon->spAttack);
        break;
    case MON_DATA_SPDEF:
        SET16(mon->spDefense);
        break;
    case MON_DATA_MAIL:
        SET8(mon->mail);
        break;
    case MON_DATA_SPECIES_OR_EGG:
        break;
    default:
        SetBoxMonData(&mon->box, field, data);
        break;
    }
}

void SetBoxMonData(struct BoxPokemon *boxMon, s32 field, const void *dataArg)
{
    const u8 *data = dataArg;

<<<<<<< HEAD
    struct PokemonSubstruct0 *substruct0 = NULL;
    struct PokemonSubstruct1 *substruct1 = NULL;
    struct PokemonSubstruct2 *substruct2 = NULL;
    struct PokemonSubstruct3 *substruct3 = NULL;

    if (field > MON_DATA_ENCRYPT_SEPARATOR)
    {
        substruct0 = &(GetSubstruct(boxMon, boxMon->personality, 0)->type0);
        substruct1 = &(GetSubstruct(boxMon, boxMon->personality, 1)->type1);
        substruct2 = &(GetSubstruct(boxMon, boxMon->personality, 2)->type2);
        substruct3 = &(GetSubstruct(boxMon, boxMon->personality, 3)->type3);

        DecryptBoxMon(boxMon);

        if (CalculateBoxMonChecksum(boxMon) != boxMon->checksum)
        {
            boxMon->isBadEgg = TRUE;
            boxMon->isEgg = TRUE;
            substruct3->isEgg = TRUE;
            EncryptBoxMon(boxMon);
            return;
        }
    }

    switch (field)
    {
    case MON_DATA_PERSONALITY:
        SET32(boxMon->personality);
        break;
    case MON_DATA_OT_ID:
        SET32(boxMon->otId);
        break;
    case MON_DATA_NICKNAME:
    {
        s32 i;
        for (i = 0; i < POKEMON_NAME_LENGTH; i++)
            boxMon->nickname[i] = data[i];
        break;
    }
    case MON_DATA_LANGUAGE:
        SET8(boxMon->language);
        break;
    case MON_DATA_SANITY_IS_BAD_EGG:
        SET8(boxMon->isBadEgg);
        break;
    case MON_DATA_SANITY_HAS_SPECIES:
        SET8(boxMon->hasSpecies);
        break;
    case MON_DATA_SANITY_IS_EGG:
        SET8(boxMon->isEgg);
        break;
    case MON_DATA_IN_PC:
        SET8(boxMon->inPC);
        break;
    case MON_DATA_OT_NAME:
    {
        s32 i;
        for (i = 0; i < PLAYER_NAME_LENGTH; i++)
            boxMon->otName[i] = data[i];
        break;
    }
    case MON_DATA_MARKINGS:
        SET8(boxMon->markings);
        break;
    case MON_DATA_CHECKSUM:
        SET16(boxMon->checksum);
        break;
    case MON_DATA_ENCRYPT_SEPARATOR:
        SET16(boxMon->unknown);
        break;
    case MON_DATA_SPECIES:
    {
        SET16(substruct0->species);
        if (substruct0->species)
            boxMon->hasSpecies = TRUE;
        else
            boxMon->hasSpecies = FALSE;
        break;
    }
    case MON_DATA_HELD_ITEM:
        SET16(substruct0->heldItem);
        break;
    case MON_DATA_EXP:
        SET32(substruct0->experience);
        break;
    case MON_DATA_PP_BONUSES:
        SET8(substruct0->ppBonuses);
        break;
    case MON_DATA_FRIENDSHIP:
        SET8(substruct0->friendship);
        break;
    case MON_DATA_MOVE1:
    case MON_DATA_MOVE2:
    case MON_DATA_MOVE3:
    case MON_DATA_MOVE4:
        SET16(substruct1->moves[field - MON_DATA_MOVE1]);
        break;
    case MON_DATA_PP1:
    case MON_DATA_PP2:
    case MON_DATA_PP3:
    case MON_DATA_PP4:
        SET8(substruct1->pp[field - MON_DATA_PP1]);
        break;
    case MON_DATA_HP_EV:
        SET8(substruct2->hpEV);
        break;
    case MON_DATA_ATK_EV:
        SET8(substruct2->attackEV);
        break;
    case MON_DATA_DEF_EV:
        SET8(substruct2->defenseEV);
        break;
    case MON_DATA_SPEED_EV:
        SET8(substruct2->speedEV);
        break;
    case MON_DATA_SPATK_EV:
        SET8(substruct2->spAttackEV);
        break;
    case MON_DATA_SPDEF_EV:
        SET8(substruct2->spDefenseEV);
        break;
    case MON_DATA_COOL:
        SET8(substruct2->cool);
        break;
    case MON_DATA_BEAUTY:
        SET8(substruct2->beauty);
        break;
    case MON_DATA_CUTE:
        SET8(substruct2->cute);
        break;
    case MON_DATA_SMART:
        SET8(substruct2->smart);
        break;
    case MON_DATA_TOUGH:
        SET8(substruct2->tough);
        break;
    case MON_DATA_SHEEN:
        SET8(substruct2->sheen);
        break;
    case MON_DATA_POKERUS:
        SET8(substruct3->pokerus);
        break;
    case MON_DATA_MET_LOCATION:
        SET8(substruct3->metLocation);
        break;
    case MON_DATA_MET_LEVEL:
    {
        u8 metLevel = *data;
        substruct3->metLevel = metLevel;
        break;
    }
    case MON_DATA_MET_GAME:
        SET8(substruct3->metGame);
        break;
    case MON_DATA_POKEBALL:
    {
        u8 pokeball = *data;
        substruct3->pokeball = pokeball;
        break;
    }
    case MON_DATA_OT_GENDER:
        SET8(substruct3->otGender);
        break;
    case MON_DATA_HP_IV:
        SET8(substruct3->hpIV);
        break;
    case MON_DATA_ATK_IV:
        SET8(substruct3->attackIV);
        break;
    case MON_DATA_DEF_IV:
        SET8(substruct3->defenseIV);
        break;
    case MON_DATA_SPEED_IV:
        SET8(substruct3->speedIV);
        break;
    case MON_DATA_SPATK_IV:
        SET8(substruct3->spAttackIV);
        break;
    case MON_DATA_SPDEF_IV:
        SET8(substruct3->spDefenseIV);
        break;
    case MON_DATA_IS_EGG:
        SET8(substruct3->isEgg);
        if (substruct3->isEgg)
            boxMon->isEgg = TRUE;
        else
            boxMon->isEgg = FALSE;
        break;
    case MON_DATA_ABILITY_NUM:
        SET8(substruct3->abilityNum);
        break;
    case MON_DATA_COOL_RIBBON:
        SET8(substruct3->coolRibbon);
        break;
    case MON_DATA_BEAUTY_RIBBON:
        SET8(substruct3->beautyRibbon);
        break;
    case MON_DATA_CUTE_RIBBON:
        SET8(substruct3->cuteRibbon);
        break;
    case MON_DATA_SMART_RIBBON:
        SET8(substruct3->smartRibbon);
        break;
    case MON_DATA_TOUGH_RIBBON:
        SET8(substruct3->toughRibbon);
        break;
    case MON_DATA_CHAMPION_RIBBON:
        SET8(substruct3->championRibbon);
        break;
    case MON_DATA_WINNING_RIBBON:
        SET8(substruct3->winningRibbon);
        break;
    case MON_DATA_VICTORY_RIBBON:
        SET8(substruct3->victoryRibbon);
        break;
    case MON_DATA_ARTIST_RIBBON:
        SET8(substruct3->artistRibbon);
        break;
    case MON_DATA_EFFORT_RIBBON:
        SET8(substruct3->effortRibbon);
        break;
    case MON_DATA_MARINE_RIBBON:
        SET8(substruct3->marineRibbon);
        break;
    case MON_DATA_LAND_RIBBON:
        SET8(substruct3->landRibbon);
        break;
    case MON_DATA_SKY_RIBBON:
        SET8(substruct3->skyRibbon);
        break;
    case MON_DATA_COUNTRY_RIBBON:
        SET8(substruct3->countryRibbon);
        break;
    case MON_DATA_NATIONAL_RIBBON:
        SET8(substruct3->nationalRibbon);
        break;
    case MON_DATA_EARTH_RIBBON:
        SET8(substruct3->earthRibbon);
        break;
    case MON_DATA_WORLD_RIBBON:
        SET8(substruct3->worldRibbon);
        break;
    case MON_DATA_UNUSED_RIBBONS:
        SET8(substruct3->unusedRibbons);
        break;
    case MON_DATA_NUZLOCKE_RIBBON:
        SET8(substruct3->nuzlockeRibbon);
        break;
    case MON_DATA_MODERN_FATEFUL_ENCOUNTER:
        SET8(substruct3->modernFatefulEncounter);
        break;
    case MON_DATA_IVS:
    {
        u32 ivs = data[0] | (data[1] << 8) | (data[2] << 16) | (data[3] << 24);
        substruct3->hpIV = ivs & MAX_IV_MASK;
        substruct3->attackIV = (ivs >> 5) & MAX_IV_MASK;
        substruct3->defenseIV = (ivs >> 10) & MAX_IV_MASK;
        substruct3->speedIV = (ivs >> 15) & MAX_IV_MASK;
        substruct3->spAttackIV = (ivs >> 20) & MAX_IV_MASK;
        substruct3->spDefenseIV = (ivs >> 25) & MAX_IV_MASK;
        break;
    }
    case MON_DATA_HIDDEN_NATURE:
        SET8(substruct0->hiddenNature);
        break;
    case MON_DATA_BOX_HP:
        SET8(substruct0->box_hp);
        break;
    case MON_DATA_BOX_AILMENT:
        SET8(substruct0->box_ailment);
        break;
    default:
        break;
    }

    if (field > MON_DATA_ENCRYPT_SEPARATOR)
    {
        boxMon->checksum = CalculateBoxMonChecksum(boxMon);
        EncryptBoxMon(boxMon);
    }
=======
    if (field > MON_DATA_ENCRYPT_SEPARATOR)
    {
        if (CalculateBoxMonChecksumDecrypt(boxMon) != boxMon->checksum)
        {
            boxMon->isBadEgg = TRUE;
            boxMon->isEgg = TRUE;
            GetSubstruct3(boxMon)->isEgg = TRUE;
            EncryptBoxMon(boxMon);
            return;
        }

        switch (field)
        {
        case MON_DATA_NICKNAME:
        case MON_DATA_NICKNAME10:
        {
            s32 i;
            struct PokemonSubstruct0 *substruct0 = GetSubstruct0(boxMon);
            for (i = 0; i < min(sizeof(boxMon->nickname), POKEMON_NAME_LENGTH); i++)
                boxMon->nickname[i] = data[i];
            if (field != MON_DATA_NICKNAME10)
            {
                if (POKEMON_NAME_LENGTH >= 11)
                    substruct0->nickname11 = data[10];
                if (POKEMON_NAME_LENGTH >= 12)
                    substruct0->nickname12 = data[11];
            }
            else
            {
                substruct0->nickname11 = EOS;
                substruct0->nickname12 = EOS;
            }
            break;
        }
        case MON_DATA_SPECIES:
        {
            struct PokemonSubstruct0 *substruct0 = GetSubstruct0(boxMon);
            SET16(substruct0->species);
            if (substruct0->species)
                boxMon->hasSpecies = TRUE;
            else
                boxMon->hasSpecies = FALSE;
            break;
        }
        case MON_DATA_HELD_ITEM:
            SET16(GetSubstruct0(boxMon)->heldItem);
            break;
        case MON_DATA_EXP:
            SET32(GetSubstruct0(boxMon)->experience);
            break;
        case MON_DATA_PP_BONUSES:
            SET8(GetSubstruct0(boxMon)->ppBonuses);
            break;
        case MON_DATA_FRIENDSHIP:
            SET8(GetSubstruct0(boxMon)->friendship);
            break;
        case MON_DATA_MOVE1:
            SET16(GetSubstruct1(boxMon)->move1);
            break;
        case MON_DATA_MOVE2:
            SET16(GetSubstruct1(boxMon)->move2);
            break;
        case MON_DATA_MOVE3:
            SET16(GetSubstruct1(boxMon)->move3);
            break;
        case MON_DATA_MOVE4:
            SET16(GetSubstruct1(boxMon)->move4);
            break;
        case MON_DATA_PP1:
            SET8(GetSubstruct1(boxMon)->pp1);
            break;
        case MON_DATA_PP2:
            SET8(GetSubstruct1(boxMon)->pp2);
            break;
        case MON_DATA_PP3:
            SET8(GetSubstruct1(boxMon)->pp3);
            break;
        case MON_DATA_PP4:
            SET8(GetSubstruct1(boxMon)->pp4);
            break;
        case MON_DATA_HP_EV:
            SET8(GetSubstruct2(boxMon)->hpEV);
            break;
        case MON_DATA_ATK_EV:
            SET8(GetSubstruct2(boxMon)->attackEV);
            break;
        case MON_DATA_DEF_EV:
            SET8(GetSubstruct2(boxMon)->defenseEV);
            break;
        case MON_DATA_SPEED_EV:
            SET8(GetSubstruct2(boxMon)->speedEV);
            break;
        case MON_DATA_SPATK_EV:
            SET8(GetSubstruct2(boxMon)->spAttackEV);
            break;
        case MON_DATA_SPDEF_EV:
            SET8(GetSubstruct2(boxMon)->spDefenseEV);
            break;
        case MON_DATA_COOL:
            SET8(GetSubstruct2(boxMon)->cool);
            break;
        case MON_DATA_BEAUTY:
            SET8(GetSubstruct2(boxMon)->beauty);
            break;
        case MON_DATA_CUTE:
            SET8(GetSubstruct2(boxMon)->cute);
            break;
        case MON_DATA_SMART:
            SET8(GetSubstruct2(boxMon)->smart);
            break;
        case MON_DATA_TOUGH:
            SET8(GetSubstruct2(boxMon)->tough);
            break;
        case MON_DATA_SHEEN:
            SET8(GetSubstruct2(boxMon)->sheen);
            break;
        case MON_DATA_POKERUS:
            SET8(GetSubstruct3(boxMon)->pokerus);
            break;
        case MON_DATA_MET_LOCATION:
            SET8(GetSubstruct3(boxMon)->metLocation);
            break;
        case MON_DATA_MET_LEVEL:
            SET8(GetSubstruct3(boxMon)->metLevel);
            break;
        case MON_DATA_MET_GAME:
            SET8(GetSubstruct3(boxMon)->metGame);
            break;
        case MON_DATA_POKEBALL:
            SET8(GetSubstruct0(boxMon)->pokeball);
            break;
        case MON_DATA_OT_GENDER:
            SET8(GetSubstruct3(boxMon)->otGender);
            break;
        case MON_DATA_HP_IV:
            SET8(GetSubstruct3(boxMon)->hpIV);
            break;
        case MON_DATA_ATK_IV:
            SET8(GetSubstruct3(boxMon)->attackIV);
            break;
        case MON_DATA_DEF_IV:
            SET8(GetSubstruct3(boxMon)->defenseIV);
            break;
        case MON_DATA_SPEED_IV:
            SET8(GetSubstruct3(boxMon)->speedIV);
            break;
        case MON_DATA_SPATK_IV:
            SET8(GetSubstruct3(boxMon)->spAttackIV);
            break;
        case MON_DATA_SPDEF_IV:
            SET8(GetSubstruct3(boxMon)->spDefenseIV);
            break;
        case MON_DATA_IS_EGG:
            SET8(GetSubstruct3(boxMon)->isEgg);
            SET8(boxMon->isEgg);
            break;
        case MON_DATA_ABILITY_NUM:
            SET8(GetSubstruct3(boxMon)->abilityNum);
            break;
        case MON_DATA_COOL_RIBBON:
            SET8(GetSubstruct3(boxMon)->coolRibbon);
            break;
        case MON_DATA_BEAUTY_RIBBON:
            SET8(GetSubstruct3(boxMon)->beautyRibbon);
            break;
        case MON_DATA_CUTE_RIBBON:
            SET8(GetSubstruct3(boxMon)->cuteRibbon);
            break;
        case MON_DATA_SMART_RIBBON:
            SET8(GetSubstruct3(boxMon)->smartRibbon);
            break;
        case MON_DATA_TOUGH_RIBBON:
            SET8(GetSubstruct3(boxMon)->toughRibbon);
            break;
        case MON_DATA_CHAMPION_RIBBON:
            SET8(GetSubstruct3(boxMon)->championRibbon);
            break;
        case MON_DATA_WINNING_RIBBON:
            SET8(GetSubstruct3(boxMon)->winningRibbon);
            break;
        case MON_DATA_VICTORY_RIBBON:
            SET8(GetSubstruct3(boxMon)->victoryRibbon);
            break;
        case MON_DATA_ARTIST_RIBBON:
            SET8(GetSubstruct3(boxMon)->artistRibbon);
            break;
        case MON_DATA_EFFORT_RIBBON:
            SET8(GetSubstruct3(boxMon)->effortRibbon);
            break;
        case MON_DATA_MARINE_RIBBON:
            SET8(GetSubstruct3(boxMon)->marineRibbon);
            break;
        case MON_DATA_LAND_RIBBON:
            SET8(GetSubstruct3(boxMon)->landRibbon);
            break;
        case MON_DATA_SKY_RIBBON:
            SET8(GetSubstruct3(boxMon)->skyRibbon);
            break;
        case MON_DATA_COUNTRY_RIBBON:
            SET8(GetSubstruct3(boxMon)->countryRibbon);
            break;
        case MON_DATA_NATIONAL_RIBBON:
            SET8(GetSubstruct3(boxMon)->nationalRibbon);
            break;
        case MON_DATA_EARTH_RIBBON:
            SET8(GetSubstruct3(boxMon)->earthRibbon);
            break;
        case MON_DATA_WORLD_RIBBON:
            SET8(GetSubstruct3(boxMon)->worldRibbon);
            break;
        case MON_DATA_MODERN_FATEFUL_ENCOUNTER:
            SET8(GetSubstruct3(boxMon)->modernFatefulEncounter);
            break;
        case MON_DATA_IVS:
        {
            u32 ivs;
            struct PokemonSubstruct3 *substruct3 = GetSubstruct3(boxMon);
            SET32(ivs);
            substruct3->hpIV = ivs & MAX_IV_MASK;
            substruct3->attackIV = (ivs >> 5) & MAX_IV_MASK;
            substruct3->defenseIV = (ivs >> 10) & MAX_IV_MASK;
            substruct3->speedIV = (ivs >> 15) & MAX_IV_MASK;
            substruct3->spAttackIV = (ivs >> 20) & MAX_IV_MASK;
            substruct3->spDefenseIV = (ivs >> 25) & MAX_IV_MASK;
            break;
        }
        case MON_DATA_HYPER_TRAINED_HP:
            SET8(GetSubstruct1(boxMon)->hyperTrainedHP);
            break;
        case MON_DATA_HYPER_TRAINED_ATK:
            SET8(GetSubstruct1(boxMon)->hyperTrainedAttack);
            break;
        case MON_DATA_HYPER_TRAINED_DEF:
            SET8(GetSubstruct1(boxMon)->hyperTrainedDefense);
            break;
        case MON_DATA_HYPER_TRAINED_SPEED:
            SET8(GetSubstruct1(boxMon)->hyperTrainedSpeed);
            break;
        case MON_DATA_HYPER_TRAINED_SPATK:
            SET8(GetSubstruct1(boxMon)->hyperTrainedSpAttack);
            break;
        case MON_DATA_HYPER_TRAINED_SPDEF:
            SET8(GetSubstruct1(boxMon)->hyperTrainedSpDefense);
            break;
        case MON_DATA_IS_SHADOW:
            SET8(GetSubstruct3(boxMon)->isShadow);
            break;
        case MON_DATA_DYNAMAX_LEVEL:
            SET8(GetSubstruct3(boxMon)->dynamaxLevel);
            break;
        case MON_DATA_GIGANTAMAX_FACTOR:
            SET8(GetSubstruct3(boxMon)->gigantamaxFactor);
            break;
        case MON_DATA_TERA_TYPE:
            SET8(GetSubstruct0(boxMon)->teraType);
            break;
        case MON_DATA_EVOLUTION_TRACKER:
        {
            union EvolutionTracker evoTracker;
            struct PokemonSubstruct1 *substruct1 = GetSubstruct1(boxMon);
            SET32(evoTracker.combinedValue);
            substruct1->evolutionTracker1 = evoTracker.tracker1;
            substruct1->evolutionTracker2 = evoTracker.tracker2;
            break;
        }
        default:
            break;
        }
    }
    else
    {
        switch (field)
        {
        case MON_DATA_STATUS:
        {
            u32 status;
            SET32(status);
            boxMon->compressedStatus = CompressStatus(status);
            break;
        }
        case MON_DATA_HP_LOST:
            SET16(boxMon->hpLost);
            break;
        case MON_DATA_PERSONALITY:
            SET32(boxMon->personality);
            break;
        case MON_DATA_OT_ID:
            SET32(boxMon->otId);
            break;
        case MON_DATA_LANGUAGE:
            SET8(boxMon->language);
            break;
        case MON_DATA_SANITY_IS_BAD_EGG:
            SET8(boxMon->isBadEgg);
            break;
        case MON_DATA_SANITY_HAS_SPECIES:
            SET8(boxMon->hasSpecies);
            break;
        case MON_DATA_SANITY_IS_EGG:
            SET8(boxMon->isEgg);
            break;
        case MON_DATA_OT_NAME:
        {
            s32 i;
            for (i = 0; i < PLAYER_NAME_LENGTH; i++)
                boxMon->otName[i] = data[i];
            break;
        }
        case MON_DATA_MARKINGS:
            SET8(boxMon->markings);
            break;
        case MON_DATA_CHECKSUM:
            SET16(boxMon->checksum);
            break;
        case MON_DATA_IS_SHINY:
        {
            u32 shinyValue = GET_SHINY_VALUE(boxMon->otId, boxMon->personality);
            bool32 isShiny;
            SET8(isShiny);
            boxMon->shinyModifier = (shinyValue < SHINY_ODDS) ^ isShiny;
            break;
        }
        case MON_DATA_HIDDEN_NATURE:
        {
            u32 nature = GetNatureFromPersonality(boxMon->personality);
            u32 hiddenNature;
            SET8(hiddenNature);
            boxMon->hiddenNatureModifier = nature ^ hiddenNature;
            break;
        }
        case MON_DATA_DAYS_SINCE_FORM_CHANGE:
            SET8(boxMon->daysSinceFormChange);
            break;
        }
    }

    if (field > MON_DATA_ENCRYPT_SEPARATOR)
        boxMon->checksum = CalculateBoxMonChecksumReencrypt(boxMon);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void CopyMon(void *dest, void *src, size_t size)
{
    memcpy(dest, src, size);
}

u8 GiveMonToPlayer(struct Pokemon *mon)
{
    s32 i;
<<<<<<< HEAD
    u8 typeChallenge = gSaveBlock1Ptr->tx_Challenges_OneTypeChallenge;
=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    SetMonData(mon, MON_DATA_OT_NAME, gSaveBlock2Ptr->playerName);
    SetMonData(mon, MON_DATA_OT_GENDER, &gSaveBlock2Ptr->playerGender);
    SetMonData(mon, MON_DATA_OT_ID, gSaveBlock2Ptr->playerTrainerId);

<<<<<<< HEAD
    for (i = 0; i < GetMaxPartySize(); i++) //tx_randomizer_and_challenges
=======
    for (i = 0; i < PARTY_SIZE; i++)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        if (GetMonData(&gPlayerParty[i], MON_DATA_SPECIES, NULL) == SPECIES_NONE)
            break;
    }

<<<<<<< HEAD
    if (i >= GetMaxPartySize()) //tx_randomizer_and_challenges
        return CopyMonToPC(mon);

    if (typeChallenge != TX_CHALLENGE_TYPE_OFF && 
                    GetTypeBySpecies(GetMonData(mon, MON_DATA_SPECIES, NULL), 1) != typeChallenge && 
                    GetTypeBySpecies(GetMonData(mon, MON_DATA_SPECIES, NULL), 2) != typeChallenge)
=======
    if (i >= PARTY_SIZE)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        return CopyMonToPC(mon);

    CopyMon(&gPlayerParty[i], mon, sizeof(*mon));
    gPlayerPartyCount = i + 1;
    return MON_GIVEN_TO_PARTY;
}

u8 CopyMonToPC(struct Pokemon *mon)
{
    s32 boxNo, boxPos;

    SetPCBoxToSendMon(VarGet(VAR_PC_BOX_TO_SEND_MON));

    boxNo = StorageGetCurrentBox();

    do
    {
        for (boxPos = 0; boxPos < IN_BOX_COUNT; boxPos++)
        {
<<<<<<< HEAD
            struct BoxPokemon* checkingMon = GetBoxedMonPtr(boxNo, boxPos);
=======
            struct BoxPokemon *checkingMon = GetBoxedMonPtr(boxNo, boxPos);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            if (GetBoxMonData(checkingMon, MON_DATA_SPECIES, NULL) == SPECIES_NONE)
            {
                MonRestorePP(mon);
                CopyMon(checkingMon, &mon->box, sizeof(mon->box));
                gSpecialVar_MonBoxId = boxNo;
                gSpecialVar_MonBoxPos = boxPos;
                if (GetPCBoxToSendMon() != boxNo)
                    FlagClear(FLAG_SHOWN_BOX_WAS_FULL_MESSAGE);
                VarSet(VAR_PC_BOX_TO_SEND_MON, boxNo);
                return MON_GIVEN_TO_PC;
            }
        }

        boxNo++;
        if (boxNo == TOTAL_BOXES_COUNT)
            boxNo = 0;
    } while (boxNo != StorageGetCurrentBox());

    return MON_CANT_GIVE;
}

<<<<<<< HEAD
u8 CalculatePlayerPartyCount(void)
{
    gPlayerPartyCount = 0;

    while (gPlayerPartyCount < GetMaxPartySize() //tx_randomizer_and_challenges
        && GetMonData(&gPlayerParty[gPlayerPartyCount], MON_DATA_SPECIES, NULL) != SPECIES_NONE)
    {
        gPlayerPartyCount++;
    }

=======
u8 CalculatePartyCount(struct Pokemon *party)
{
    u32 partyCount = 0;

    while (partyCount < PARTY_SIZE
        && GetMonData(&party[partyCount], MON_DATA_SPECIES, NULL) != SPECIES_NONE)
    {
        partyCount++;
    }

    return partyCount;
}

u8 CalculatePartyCountOfSide(u32 battler, struct Pokemon *party)
{
    s32 partyCount, partySize;
    GetAIPartyIndexes(battler, &partyCount, &partySize);

    while (partyCount < partySize
        && GetMonData(&party[partyCount], MON_DATA_SPECIES, NULL) != SPECIES_NONE)
    {
        partyCount++;
    }

    return partyCount;
}

u8 CalculatePlayerPartyCount(void)
{
    gPlayerPartyCount = CalculatePartyCount(gPlayerParty);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    return gPlayerPartyCount;
}

u8 CalculateEnemyPartyCount(void)
{
<<<<<<< HEAD
    gEnemyPartyCount = 0;

    while (gEnemyPartyCount < PARTY_SIZE
        && GetMonData(&gEnemyParty[gEnemyPartyCount], MON_DATA_SPECIES, NULL) != SPECIES_NONE)
    {
        gEnemyPartyCount++;
    }

    return gEnemyPartyCount;
}

=======
    gEnemyPartyCount = CalculatePartyCount(gEnemyParty);
    return gEnemyPartyCount;
}

u8 CalculateEnemyPartyCountInSide(u32 battler)
{
    return CalculatePartyCountOfSide(battler, gEnemyParty);
}

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
u8 GetMonsStateToDoubles(void)
{
    s32 aliveCount = 0;
    s32 i;
    CalculatePlayerPartyCount();

<<<<<<< HEAD
=======
    if (OW_DOUBLE_APPROACH_WITH_ONE_MON)
        return PLAYER_HAS_TWO_USABLE_MONS;

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    if (gPlayerPartyCount == 1)
        return gPlayerPartyCount; // PLAYER_HAS_ONE_MON

    for (i = 0; i < gPlayerPartyCount; i++)
    {
        if (GetMonData(&gPlayerParty[i], MON_DATA_SPECIES_OR_EGG, NULL) != SPECIES_EGG
         && GetMonData(&gPlayerParty[i], MON_DATA_HP, NULL) != 0
         && GetMonData(&gPlayerParty[i], MON_DATA_SPECIES_OR_EGG, NULL) != SPECIES_NONE)
            aliveCount++;
    }

    return (aliveCount > 1) ? PLAYER_HAS_TWO_USABLE_MONS : PLAYER_HAS_ONE_USABLE_MON;
}

u8 GetMonsStateToDoubles_2(void)
{
    s32 aliveCount = 0;
    s32 i;

<<<<<<< HEAD
=======
    if (OW_DOUBLE_APPROACH_WITH_ONE_MON
     || FollowerNPCIsBattlePartner())
        return PLAYER_HAS_TWO_USABLE_MONS;

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    for (i = 0; i < PARTY_SIZE; i++)
    {
        u32 species = GetMonData(&gPlayerParty[i], MON_DATA_SPECIES_OR_EGG, NULL);
        if (species != SPECIES_EGG && species != SPECIES_NONE
         && GetMonData(&gPlayerParty[i], MON_DATA_HP, NULL) != 0)
            aliveCount++;
    }

    if (aliveCount == 1)
        return PLAYER_HAS_ONE_MON; // may have more than one, but only one is alive

    return (aliveCount > 1) ? PLAYER_HAS_TWO_USABLE_MONS : PLAYER_HAS_ONE_USABLE_MON;
}

<<<<<<< HEAD
u8 GetAbilityBySpecies(u16 species, u8 abilityNum)
{
    if (gSaveBlock1Ptr->tx_Random_Abilities) //tx_randomizer_and_challenges
    {
        species = GetSpeciesRandomSeeded(species, TX_RANDOM_T_ABILITY, 0);
        if (gSpeciesInfo[species].abilities[1] == ABILITY_NONE)
            abilityNum = 0;
        else
            abilityNum = 1;
    }
    if ((abilityNum == 0) && (species == SPECIES_ARTICUNO 
            || species == SPECIES_ZAPDOS 
            || species == SPECIES_MOLTRES
            || species == SPECIES_MEWTWO
            || species == SPECIES_RAICHU
            || species == SPECIES_ENTEI
            || species == SPECIES_SUICUNE
            || species == SPECIES_HO_OH
            || species == SPECIES_LUGIA)
            && (gSaveBlock1Ptr->tx_Mode_Legendary_Abilities == 0))
        gLastUsedAbility = gSpeciesInfo[species].abilities_old[0];
    else if ((abilityNum == 1) && (species == SPECIES_NOCTOWL) && (gSaveBlock1Ptr->tx_Mode_Modern_Types == 0))
        gLastUsedAbility = gSpeciesInfo[species].abilities_old[1];
    else if (abilityNum)
        gLastUsedAbility = gSpeciesInfo[species].abilities[1];
    else
        gLastUsedAbility = gSpeciesInfo[species].abilities[0];
=======
u16 GetAbilityBySpecies(u16 species, u8 abilityNum)
{
    int i;

    if (abilityNum < NUM_ABILITY_SLOTS)
        gLastUsedAbility = GetSpeciesAbility(species, abilityNum);
    else
        gLastUsedAbility = ABILITY_NONE;

    if (abilityNum >= NUM_NORMAL_ABILITY_SLOTS) // if abilityNum is empty hidden ability, look for other hidden abilities
    {
        for (i = NUM_NORMAL_ABILITY_SLOTS; i < NUM_ABILITY_SLOTS && gLastUsedAbility == ABILITY_NONE; i++)
        {
            gLastUsedAbility = GetSpeciesAbility(species, i);
        }
    }

    for (i = 0; i < NUM_ABILITY_SLOTS && gLastUsedAbility == ABILITY_NONE; i++) // look for any non-empty ability
    {
        gLastUsedAbility = GetSpeciesAbility(species, i);
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    return gLastUsedAbility;
}

<<<<<<< HEAD
u8 GetMonAbility(struct Pokemon *mon)
=======
u16 GetMonAbility(struct Pokemon *mon)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    u8 abilityNum = GetMonData(mon, MON_DATA_ABILITY_NUM, NULL);
    return GetAbilityBySpecies(species, abilityNum);
}

void CreateSecretBaseEnemyParty(struct SecretBase *secretBaseRecord)
{
    s32 i, j;

    ZeroEnemyPartyMons();
    *gBattleResources->secretBase = *secretBaseRecord;

    for (i = 0; i < PARTY_SIZE; i++)
    {
        if (gBattleResources->secretBase->party.species[i])
        {
            CreateMon(&gEnemyParty[i],
                gBattleResources->secretBase->party.species[i],
                gBattleResources->secretBase->party.levels[i],
                15,
                TRUE,
                gBattleResources->secretBase->party.personality[i],
                OT_ID_RANDOM_NO_SHINY,
                0);

            SetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, &gBattleResources->secretBase->party.heldItems[i]);

            for (j = 0; j < NUM_STATS; j++)
                SetMonData(&gEnemyParty[i], MON_DATA_HP_EV + j, &gBattleResources->secretBase->party.EVs[i]);

            for (j = 0; j < MAX_MON_MOVES; j++)
            {
                SetMonData(&gEnemyParty[i], MON_DATA_MOVE1 + j, &gBattleResources->secretBase->party.moves[i * MAX_MON_MOVES + j]);
<<<<<<< HEAD
                SetMonData(&gEnemyParty[i], MON_DATA_PP1 + j, &gBattleMoves[gBattleResources->secretBase->party.moves[i * MAX_MON_MOVES + j]].pp);
=======
                u32 pp = GetMovePP(gBattleResources->secretBase->party.moves[i * MAX_MON_MOVES + j]);
                SetMonData(&gEnemyParty[i], MON_DATA_PP1 + j, &pp);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            }
        }
    }
}

u8 GetSecretBaseTrainerPicIndex(void)
{
    u8 facilityClass = sSecretBaseFacilityClasses[gBattleResources->secretBase->gender][gBattleResources->secretBase->trainerId[0] % NUM_SECRET_BASE_CLASSES];
    return gFacilityClassToPicIndex[facilityClass];
}

<<<<<<< HEAD
u8 GetSecretBaseTrainerClass(void)
=======
enum TrainerClassID GetSecretBaseTrainerClass(void)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u8 facilityClass = sSecretBaseFacilityClasses[gBattleResources->secretBase->gender][gBattleResources->secretBase->trainerId[0] % NUM_SECRET_BASE_CLASSES];
    return gFacilityClassToTrainerClass[facilityClass];
}

bool8 IsPlayerPartyAndPokemonStorageFull(void)
{
    s32 i;

<<<<<<< HEAD
    for (i = 0; i < GetMaxPartySize(); i++)
=======
    for (i = 0; i < PARTY_SIZE; i++)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        if (GetMonData(&gPlayerParty[i], MON_DATA_SPECIES, NULL) == SPECIES_NONE)
            return FALSE;

    return IsPokemonStorageFull();
}

bool8 IsPokemonStorageFull(void)
{
    s32 i, j;

    for (i = 0; i < TOTAL_BOXES_COUNT; i++)
        for (j = 0; j < IN_BOX_COUNT; j++)
            if (GetBoxMonDataAt(i, j, MON_DATA_SPECIES) == SPECIES_NONE)
                return FALSE;

    return TRUE;
}

<<<<<<< HEAD
void GetSpeciesName(u8 *name, u16 species)
{
    s32 i;

    for (i = 0; i <= POKEMON_NAME_LENGTH; i++)
    {
        if (species > NUM_SPECIES)
            name[i] = gSpeciesNames[SPECIES_NONE][i];
        else
            name[i] = gSpeciesNames[species][i];

        if (name[i] == EOS)
            break;
    }

    name[i] = EOS;
=======
const u8 *GetSpeciesName(u16 species)
{
    species = SanitizeSpeciesId(species);
    if (gSpeciesInfo[species].speciesName[0] == 0)
        return gSpeciesInfo[SPECIES_NONE].speciesName;
    return gSpeciesInfo[species].speciesName;
}

const u8 *GetSpeciesCategory(u16 species)
{
    species = SanitizeSpeciesId(species);
    if (gSpeciesInfo[species].categoryName[0] == 0)
        return gSpeciesInfo[SPECIES_NONE].categoryName;
    return gSpeciesInfo[species].categoryName;
}

const u8 *GetSpeciesPokedexDescription(u16 species)
{
    species = SanitizeSpeciesId(species);
    if (gSpeciesInfo[species].description == NULL)
        return gSpeciesInfo[SPECIES_NONE].description;
    return gSpeciesInfo[species].description;
}

u32 GetSpeciesHeight(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].height;
}

u32 GetSpeciesWeight(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].weight;
}

u32 GetSpeciesType(u16 species, u8 slot)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].types[slot];
}

u32 GetSpeciesAbility(u16 species, u8 slot)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].abilities[slot];
}

u32 GetSpeciesBaseHP(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].baseHP;
}

u32 GetSpeciesBaseAttack(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].baseAttack;
}

u32 GetSpeciesBaseDefense(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].baseDefense;
}

u32 GetSpeciesBaseSpAttack(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].baseSpAttack;
}

u32 GetSpeciesBaseSpDefense(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].baseSpDefense;
}

u32 GetSpeciesBaseSpeed(u16 species)
{
    return gSpeciesInfo[SanitizeSpeciesId(species)].baseSpeed;
}

u32 GetSpeciesBaseStat(u16 species, u32 statIndex)
{
    switch (statIndex)
    {
    case STAT_HP:
        return GetSpeciesBaseHP(species);
    case STAT_ATK:
        return GetSpeciesBaseAttack(species);
    case STAT_DEF:
        return GetSpeciesBaseDefense(species);
    case STAT_SPEED:
        return GetSpeciesBaseSpeed(species);
    case STAT_SPATK:
        return GetSpeciesBaseSpAttack(species);
    case STAT_SPDEF:
        return GetSpeciesBaseSpDefense(species);
    }
    return 0;
}

const struct LevelUpMove *GetSpeciesLevelUpLearnset(u16 species)
{
    const struct LevelUpMove *learnset = gSpeciesInfo[SanitizeSpeciesId(species)].levelUpLearnset;
    if (learnset == NULL)
        return gSpeciesInfo[SPECIES_NONE].levelUpLearnset;
    return learnset;
}

const u16 *GetSpeciesTeachableLearnset(u16 species)
{
    const u16 *learnset = gSpeciesInfo[SanitizeSpeciesId(species)].teachableLearnset;
    if (learnset == NULL)
        return gSpeciesInfo[SPECIES_NONE].teachableLearnset;
    return learnset;
}

const u16 *GetSpeciesEggMoves(u16 species)
{
    const u16 *learnset = gSpeciesInfo[SanitizeSpeciesId(species)].eggMoveLearnset;
    if (learnset == NULL)
        return gSpeciesInfo[SPECIES_NONE].eggMoveLearnset;
    return learnset;
}

const struct Evolution *GetSpeciesEvolutions(u16 species)
{
    const struct Evolution *evolutions = gSpeciesInfo[SanitizeSpeciesId(species)].evolutions;
    if (evolutions == NULL)
        return gSpeciesInfo[SPECIES_NONE].evolutions;
    return evolutions;
}

const u16 *GetSpeciesFormTable(u16 species)
{
    const u16 *formTable = gSpeciesInfo[SanitizeSpeciesId(species)].formSpeciesIdTable;
    if (formTable == NULL)
        return gSpeciesInfo[SPECIES_NONE].formSpeciesIdTable;
    return formTable;
}

const struct FormChange *GetSpeciesFormChanges(u16 species)
{
    const struct FormChange *formChanges = gSpeciesInfo[SanitizeSpeciesId(species)].formChangeTable;
    if (formChanges == NULL)
        return gSpeciesInfo[SPECIES_NONE].formChangeTable;
    return formChanges;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

u8 CalculatePPWithBonus(u16 move, u8 ppBonuses, u8 moveIndex)
{
<<<<<<< HEAD
    u8 basePP = gBattleMoves[move].pp;
=======
    u8 basePP = GetMovePP(move);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    return basePP + ((basePP * 20 * ((gPPUpGetMask[moveIndex] & ppBonuses) >> (2 * moveIndex))) / 100);
}

void RemoveMonPPBonus(struct Pokemon *mon, u8 moveIndex)
{
    u8 ppBonuses = GetMonData(mon, MON_DATA_PP_BONUSES, NULL);
    ppBonuses &= gPPUpClearMask[moveIndex];
    SetMonData(mon, MON_DATA_PP_BONUSES, &ppBonuses);
}

void RemoveBattleMonPPBonus(struct BattlePokemon *mon, u8 moveIndex)
{
    mon->ppBonuses &= gPPUpClearMask[moveIndex];
}

<<<<<<< HEAD
void CopyPlayerPartyMonToBattleData(u8 battlerId, u8 partyIndex)
{
    u16 *hpSwitchout;
    s32 i;
    u8 nickname[POKEMON_NAME_BUFFER_SIZE];

    gBattleMons[battlerId].species = GetMonData(&gPlayerParty[partyIndex], MON_DATA_SPECIES, NULL);
    gBattleMons[battlerId].item = GetMonData(&gPlayerParty[partyIndex], MON_DATA_HELD_ITEM, NULL);

    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        gBattleMons[battlerId].moves[i] = GetMonData(&gPlayerParty[partyIndex], MON_DATA_MOVE1 + i, NULL);
        gBattleMons[battlerId].pp[i] = GetMonData(&gPlayerParty[partyIndex], MON_DATA_PP1 + i, NULL);
    }

    gBattleMons[battlerId].ppBonuses = GetMonData(&gPlayerParty[partyIndex], MON_DATA_PP_BONUSES, NULL);
    gBattleMons[battlerId].friendship = GetMonData(&gPlayerParty[partyIndex], MON_DATA_FRIENDSHIP, NULL);
    gBattleMons[battlerId].experience = GetMonData(&gPlayerParty[partyIndex], MON_DATA_EXP, NULL);
    gBattleMons[battlerId].hpIV = GetMonData(&gPlayerParty[partyIndex], MON_DATA_HP_IV, NULL);
    gBattleMons[battlerId].attackIV = GetMonData(&gPlayerParty[partyIndex], MON_DATA_ATK_IV, NULL);
    gBattleMons[battlerId].defenseIV = GetMonData(&gPlayerParty[partyIndex], MON_DATA_DEF_IV, NULL);
    gBattleMons[battlerId].speedIV = GetMonData(&gPlayerParty[partyIndex], MON_DATA_SPEED_IV, NULL);
    gBattleMons[battlerId].spAttackIV = GetMonData(&gPlayerParty[partyIndex], MON_DATA_SPATK_IV, NULL);
    gBattleMons[battlerId].spDefenseIV = GetMonData(&gPlayerParty[partyIndex], MON_DATA_SPDEF_IV, NULL);
    gBattleMons[battlerId].personality = GetMonData(&gPlayerParty[partyIndex], MON_DATA_PERSONALITY, NULL);
    gBattleMons[battlerId].status1 = GetMonData(&gPlayerParty[partyIndex], MON_DATA_STATUS, NULL);
    gBattleMons[battlerId].level = GetMonData(&gPlayerParty[partyIndex], MON_DATA_LEVEL, NULL);
    gBattleMons[battlerId].hp = GetMonData(&gPlayerParty[partyIndex], MON_DATA_HP, NULL);
    gBattleMons[battlerId].maxHP = GetMonData(&gPlayerParty[partyIndex], MON_DATA_MAX_HP, NULL);
    gBattleMons[battlerId].attack = GetMonData(&gPlayerParty[partyIndex], MON_DATA_ATK, NULL);
    gBattleMons[battlerId].defense = GetMonData(&gPlayerParty[partyIndex], MON_DATA_DEF, NULL);
    gBattleMons[battlerId].speed = GetMonData(&gPlayerParty[partyIndex], MON_DATA_SPEED, NULL);
    gBattleMons[battlerId].spAttack = GetMonData(&gPlayerParty[partyIndex], MON_DATA_SPATK, NULL);
    gBattleMons[battlerId].spDefense = GetMonData(&gPlayerParty[partyIndex], MON_DATA_SPDEF, NULL);
    gBattleMons[battlerId].isEgg = GetMonData(&gPlayerParty[partyIndex], MON_DATA_IS_EGG, NULL);
    gBattleMons[battlerId].abilityNum = GetMonData(&gPlayerParty[partyIndex], MON_DATA_ABILITY_NUM, NULL);
    gBattleMons[battlerId].otId = GetMonData(&gPlayerParty[partyIndex], MON_DATA_OT_ID, NULL);
    gBattleMons[battlerId].type1 = GetTypeBySpecies(gBattleMons[battlerId].species, 1); //tx_randomizer_and_challenges
    gBattleMons[battlerId].type2 = GetTypeBySpecies(gBattleMons[battlerId].species, 2); //tx_randomizer_and_challenges
    gBattleMons[battlerId].ability = GetAbilityBySpecies(gBattleMons[battlerId].species, gBattleMons[battlerId].abilityNum);
    GetMonData(&gPlayerParty[partyIndex], MON_DATA_NICKNAME, nickname);
    StringCopy_Nickname(gBattleMons[battlerId].nickname, nickname);
    GetMonData(&gPlayerParty[partyIndex], MON_DATA_OT_NAME, gBattleMons[battlerId].otName);

    hpSwitchout = &gBattleStruct->hpOnSwitchout[GetBattlerSide(battlerId)];
    *hpSwitchout = gBattleMons[battlerId].hp;

    for (i = 0; i < NUM_BATTLE_STATS; i++)
        gBattleMons[battlerId].statStages[i] = DEFAULT_STAT_STAGE;

    gBattleMons[battlerId].status2 = 0;
    UpdateSentPokesToOpponentValue(battlerId);
    ClearTemporarySpeciesSpriteData(battlerId, FALSE);
=======
void PokemonToBattleMon(struct Pokemon *src, struct BattlePokemon *dst)
{
    s32 i;
    u8 nickname[POKEMON_NAME_BUFFER_SIZE];

    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        dst->moves[i] = GetMonData(src, MON_DATA_MOVE1 + i, NULL);
        dst->pp[i] = GetMonData(src, MON_DATA_PP1 + i, NULL);
    }

    dst->species = GetMonData(src, MON_DATA_SPECIES, NULL);
    dst->item = GetMonData(src, MON_DATA_HELD_ITEM, NULL);
    dst->ppBonuses = GetMonData(src, MON_DATA_PP_BONUSES, NULL);
    dst->friendship = GetMonData(src, MON_DATA_FRIENDSHIP, NULL);
    dst->experience = GetMonData(src, MON_DATA_EXP, NULL);
    dst->hpIV = GetMonData(src, MON_DATA_HP_IV, NULL);
    dst->attackIV = GetMonData(src, MON_DATA_ATK_IV, NULL);
    dst->defenseIV = GetMonData(src, MON_DATA_DEF_IV, NULL);
    dst->speedIV = GetMonData(src, MON_DATA_SPEED_IV, NULL);
    dst->spAttackIV = GetMonData(src, MON_DATA_SPATK_IV, NULL);
    dst->spDefenseIV = GetMonData(src, MON_DATA_SPDEF_IV, NULL);
    dst->personality = GetMonData(src, MON_DATA_PERSONALITY, NULL);
    dst->status1 = GetMonData(src, MON_DATA_STATUS, NULL);
    dst->level = GetMonData(src, MON_DATA_LEVEL, NULL);
    dst->hp = GetMonData(src, MON_DATA_HP, NULL);
    dst->maxHP = GetMonData(src, MON_DATA_MAX_HP, NULL);
    dst->attack = GetMonData(src, MON_DATA_ATK, NULL);
    dst->defense = GetMonData(src, MON_DATA_DEF, NULL);
    dst->speed = GetMonData(src, MON_DATA_SPEED, NULL);
    dst->spAttack = GetMonData(src, MON_DATA_SPATK, NULL);
    dst->spDefense = GetMonData(src, MON_DATA_SPDEF, NULL);
    dst->abilityNum = GetMonData(src, MON_DATA_ABILITY_NUM, NULL);
    dst->otId = GetMonData(src, MON_DATA_OT_ID, NULL);
    dst->types[0] = GetSpeciesType(dst->species, 0);
    dst->types[1] = GetSpeciesType(dst->species, 1);
    dst->types[2] = TYPE_MYSTERY;
    dst->isShiny = IsMonShiny(src);
    dst->ability = GetAbilityBySpecies(dst->species, dst->abilityNum);
    GetMonData(src, MON_DATA_NICKNAME, nickname);
    StringCopy_Nickname(dst->nickname, nickname);
    GetMonData(src, MON_DATA_OT_NAME, dst->otName);

    for (i = 0; i < NUM_BATTLE_STATS; i++)
        dst->statStages[i] = DEFAULT_STAT_STAGE;

    memset(&dst->volatiles, 0, sizeof(struct Volatiles));
}

void CopyPartyMonToBattleData(u32 battler, u32 partyIndex)
{
    u32 side = GetBattlerSide(battler);
    struct Pokemon *party = GetSideParty(side);
    PokemonToBattleMon(&party[partyIndex], &gBattleMons[battler]);
    gBattleStruct->hpOnSwitchout[side] = gBattleMons[battler].hp;
    UpdateSentPokesToOpponentValue(battler);
    ClearTemporarySpeciesSpriteData(battler, FALSE, FALSE);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

bool8 ExecuteTableBasedItemEffect(struct Pokemon *mon, u16 item, u8 partyIndex, u8 moveIndex)
{
    return PokemonUseItemEffects(mon, item, partyIndex, moveIndex, FALSE);
}

#define UPDATE_FRIENDSHIP_FROM_ITEM()                                                                   \
{                                                                                                       \
    if ((retVal == 0 || friendshipOnly) && !ShouldSkipFriendshipChange() && friendshipChange == 0)      \
    {                                                                                                   \
        friendshipChange = itemEffect[itemEffectParam];                                                 \
        friendship = GetMonData(mon, MON_DATA_FRIENDSHIP, NULL);                                        \
        if (friendshipChange > 0 && holdEffect == HOLD_EFFECT_FRIENDSHIP_UP)                            \
            friendship += 150 * friendshipChange / 100;                                                 \
        else                                                                                            \
            friendship += friendshipChange;                                                             \
        if (friendshipChange > 0)                                                                       \
        {                                                                                               \
            if (GetMonData(mon, MON_DATA_POKEBALL, NULL) == ITEM_LUXURY_BALL)                           \
                friendship++;                                                                           \
            if (GetMonData(mon, MON_DATA_MET_LOCATION, NULL) == GetCurrentRegionMapSectionId())         \
                friendship++;                                                                           \
        }                                                                                               \
        if (friendship < 0)                                                                             \
            friendship = 0;                                                                             \
        if (friendship > MAX_FRIENDSHIP)                                                                \
            friendship = MAX_FRIENDSHIP;                                                                \
        SetMonData(mon, MON_DATA_FRIENDSHIP, &friendship);                                              \
        retVal = FALSE;                                                                                 \
    }                                                                                                   \
}

<<<<<<< HEAD
=======
// EXP candies store an index for this table in their holdEffectParam.
const u32 sExpCandyExperienceTable[] = {
    [EXP_100 - 1] = 100,
    [EXP_800 - 1] = 800,
    [EXP_3000 - 1] = 3000,
    [EXP_10000 - 1] = 10000,
    [EXP_30000 - 1] = 30000,
};

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
// Returns TRUE if the item has no effect on the PokÃ©mon, FALSE otherwise
bool8 PokemonUseItemEffects(struct Pokemon *mon, u16 item, u8 partyIndex, u8 moveIndex, bool8 usedByAI)
{
    u32 dataUnsigned;
<<<<<<< HEAD
    s32 dataSigned;
=======
    s32 dataSigned, evCap;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    s32 friendship;
    s32 i;
    bool8 retVal = TRUE;
    const u8 *itemEffect;
    u8 itemEffectParam = ITEM_EFFECT_ARG_START;
    u32 temp1, temp2;
    s8 friendshipChange = 0;
    u8 holdEffect;
<<<<<<< HEAD
    u8 battlerId = MAX_BATTLERS_COUNT;
=======
    u8 battler = MAX_BATTLERS_COUNT;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    u32 friendshipOnly = FALSE;
    u16 heldItem;
    u8 effectFlags;
    s8 evChange;
    u16 evCount;

<<<<<<< HEAD
    // Get item hold effect
    heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, NULL);
    if (heldItem == ITEM_ENIGMA_BERRY)
    {
        if (gMain.inBattle)
            holdEffect = gEnigmaBerries[gBattlerInMenuId].holdEffect;
        else
            holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
    }
    else
    {
        holdEffect = ItemId_GetHoldEffect(heldItem);
    }

    // Get battler id (if relevant)
    gPotentialItemEffectBattler = gBattlerInMenuId;
    if (gMain.inBattle)
    {
        gActiveBattler = gBattlerInMenuId;
        i = (GetBattlerSide(gActiveBattler) != B_SIDE_PLAYER);
        while (i < gBattlersCount)
        {
            if (gBattlerPartyIndexes[i] == partyIndex)
            {
                battlerId = i;
                break;
            }
            i += 2;
        }
    }
    else
    {
        gActiveBattler = 0;
        battlerId = MAX_BATTLERS_COUNT;
    }

    // Skip using the item if it won't do anything
    if (!ITEM_HAS_EFFECT(item))
        return TRUE;
    if (gItemEffectTable[item - ITEM_POTION] == NULL && item != ITEM_ENIGMA_BERRY && (gSaveBlock1Ptr->tx_Mode_New_Citrus == 1))
        return TRUE;
    else if (gItemEffectTable_OldSitrus[item - ITEM_POTION] == NULL && item != ITEM_ENIGMA_BERRY && (gSaveBlock1Ptr->tx_Mode_New_Citrus == 0))
        return TRUE;

    // Get item effect
    if (item == ITEM_ENIGMA_BERRY)
    {
        if (gMain.inBattle)
            itemEffect = gEnigmaBerries[gActiveBattler].itemEffect;
        else
            itemEffect = gSaveBlock1Ptr->enigmaBerry.itemEffect;
    }
    else
    {
        if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 0)
            itemEffect = gItemEffectTable_OldSitrus[item - ITEM_POTION];
        else if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 1)
            itemEffect = gItemEffectTable[item - ITEM_POTION];
    }
=======
    // Determine the EV cap to use
    u32 maxAllowedEVs = !B_EV_ITEMS_CAP ? MAX_TOTAL_EVS : GetCurrentEVCap();

    // Get item hold effect
    heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, NULL);
    if (heldItem == ITEM_ENIGMA_BERRY_E_READER)
    #if FREE_ENIGMA_BERRY == FALSE
        holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
    #else
        holdEffect = 0;
    #endif //FREE_ENIGMA_BERRY
    else
        holdEffect = GetItemHoldEffect(heldItem);

    // Skip using the item if it won't do anything
    if (GetItemEffect(item) == NULL && item != ITEM_ENIGMA_BERRY_E_READER)
        return TRUE;

    // Get item effect
    itemEffect = GetItemEffect(item);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    // Do item effect
    for (i = 0; i < ITEM_EFFECT_ARG_START; i++)
    {
        switch (i)
        {

        // Handle ITEM0 effects (infatuation, Dire Hit, X Attack). ITEM0_SACRED_ASH is handled in party_menu.c
<<<<<<< HEAD
        case 0:
            // Cure infatuation
            if ((itemEffect[i] & ITEM0_INFATUATION)
             && gMain.inBattle && battlerId != MAX_BATTLERS_COUNT && (gBattleMons[battlerId].status2 & STATUS2_INFATUATION))
            {
                gBattleMons[battlerId].status2 &= ~STATUS2_INFATUATION;
                retVal = FALSE;
            }

            // Dire Hit
            if ((itemEffect[i] & ITEM0_DIRE_HIT)
             && !(gBattleMons[gActiveBattler].status2 & STATUS2_FOCUS_ENERGY))
            {
                gBattleMons[gActiveBattler].status2 |= STATUS2_FOCUS_ENERGY;
                retVal = FALSE;
            }

            // X Attack
            if ((itemEffect[i] & ITEM0_X_ATTACK)
             && gBattleMons[gActiveBattler].statStages[STAT_ATK] < MAX_STAT_STAGE)
            {
                gBattleMons[gActiveBattler].statStages[STAT_ATK] += itemEffect[i] & ITEM0_X_ATTACK;
                if (gBattleMons[gActiveBattler].statStages[STAT_ATK] > MAX_STAT_STAGE)
                    gBattleMons[gActiveBattler].statStages[STAT_ATK] = MAX_STAT_STAGE;
                retVal = FALSE;
            }
            break;

        // Handle ITEM1 effects (in-battle stat boosting effects)
        case 1:
            // X Defend
            if ((itemEffect[i] & ITEM1_X_DEFEND)
             && gBattleMons[gActiveBattler].statStages[STAT_DEF] < MAX_STAT_STAGE)
            {
                gBattleMons[gActiveBattler].statStages[STAT_DEF] += (itemEffect[i] & ITEM1_X_DEFEND) >> 4;
                if (gBattleMons[gActiveBattler].statStages[STAT_DEF] > MAX_STAT_STAGE)
                    gBattleMons[gActiveBattler].statStages[STAT_DEF] = MAX_STAT_STAGE;
                retVal = FALSE;
            }

            // X Speed
            if ((itemEffect[i] & ITEM1_X_SPEED)
             && gBattleMons[gActiveBattler].statStages[STAT_SPEED] < MAX_STAT_STAGE)
            {
                gBattleMons[gActiveBattler].statStages[STAT_SPEED] += itemEffect[i] & ITEM1_X_SPEED;
                if (gBattleMons[gActiveBattler].statStages[STAT_SPEED] > MAX_STAT_STAGE)
                    gBattleMons[gActiveBattler].statStages[STAT_SPEED] = MAX_STAT_STAGE;
                retVal = FALSE;
            }
            break;
        // Handle ITEM2 effects (more stat boosting effects)
        case 2:
            // X Accuracy
            if ((itemEffect[i] & ITEM2_X_ACCURACY)
             && gBattleMons[gActiveBattler].statStages[STAT_ACC] < MAX_STAT_STAGE)
            {
                gBattleMons[gActiveBattler].statStages[STAT_ACC] += (itemEffect[i] & ITEM2_X_ACCURACY) >> 4;
                if (gBattleMons[gActiveBattler].statStages[STAT_ACC] > MAX_STAT_STAGE)
                    gBattleMons[gActiveBattler].statStages[STAT_ACC] = MAX_STAT_STAGE;
                retVal = FALSE;
            }

            // X Sp Attack
            if ((itemEffect[i] & ITEM2_X_SPATK)
             && gBattleMons[gActiveBattler].statStages[STAT_SPATK] < MAX_STAT_STAGE)
            {
                gBattleMons[gActiveBattler].statStages[STAT_SPATK] += itemEffect[i] & ITEM2_X_SPATK;
                if (gBattleMons[gActiveBattler].statStages[STAT_SPATK] > MAX_STAT_STAGE)
                    gBattleMons[gActiveBattler].statStages[STAT_SPATK] = MAX_STAT_STAGE;
                retVal = FALSE;
            }
=======
        // Now handled in item battle scripts.
        case 0:
            break;

        // Handle ITEM1 effects (in-battle stat boosting effects)
        // Now handled in item battle scripts.
        case 1:
            break;
        // Formerly used by the item effects of the X Sp. Atk and the X Accuracy
        case 2:
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            break;

        // Handle ITEM3 effects (Guard Spec, Rare Candy, cure status)
        case 3:
<<<<<<< HEAD
            // Guard Spec
            if ((itemEffect[i] & ITEM3_GUARD_SPEC)
             && gSideTimers[GetBattlerSide(gActiveBattler)].mistTimer == 0)
            {
                gSideTimers[GetBattlerSide(gActiveBattler)].mistTimer = 5;
                retVal = FALSE;
            }

            // Rare Candy
            if ((itemEffect[i] & ITEM3_LEVEL_UP)
             && GetMonData(mon, MON_DATA_LEVEL, NULL) < GetCurrentPartyLevelCap())
            {
                dataUnsigned = gExperienceTables[gSpeciesInfo[GetMonData(mon, MON_DATA_SPECIES, NULL)].growthRate][GetMonData(mon, MON_DATA_LEVEL, NULL) + 1];
                SetMonData(mon, MON_DATA_EXP, &dataUnsigned);
                CalculateMonStats(mon);
                retVal = FALSE;
            }

            // Cure status
            if ((itemEffect[i] & ITEM3_SLEEP)
             && HealStatusConditions(mon, partyIndex, STATUS1_SLEEP, battlerId) == 0)
            {
                if (battlerId != MAX_BATTLERS_COUNT)
                    gBattleMons[battlerId].status2 &= ~STATUS2_NIGHTMARE;
                retVal = FALSE;
            }
            if ((itemEffect[i] & ITEM3_POISON) && HealStatusConditions(mon, partyIndex, STATUS1_PSN_ANY | STATUS1_TOXIC_COUNTER, battlerId) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_BURN) && HealStatusConditions(mon, partyIndex, STATUS1_BURN, battlerId) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_FREEZE) && HealStatusConditions(mon, partyIndex, STATUS1_FREEZE, battlerId) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_PARALYSIS) && HealStatusConditions(mon, partyIndex, STATUS1_PARALYSIS, battlerId) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_CONFUSION)  // heal confusion
             && gMain.inBattle && battlerId != MAX_BATTLERS_COUNT && (gBattleMons[battlerId].status2 & STATUS2_CONFUSION))
            {
                gBattleMons[battlerId].status2 &= ~STATUS2_CONFUSION;
                retVal = FALSE;
            }
=======
            // Rare Candy / EXP Candy
            if ((itemEffect[i] & ITEM3_LEVEL_UP)
             && GetMonData(mon, MON_DATA_LEVEL, NULL) != MAX_LEVEL)
            {
                u8 param = GetItemHoldEffectParam(item);
                dataUnsigned = 0;

                if (param == 0) // Rare Candy
                {
                    dataUnsigned = gExperienceTables[gSpeciesInfo[GetMonData(mon, MON_DATA_SPECIES, NULL)].growthRate][GetMonData(mon, MON_DATA_LEVEL, NULL) + 1];
                }
                else if (param - 1 < ARRAY_COUNT(sExpCandyExperienceTable)) // EXP Candies
                {
                    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
                    dataUnsigned = sExpCandyExperienceTable[param - 1] + GetMonData(mon, MON_DATA_EXP, NULL);

                    if (B_RARE_CANDY_CAP && B_EXP_CAP_TYPE == EXP_CAP_HARD)
                    {
                        u32 currentLevelCap = GetCurrentLevelCap();
                        if (dataUnsigned > gExperienceTables[gSpeciesInfo[species].growthRate][currentLevelCap])
                            dataUnsigned = gExperienceTables[gSpeciesInfo[species].growthRate][currentLevelCap];
                    }
                    else if (dataUnsigned > gExperienceTables[gSpeciesInfo[species].growthRate][MAX_LEVEL])
                    {
                        dataUnsigned = gExperienceTables[gSpeciesInfo[species].growthRate][MAX_LEVEL];
                    }
                }

                if (dataUnsigned != 0) // Failsafe
                {
                    SetMonData(mon, MON_DATA_EXP, &dataUnsigned);
                    CalculateMonStats(mon);
                    retVal = FALSE;
                }
            }

            // Cure status
            if ((itemEffect[i] & ITEM3_SLEEP) && HealStatusConditions(mon, STATUS1_SLEEP, battler) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_POISON) && HealStatusConditions(mon, STATUS1_PSN_ANY | STATUS1_TOXIC_COUNTER, battler) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_BURN) && HealStatusConditions(mon, STATUS1_BURN, battler) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_FREEZE) && HealStatusConditions(mon, STATUS1_FREEZE | STATUS1_FROSTBITE, battler) == 0)
                retVal = FALSE;
            if ((itemEffect[i] & ITEM3_PARALYSIS) && HealStatusConditions(mon, STATUS1_PARALYSIS, battler) == 0)
                retVal = FALSE;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            break;

        // Handle ITEM4 effects (Change HP/Atk EVs, HP heal, PP heal, PP up, Revive, and evolution stones)
        case 4:
            effectFlags = itemEffect[i];

            // PP Up
            if (effectFlags & ITEM4_PP_UP)
            {
<<<<<<< HEAD
                effectFlags &= ~ITEM4_PP_UP;
                dataUnsigned = (GetMonData(mon, MON_DATA_PP_BONUSES, NULL) & gPPUpGetMask[moveIndex]) >> (moveIndex * 2);
                temp1 = CalculatePPWithBonus(GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL), GetMonData(mon, MON_DATA_PP_BONUSES, NULL), moveIndex);
                if (dataUnsigned <= 2 && temp1 > 4)
                {
                    dataUnsigned = GetMonData(mon, MON_DATA_PP_BONUSES, NULL) + gPPUpAddValues[moveIndex];
=======
                u32 ppBonuses = GetMonData(mon, MON_DATA_PP_BONUSES, NULL);
                effectFlags &= ~ITEM4_PP_UP;
                dataUnsigned = (ppBonuses & gPPUpGetMask[moveIndex]) >> (moveIndex * 2);
                temp1 = CalculatePPWithBonus(GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL), ppBonuses, moveIndex);
                if (dataUnsigned <= 2 && temp1 > 4)
                {
                    dataUnsigned = ppBonuses + gPPUpAddValues[moveIndex];
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                    SetMonData(mon, MON_DATA_PP_BONUSES, &dataUnsigned);

                    dataUnsigned = CalculatePPWithBonus(GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL), dataUnsigned, moveIndex) - temp1;
                    dataUnsigned = GetMonData(mon, MON_DATA_PP1 + moveIndex, NULL) + dataUnsigned;
                    SetMonData(mon, MON_DATA_PP1 + moveIndex, &dataUnsigned);
                    retVal = FALSE;
                }
            }
            temp1 = 0;

            // Loop through and try each of the remaining ITEM4 effects
            while (effectFlags != 0)
            {
                if (effectFlags & 1)
                {
                    switch (temp1)
                    {
                    case 0: // ITEM4_EV_HP
                    case 1: // ITEM4_EV_ATK
                        evCount = GetMonEVCount(mon);
                        temp2 = itemEffect[itemEffectParam];
                        dataSigned = GetMonData(mon, sGetMonDataEVConstants[temp1], NULL);
                        evChange = temp2;

                        if (evChange > 0) // Increasing EV (HP or Atk)
                        {
<<<<<<< HEAD
                            // Has EV increase limit already been reached?
                            if (evCount >= MAX_TOTAL_EVS)
                                return TRUE;
                            if (dataSigned >= EV_ITEM_RAISE_LIMIT)
                                break;

                            // Limit the increase
                            if (dataSigned + evChange > EV_ITEM_RAISE_LIMIT)
                                temp2 = EV_ITEM_RAISE_LIMIT - (dataSigned + evChange) + evChange;
                            else
                                temp2 = evChange;

                            if (evCount + temp2 > MAX_TOTAL_EVS)
                                temp2 += MAX_TOTAL_EVS - (evCount + temp2);

                            dataSigned += temp2;
                        }
                        else // Decreasing EV (HP or Atk)
=======
                            // Check if the total EV limit is reached
                            if (evCount >= maxAllowedEVs)
                                return TRUE;

                            // Ensure the increase does not exceed the max EV per stat (252)
                            evCap = (itemEffect[10] & ITEM10_IS_VITAMIN) ? EV_ITEM_RAISE_LIMIT : MAX_PER_STAT_EVS;

                            // Check if the per-stat limit is reached
                            if (dataSigned >= evCap)
                                return TRUE;  // Prevents item use if the per-stat cap is already reached

                            if (dataSigned + evChange > evCap)
                                temp2 = evCap - dataSigned;
                            else
                                temp2 = evChange;

                            // Ensure the total EVs do not exceed the maximum allowed (510)
                            if (evCount + temp2 > maxAllowedEVs)
                                temp2 = maxAllowedEVs - evCount;

                            // Prevent item use if no EVs can be increased
                            if (temp2 == 0)
                                return TRUE;

                            // Apply the EV increase
                            dataSigned += temp2;
                        }
                        else if (evChange < 0) // Decreasing EV (HP or Atk)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                        {
                            if (dataSigned == 0)
                            {
                                // No EVs to lose, but make sure friendship updates anyway
                                friendshipOnly = TRUE;
                                itemEffectParam++;
                                break;
                            }
                            dataSigned += evChange;
<<<<<<< HEAD
                            if (dataSigned < 0)
                                dataSigned = 0;
                        }
=======
                            if (I_BERRY_EV_JUMP == GEN_4 && dataSigned > 100)
                                dataSigned = 100;
                            if (dataSigned < 0)
                                dataSigned = 0;
                        }
                        else // Reset EV (HP or Atk)
                        {
                            if (dataSigned == 0)
                                break;

                            dataSigned = 0;
                        }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

                        // Update EVs and stats
                        SetMonData(mon, sGetMonDataEVConstants[temp1], &dataSigned);
                        CalculateMonStats(mon);
                        itemEffectParam++;
                        retVal = FALSE;
                        break;

                    case 2: // ITEM4_HEAL_HP
<<<<<<< HEAD
                        // If Revive, update number of times revive has been used
                        if (effectFlags & (ITEM4_REVIVE >> 2))
                        {
                            if (GetMonData(mon, MON_DATA_HP, NULL) != 0)
                            {
                                itemEffectParam++;
                                break;
                            }
                            if (gMain.inBattle)
                            {
                                if (battlerId != MAX_BATTLERS_COUNT)
                                {
                                    gAbsentBattlerFlags &= ~gBitTable[battlerId];
                                    CopyPlayerPartyMonToBattleData(battlerId, GetPartyIdFromBattlePartyId(gBattlerPartyIndexes[battlerId]));
                                    if (GetBattlerSide(gActiveBattler) == B_SIDE_PLAYER && gBattleResults.numRevivesUsed < 255)
                                        gBattleResults.numRevivesUsed++;
                                }
                                else
                                {
                                    gAbsentBattlerFlags &= ~gBitTable[gActiveBattler ^ 2];
                                    if (GetBattlerSide(gActiveBattler) == B_SIDE_PLAYER && gBattleResults.numRevivesUsed < 255)
                                        gBattleResults.numRevivesUsed++;
                                }
                            }
                        }
                        else
                        {
                            if (GetMonData(mon, MON_DATA_HP, NULL) == 0)
                            {
                                itemEffectParam++;
                                break;
                            }
=======
                    {
                        u32 currentHP = GetMonData(mon, MON_DATA_HP, NULL);
                        u32 maxHP = GetMonData(mon, MON_DATA_MAX_HP, NULL);
                        // Check use validity.
                        if ((effectFlags & (ITEM4_REVIVE >> 2) && currentHP != 0)
                              || (!(effectFlags & (ITEM4_REVIVE >> 2)) && currentHP == 0))
                        {
                            itemEffectParam++;
                            break;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                        }

                        // Get amount of HP to restore
                        dataUnsigned = itemEffect[itemEffectParam++];
                        switch (dataUnsigned)
                        {
                        case ITEM6_HEAL_HP_FULL:
<<<<<<< HEAD
                            dataUnsigned = GetMonData(mon, MON_DATA_MAX_HP, NULL) - GetMonData(mon, MON_DATA_HP, NULL);
                            break;
                        case ITEM6_HEAL_HP_HALF:
                            dataUnsigned = GetMonData(mon, MON_DATA_MAX_HP, NULL) / 2;
                            if (dataUnsigned == 0)
                                dataUnsigned = 1;
                            break;
                        case ITEM6_HEAL_QUARTER:
                            dataUnsigned = GetMonData(mon, MON_DATA_MAX_HP, NULL) / 4;
=======
                            dataUnsigned = maxHP - currentHP;
                            break;
                        case ITEM6_HEAL_HP_HALF:
                            dataUnsigned = maxHP / 2;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                            if (dataUnsigned == 0)
                                dataUnsigned = 1;
                            break;
                        case ITEM6_HEAL_HP_LVL_UP:
                            dataUnsigned = gBattleScripting.levelUpHP;
                            break;
<<<<<<< HEAD
                        }

                        // Only restore HP if not at max health
                        if (GetMonData(mon, MON_DATA_MAX_HP, NULL) != GetMonData(mon, MON_DATA_HP, NULL))
                        {
                            if (!usedByAI)
                            {
                                // Restore HP
                                dataUnsigned = GetMonData(mon, MON_DATA_HP, NULL) + dataUnsigned;
                                if (dataUnsigned > GetMonData(mon, MON_DATA_MAX_HP, NULL))
                                    dataUnsigned = GetMonData(mon, MON_DATA_MAX_HP, NULL);
                                SetMonData(mon, MON_DATA_HP, &dataUnsigned);

                                // Update battler (if applicable)
                                if (gMain.inBattle && battlerId != MAX_BATTLERS_COUNT)
                                {
                                    gBattleMons[battlerId].hp = dataUnsigned;
                                    if (!(effectFlags & (ITEM4_REVIVE >> 2)) && GetBattlerSide(gActiveBattler) == B_SIDE_PLAYER)
                                    {
                                        if (gBattleResults.numHealingItemsUsed < 255)
                                            gBattleResults.numHealingItemsUsed++;

                                        temp2 = gActiveBattler;
                                        gActiveBattler = battlerId;
                                        BtlController_EmitGetMonData(BUFFER_A, REQUEST_ALL_BATTLE, 0);
                                        MarkBattlerForControllerExec(gActiveBattler);
                                        gActiveBattler = temp2;
                                    }
                                }
                            }
                            else
                            {
                                gBattleMoveDamage = -dataUnsigned;
                            }
=======
                        case ITEM6_HEAL_HP_QUARTER:
                            dataUnsigned = maxHP / 4;
                            if (dataUnsigned == 0)
                                dataUnsigned = 1;
                            break;
                        }

                        // Only restore HP if not at max health
                        if (maxHP != currentHP)
                        {
                            // Restore HP
                            dataUnsigned = currentHP + dataUnsigned;
                            if (dataUnsigned > maxHP)
                                dataUnsigned = maxHP;
                            SetMonData(mon, MON_DATA_HP, &dataUnsigned);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                            retVal = FALSE;
                        }
                        effectFlags &= ~(ITEM4_REVIVE >> 2);
                        break;
<<<<<<< HEAD

=======
                    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                    case 3: // ITEM4_HEAL_PP
                        if (!(effectFlags & (ITEM4_HEAL_PP_ONE >> 3)))
                        {
                            // Heal PP for all moves
                            for (temp2 = 0; (signed)(temp2) < (signed)(MAX_MON_MOVES); temp2++)
                            {
<<<<<<< HEAD
                                u16 moveId;
                                dataUnsigned = GetMonData(mon, MON_DATA_PP1 + temp2, NULL);
                                moveId = GetMonData(mon, MON_DATA_MOVE1 + temp2, NULL);
                                if (dataUnsigned != CalculatePPWithBonus(moveId, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), temp2))
                                {
                                    dataUnsigned += itemEffect[itemEffectParam];
                                    moveId = GetMonData(mon, MON_DATA_MOVE1 + temp2, NULL); // Redundant
                                    if (dataUnsigned > CalculatePPWithBonus(moveId, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), temp2))
                                    {
                                        moveId = GetMonData(mon, MON_DATA_MOVE1 + temp2, NULL); // Redundant
                                        dataUnsigned = CalculatePPWithBonus(moveId, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), temp2);
                                    }
                                    SetMonData(mon, MON_DATA_PP1 + temp2, &dataUnsigned);

                                    // Heal battler PP too (if applicable)
                                    if (gMain.inBattle && battlerId != MAX_BATTLERS_COUNT && MOVE_IS_PERMANENT(battlerId, temp2))
                                        gBattleMons[battlerId].pp[temp2] = dataUnsigned;

=======
                                u32 move, ppBonus;
                                dataUnsigned = GetMonData(mon, MON_DATA_PP1 + temp2, NULL);
                                move = GetMonData(mon, MON_DATA_MOVE1 + temp2, NULL);
                                ppBonus = CalculatePPWithBonus(move, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), temp2);
                                if (dataUnsigned != ppBonus)
                                {
                                    dataUnsigned += itemEffect[itemEffectParam];
                                    if (dataUnsigned > ppBonus)
                                        dataUnsigned = ppBonus;
                                    SetMonData(mon, MON_DATA_PP1 + temp2, &dataUnsigned);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                                    retVal = FALSE;
                                }
                            }
                            itemEffectParam++;
                        }
                        else
                        {
                            // Heal PP for one move
<<<<<<< HEAD
                            u16 moveId;
                            dataUnsigned = GetMonData(mon, MON_DATA_PP1 + moveIndex, NULL);
                            moveId = GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL);
                            if (dataUnsigned != CalculatePPWithBonus(moveId, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), moveIndex))
                            {
                                dataUnsigned += itemEffect[itemEffectParam++];
                                moveId = GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL); // Redundant
                                if (dataUnsigned > CalculatePPWithBonus(moveId, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), moveIndex))
                                {
                                    moveId = GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL); // Redundant
                                    dataUnsigned = CalculatePPWithBonus(moveId, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), moveIndex);
                                }
                                SetMonData(mon, MON_DATA_PP1 + moveIndex, &dataUnsigned);

                                // Heal battler PP too (if applicable)
                                if (gMain.inBattle && battlerId != MAX_BATTLERS_COUNT && MOVE_IS_PERMANENT(battlerId, moveIndex))
                                    gBattleMons[battlerId].pp[moveIndex] = dataUnsigned;

=======
                            u16 move;
                            dataUnsigned = GetMonData(mon, MON_DATA_PP1 + moveIndex, NULL);
                            move = GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL);
                            u32 ppBonus = CalculatePPWithBonus(move, GetMonData(mon, MON_DATA_PP_BONUSES, NULL), moveIndex);
                            if (dataUnsigned != ppBonus)
                            {
                                dataUnsigned += itemEffect[itemEffectParam++];
                                if (dataUnsigned > ppBonus)
                                    dataUnsigned = ppBonus;
                                SetMonData(mon, MON_DATA_PP1 + moveIndex, &dataUnsigned);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                                retVal = FALSE;
                            }
                        }
                        break;

                    // cases 4-6 are ITEM4_HEAL_PP_ONE, ITEM4_PP_UP, and ITEM4_REVIVE, which
                    // are already handled above by other cases or before the loop

                    case 7: // ITEM4_EVO_STONE
                        {
<<<<<<< HEAD
                            u16 targetSpecies = GetEvolutionTargetSpecies(mon, EVO_MODE_ITEM_USE, item);

                            if (targetSpecies != SPECIES_NONE)
                            {
                                BeginEvolutionScene(mon, targetSpecies, FALSE, partyIndex);
=======
                            bool32 canStopEvo = TRUE;
                            u32 targetSpecies = GetEvolutionTargetSpecies(mon, EVO_MODE_ITEM_USE, item, NULL, &canStopEvo, CHECK_EVO);

                            if (targetSpecies != SPECIES_NONE)
                            {
                                GetEvolutionTargetSpecies(mon, EVO_MODE_ITEM_USE, item, NULL, &canStopEvo, DO_EVO);
                                BeginEvolutionScene(mon, targetSpecies, canStopEvo, partyIndex);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                                return FALSE;
                            }
                        }
                        break;
                    }
                }
                temp1++;
                effectFlags >>= 1;
            }
            break;

        // Handle ITEM5 effects (Change Def/SpDef/SpAtk/Speed EVs, PP Max, and friendship changes)
        case 5:
            effectFlags = itemEffect[i];
            temp1 = 0;

            // Loop through and try each of the ITEM5 effects
            while (effectFlags != 0)
            {
                if (effectFlags & 1)
                {
                    switch (temp1)
                    {
                    case 0: // ITEM5_EV_DEF
                    case 1: // ITEM5_EV_SPEED
                    case 2: // ITEM5_EV_SPDEF
                    case 3: // ITEM5_EV_SPATK
                        evCount = GetMonEVCount(mon);
                        temp2 = itemEffect[itemEffectParam];
                        dataSigned = GetMonData(mon, sGetMonDataEVConstants[temp1 + 2], NULL);
                        evChange = temp2;
                        if (evChange > 0) // Increasing EV
                        {
<<<<<<< HEAD
                            // Has EV increase limit already been reached?
                            if (evCount >= MAX_TOTAL_EVS)
                                return TRUE;
                            if (dataSigned >= EV_ITEM_RAISE_LIMIT)
                                break;

                            // Limit the increase
                            if (dataSigned + evChange > EV_ITEM_RAISE_LIMIT)
                                temp2 = EV_ITEM_RAISE_LIMIT - (dataSigned + evChange) + evChange;
                            else
                                temp2 = evChange;

                            if (evCount + temp2 > MAX_TOTAL_EVS)
                                temp2 += MAX_TOTAL_EVS - (evCount + temp2);

                            dataSigned += temp2;
                        }
                        else // Decreasing EV
=======
                            // Check if the total EV limit is reached
                            if (evCount >= maxAllowedEVs)
                                return TRUE;

                            // Ensure the increase does not exceed the max EV per stat (252)
                            evCap = (itemEffect[10] & ITEM10_IS_VITAMIN) ? EV_ITEM_RAISE_LIMIT : MAX_PER_STAT_EVS;

                            // Check if the per-stat limit is reached
                            if (dataSigned >= evCap)
                                return TRUE;  // Prevents item use if the per-stat cap is already reached

                            if (dataSigned + evChange > evCap)
                                temp2 = evCap - dataSigned;
                            else
                                temp2 = evChange;

                            // Ensure the total EVs do not exceed the maximum allowed (510)
                            if (evCount + temp2 > maxAllowedEVs)
                                temp2 = maxAllowedEVs - evCount;

                            // Prevent item use if no EVs can be increased
                            if (temp2 == 0)
                                return TRUE;

                            // Apply the EV increase
                            dataSigned += temp2;
                        }
                        else if (evChange < 0) // Decreasing EV
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                        {
                            if (dataSigned == 0)
                            {
                                // No EVs to lose, but make sure friendship updates anyway
                                friendshipOnly = TRUE;
                                itemEffectParam++;
                                break;
                            }
                            dataSigned += evChange;
<<<<<<< HEAD
                            if (dataSigned < 0)
                                dataSigned = 0;
                        }
=======
                            if (I_BERRY_EV_JUMP == GEN_4 && dataSigned > 100)
                                dataSigned = 100;
                            if (dataSigned < 0)
                                dataSigned = 0;
                        }
                        else // Reset EV
                        {
                            if (dataSigned == 0)
                                break;

                            dataSigned = 0;
                        }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

                        // Update EVs and stats
                        SetMonData(mon, sGetMonDataEVConstants[temp1 + 2], &dataSigned);
                        CalculateMonStats(mon);
                        retVal = FALSE;
                        itemEffectParam++;
                        break;

                    case 4: // ITEM5_PP_MAX
<<<<<<< HEAD
                        dataUnsigned = (GetMonData(mon, MON_DATA_PP_BONUSES, NULL) & gPPUpGetMask[moveIndex]) >> (moveIndex * 2);
                        temp2 = CalculatePPWithBonus(GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL), GetMonData(mon, MON_DATA_PP_BONUSES, NULL), moveIndex);
=======
                    {
                        u32 ppBonuses = GetMonData(mon, MON_DATA_PP_BONUSES, NULL);
                        dataUnsigned = (ppBonuses & gPPUpGetMask[moveIndex]) >> (moveIndex * 2);
                        temp2 = CalculatePPWithBonus(GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL), ppBonuses, moveIndex);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

                        // Check if 3 PP Ups have been applied already, and that the move has a total PP of at least 5 (excludes Sketch)
                        if (dataUnsigned < 3 && temp2 >= 5)
                        {
<<<<<<< HEAD
                            dataUnsigned = GetMonData(mon, MON_DATA_PP_BONUSES, NULL);
=======
                            dataUnsigned = ppBonuses;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                            dataUnsigned &= gPPUpClearMask[moveIndex];
                            dataUnsigned += gPPUpAddValues[moveIndex] * 3; // Apply 3 PP Ups (max)

                            SetMonData(mon, MON_DATA_PP_BONUSES, &dataUnsigned);
                            dataUnsigned = CalculatePPWithBonus(GetMonData(mon, MON_DATA_MOVE1 + moveIndex, NULL), dataUnsigned, moveIndex) - temp2;
                            dataUnsigned = GetMonData(mon, MON_DATA_PP1 + moveIndex, NULL) + dataUnsigned;
                            SetMonData(mon, MON_DATA_PP1 + moveIndex, &dataUnsigned);
                            retVal = FALSE;
                        }
                        break;
<<<<<<< HEAD

=======
                    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                    case 5: // ITEM5_FRIENDSHIP_LOW
                        // Changes to friendship are given differently depending on
                        // how much friendship the PokÃ©mon already has.
                        // In general, PokÃ©mon with lower friendship receive more,
                        // and PokÃ©mon with higher friendship receive less.
                        if (GetMonData(mon, MON_DATA_FRIENDSHIP, NULL) < 100)
                            UPDATE_FRIENDSHIP_FROM_ITEM();
                        itemEffectParam++;
                        break;

                    case 6: // ITEM5_FRIENDSHIP_MID
                        if (GetMonData(mon, MON_DATA_FRIENDSHIP, NULL) >= 100 && GetMonData(mon, MON_DATA_FRIENDSHIP, NULL) < 200)
                            UPDATE_FRIENDSHIP_FROM_ITEM();
                        itemEffectParam++;
                        break;

                    case 7: // ITEM5_FRIENDSHIP_HIGH
                        if (GetMonData(mon, MON_DATA_FRIENDSHIP, NULL) >= 200)
                            UPDATE_FRIENDSHIP_FROM_ITEM();
                        itemEffectParam++;
                        break;
                    }
                }
                temp1++;
                effectFlags >>= 1;
            }
            break;
        }
    }
    return retVal;
}

<<<<<<< HEAD
bool8 HealStatusConditions(struct Pokemon *mon, u32 battlePartyId, u32 healMask, u8 battlerId)
=======
bool8 HealStatusConditions(struct Pokemon *mon, u32 healMask, u8 battler)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u32 status = GetMonData(mon, MON_DATA_STATUS, 0);

    if (status & healMask)
    {
        status &= ~healMask;
        SetMonData(mon, MON_DATA_STATUS, &status);
<<<<<<< HEAD
        if (gMain.inBattle && battlerId != MAX_BATTLERS_COUNT)
            gBattleMons[battlerId].status1 &= ~healMask;
=======
        if (gMain.inBattle && battler != MAX_BATTLERS_COUNT)
        {
            gBattleMons[battler].status1 &= ~healMask;
            if((healMask & STATUS1_SLEEP))
            {
                u32 i = 0;
                u32 battlerSide = GetBattlerSide(battler);
                struct Pokemon *party = GetSideParty(battlerSide);

                for (i = 0; i < PARTY_SIZE; i++)
                {
                    if (&party[i] == mon)
                    {
                        TryDeactivateSleepClause(battlerSide, i);
                        break;
                    }
                }
            }
        }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        return FALSE;
    }
    else
    {
        return TRUE;
    }
}

<<<<<<< HEAD
u8 GetItemEffectParamOffset(u16 itemId, u8 effectByte, u8 effectBit)
{
    const u8 *temp;
    const u8 *temp2;
    const u8 *itemEffect;
    const u8 *itemEffect2;
=======
u8 GetItemEffectParamOffset(u32 battler, u16 itemId, u8 effectByte, u8 effectBit)
{
    const u8 *temp;
    const u8 *itemEffect;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    u8 offset;
    int i;
    u8 j;
    u8 effectFlags;

    offset = ITEM_EFFECT_ARG_START;

<<<<<<< HEAD
    temp = gItemEffectTable[itemId - ITEM_POTION];
    temp2 = gItemEffectTable_OldSitrus[itemId - ITEM_POTION];

    if (!temp && itemId != ITEM_ENIGMA_BERRY && (gSaveBlock1Ptr->tx_Mode_New_Citrus == 1))
        return 0;
    else if (!temp2 && itemId != ITEM_ENIGMA_BERRY && (gSaveBlock1Ptr->tx_Mode_New_Citrus == 0))
        return 0;

    if ((itemId == ITEM_ENIGMA_BERRY) && (gSaveBlock1Ptr->tx_Mode_New_Citrus == 1))
    {
        temp = gEnigmaBerries[gActiveBattler].itemEffect;
    }
    else if ((itemId == ITEM_ENIGMA_BERRY) && (gSaveBlock1Ptr->tx_Mode_New_Citrus == 0))
    {
        temp2 = gEnigmaBerries[gActiveBattler].itemEffect;
    }

    itemEffect = temp;
    itemEffect2 = temp;
=======
    temp = GetItemEffect(itemId);

    if (temp != NULL && !temp && itemId != ITEM_ENIGMA_BERRY_E_READER)
        return 0;

    if (itemId == ITEM_ENIGMA_BERRY_E_READER)
    {
        temp = gEnigmaBerries[battler].itemEffect;
    }

    itemEffect = temp;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    for (i = 0; i < ITEM_EFFECT_ARG_START; i++)
    {
        switch (i)
        {
        case 0:
        case 1:
        case 2:
        case 3:
            if (i == effectByte)
                return 0;
            break;
        case 4:
<<<<<<< HEAD
            if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 1)
                effectFlags = itemEffect[4];
            else if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 0)
                effectFlags = itemEffect2[4];
=======
            effectFlags = itemEffect[4];
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            if (effectFlags & ITEM4_PP_UP)
                effectFlags &= ~(ITEM4_PP_UP);
            j = 0;
            while (effectFlags)
            {
                if (effectFlags & 1)
                {
                    switch (j)
                    {
                    case 2: // ITEM4_HEAL_HP
                        if (effectFlags & (ITEM4_REVIVE >> 2))
                            effectFlags &= ~(ITEM4_REVIVE >> 2);
                        // fallthrough
                    case 0: // ITEM4_EV_HP
                        if (i == effectByte && (effectFlags & effectBit))
                            return offset;
                        offset++;
                        break;
                    case 1: // ITEM4_EV_ATK
                        if (i == effectByte && (effectFlags & effectBit))
                            return offset;
                        offset++;
                        break;
                    case 3: // ITEM4_HEAL_PP
                        if (i == effectByte && (effectFlags & effectBit))
                            return offset;
                        offset++;
                        break;
                    case 7: // ITEM4_EVO_STONE
                        if (i == effectByte)
                            return 0;
                        break;
                    }
                }
                j++;
                effectFlags >>= 1;
                if (i == effectByte)
                    effectBit >>= 1;
            }
            break;
        case 5:
<<<<<<< HEAD
            if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 1)
                effectFlags = itemEffect[5];
            else if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 0)
                effectFlags = itemEffect2[5];
=======
            effectFlags = itemEffect[5];
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            j = 0;
            while (effectFlags)
            {
                if (effectFlags & 1)
                {
                    switch (j)
                    {
                    case 0: // ITEM5_EV_DEF
                    case 1: // ITEM5_EV_SPEED
                    case 2: // ITEM5_EV_SPDEF
                    case 3: // ITEM5_EV_SPATK
                    case 4: // ITEM5_PP_MAX
                    case 5: // ITEM5_FRIENDSHIP_LOW
                    case 6: // ITEM5_FRIENDSHIP_MID
                        if (i == effectByte && (effectFlags & effectBit))
                            return offset;
                        offset++;
                        break;
                    case 7: // ITEM5_FRIENDSHIP_HIGH
                        if (i == effectByte)
                            return 0;
                        break;
                    }
                }
                j++;
                effectFlags >>= 1;
                if (i == effectByte)
                    effectBit >>= 1;
            }
            break;
        }
    }

    return offset;
}

static void BufferStatRoseMessage(s32 statIdx)
{
    gBattlerTarget = gBattlerInMenuId;
    StringCopy(gBattleTextBuff1, gStatNamesTable[sStatsToRaise[statIdx]]);
<<<<<<< HEAD
    StringCopy(gBattleTextBuff2, gText_StatRose);
=======
    if (B_X_ITEMS_BUFF >= GEN_7)
    {
        StringCopy(gBattleTextBuff2, gText_StatSharply);
        StringAppend(gBattleTextBuff2, gText_StatRose);
    }
    else
    {
        StringCopy(gBattleTextBuff2, gText_StatRose);
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    BattleStringExpandPlaceholdersToDisplayedString(gText_DefendersStatRose);
}

u8 *UseStatIncreaseItem(u16 itemId)
{
<<<<<<< HEAD
    int i;
    const u8 *itemEffect;

    if (itemId == ITEM_ENIGMA_BERRY)
=======
    const u8 *itemEffect;

    if (itemId == ITEM_ENIGMA_BERRY_E_READER)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        if (gMain.inBattle)
            itemEffect = gEnigmaBerries[gBattlerInMenuId].itemEffect;
        else
<<<<<<< HEAD
            itemEffect = gSaveBlock1Ptr->enigmaBerry.itemEffect;
    }
    else
    {
        if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 0)
            itemEffect = gItemEffectTable_OldSitrus[itemId - ITEM_POTION];
        else if (gSaveBlock1Ptr->tx_Mode_New_Citrus == 1)
            itemEffect = gItemEffectTable[itemId - ITEM_POTION];
=======
        #if FREE_ENIGMA_BERRY == FALSE
            itemEffect = gSaveBlock1Ptr->enigmaBerry.itemEffect;
        #else
            itemEffect = 0;
        #endif //FREE_ENIGMA_BERRY
    }
    else
    {
        itemEffect = GetItemEffect(itemId);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    gPotentialItemEffectBattler = gBattlerInMenuId;

<<<<<<< HEAD
    for (i = 0; i < 3; i++)
    {
        if (itemEffect[i] & (ITEM0_X_ATTACK | ITEM1_X_SPEED | ITEM2_X_SPATK))
            BufferStatRoseMessage(i * 2);

        if (itemEffect[i] & (ITEM0_DIRE_HIT | ITEM1_X_DEFEND | ITEM2_X_ACCURACY))
        {
            if (i != 0) // Dire Hit is the only ITEM0 above
            {
                BufferStatRoseMessage(i * 2 + 1);
            }
            else
            {
                gBattlerAttacker = gBattlerInMenuId;
                BattleStringExpandPlaceholdersToDisplayedString(gText_PkmnGettingPumped);
            }
        }
=======
    if (itemEffect[0] & ITEM0_DIRE_HIT)
    {
        gBattlerAttacker = gBattlerInMenuId;
        BattleStringExpandPlaceholdersToDisplayedString(gText_PkmnGettingPumped);
    }

    switch (itemEffect[1])
    {
        case ITEM1_X_ATTACK:
            BufferStatRoseMessage(STAT_ATK);
            break;
        case ITEM1_X_DEFENSE:
            BufferStatRoseMessage(STAT_DEF);
            break;
        case ITEM1_X_SPEED:
            BufferStatRoseMessage(STAT_SPEED);
            break;
        case ITEM1_X_SPATK:
            BufferStatRoseMessage(STAT_SPATK);
            break;
        case ITEM1_X_SPDEF:
            BufferStatRoseMessage(STAT_SPDEF);
            break;
        case ITEM1_X_ACCURACY:
            BufferStatRoseMessage(STAT_ACC);
            break;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    if (itemEffect[3] & ITEM3_GUARD_SPEC)
    {
        gBattlerAttacker = gBattlerInMenuId;
        BattleStringExpandPlaceholdersToDisplayedString(gText_PkmnShroudedInMist);
    }

    return gDisplayedStringBattle;
}

<<<<<<< HEAD
u8 GetNature(struct Pokemon *mon, bool32 checkHidden)
{
    if (!checkHidden || GetMonData(mon, MON_DATA_HIDDEN_NATURE, 0) == HIDDEN_NATURE_NONE)
        return GetNatureFromPersonality(GetMonData(mon, MON_DATA_PERSONALITY, 0));
    else
        return GetMonData(mon, MON_DATA_HIDDEN_NATURE, 0);
=======
u8 GetNature(struct Pokemon *mon)
{
    return GetMonData(mon, MON_DATA_PERSONALITY, 0) % NUM_NATURES;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

u8 GetNatureFromPersonality(u32 personality)
{
    return personality % NUM_NATURES;
}

<<<<<<< HEAD
u16 GetEvolutionTargetSpecies(struct Pokemon *mon, u8 mode, u16 evolutionItem)
{
    int i, j;
    u16 targetSpecies = 0;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, 0);
    u16 heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, 0);
    u32 personality = GetMonData(mon, MON_DATA_PERSONALITY, 0);
    u8 level;
    u16 friendship;
    u8 beauty = GetMonData(mon, MON_DATA_BEAUTY, 0);
    u16 upperPersonality = personality >> 16;
    u8 holdEffect;

    //tx_randomizer_and_challenges
    if (EvolutionBlockedByEvoLimit(species)) //No Evos already previously checked
        return SPECIES_NONE;
    if (gSaveBlock1Ptr->tx_Random_EvolutionMethods) 
        species = GetSpeciesRandomSeeded(species, TX_RANDOM_T_EVO_METH, 0);
    if (species == SPECIES_NONE)
        return SPECIES_NONE;
    if (heldItem == ITEM_ENIGMA_BERRY)
        holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
    else
        holdEffect = ItemId_GetHoldEffect(heldItem);

    // Prevent evolution with Everstone, unless we're just viewing the party menu with an evolution item
    if (holdEffect == HOLD_EFFECT_PREVENT_EVOLVE && mode != EVO_MODE_ITEM_CHECK)
=======
u32 GetGMaxTargetSpecies(u32 species)
{
    const struct FormChange *formChanges = GetSpeciesFormChanges(species);
    u32 i;
    for (i = 0; formChanges != NULL && formChanges[i].method != FORM_CHANGE_TERMINATOR; i++)
    {
        if (formChanges[i].method == FORM_CHANGE_BATTLE_GIGANTAMAX)
            return formChanges[i].targetSpecies;
    }
    return species;
}

bool32 DoesMonMeetAdditionalConditions(struct Pokemon *mon, const struct EvolutionParam *params, struct Pokemon *tradePartner, u32 partyId, bool32 *canStopEvo, enum EvoState evoState)
{
    u32 i, j;
    u32 heldItem = GetMonData(mon, MON_DATA_HELD_ITEM);
    u32 gender = GetMonGender(mon);
    u32 friendship = GetMonData(mon, MON_DATA_FRIENDSHIP, 0);
    u32 attack = GetMonData(mon, MON_DATA_ATK, 0);
    u32 defense = GetMonData(mon, MON_DATA_DEF, 0);
    u32 personality = GetMonData(mon, MON_DATA_PERSONALITY, 0);
    u16 upperPersonality = personality >> 16;
    u32 weather = GetCurrentWeather();
    u32 nature = GetNature(mon);
    bool32 removeHoldItem = FALSE;
    u32 removeBagItem = ITEM_NONE;
    u32 removeBagItemCount = 0;
    u32 evolutionTracker = GetMonData(mon, MON_DATA_EVOLUTION_TRACKER, 0);
    u32 partnerSpecies, partnerHeldItem;
    enum ItemHoldEffect partnerHoldEffect;

    if (tradePartner != NULL)
    {
        partnerSpecies = GetMonData(tradePartner, MON_DATA_SPECIES, 0);
        partnerHeldItem = GetMonData(tradePartner, MON_DATA_HELD_ITEM, 0);

        if (partnerHeldItem == ITEM_ENIGMA_BERRY_E_READER)
        #if FREE_ENIGMA_BERRY == FALSE
            partnerHoldEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
        #else
            partnerHoldEffect = 0;
        #endif //FREE_ENIGMA_BERRY
        else
            partnerHoldEffect = GetItemHoldEffect(partnerHeldItem);
    }
    else
    {
        partnerSpecies = SPECIES_NONE;
        partnerHeldItem = ITEM_NONE;
        partnerHoldEffect = HOLD_EFFECT_NONE;
    }

    // Check for additional conditions (only if the primary method passes). Skips if there's no additional conditions.
    for (i = 0; params != NULL && params[i].condition != CONDITIONS_END; i++)
    {
        enum EvolutionConditions condition = params[i].condition;
        u32 currentCondition = FALSE;

        switch(condition)
        {
        // Gen 2
        case IF_GENDER:
            if (gender == params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_MIN_FRIENDSHIP:
            if (friendship >= params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_ATK_GT_DEF:
            if (attack > defense)
                currentCondition = TRUE;
            break;
        case IF_ATK_EQ_DEF:
            if (attack == defense)
                currentCondition = TRUE;
            break;
        case IF_ATK_LT_DEF:
            if (attack < defense)
                currentCondition = TRUE;
            break;
        case IF_TIME:
            if (GetTimeOfDay() == params[i].arg1)
                currentCondition = TRUE;

            break;
        case IF_NOT_TIME:
            if (GetTimeOfDay() != params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_HOLD_ITEM:
            if (heldItem == params[i].arg1)
            {
                currentCondition = TRUE;
                removeHoldItem = TRUE;
            }
            break;
        // Gen 3
        case IF_PID_UPPER_MODULO_10_GT:
            if ((upperPersonality % 10) > params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_PID_UPPER_MODULO_10_EQ:
            if ((upperPersonality % 10) == params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_PID_UPPER_MODULO_10_LT:
            if ((upperPersonality % 10) < params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_MIN_BEAUTY:
        {
            u32 beauty = GetMonData(mon, MON_DATA_BEAUTY, 0);
            if (beauty >= params[i].arg1)
                currentCondition = TRUE;
            break;
        }
        case IF_MIN_COOLNESS:
        {
            u32 coolness = GetMonData(mon, MON_DATA_COOL, 0);
            if (coolness >= params[i].arg1)
                currentCondition = TRUE;
            break;
        }
        case IF_MIN_SMARTNESS:
        // remember that even though it's called "Smart/Smartness" here,
        // from gen 6 and up it's known as "Clever/Cleverness."
        {
            u32 smartness = GetMonData(mon, MON_DATA_SMART, 0);
            if (smartness >= params[i].arg1)
                currentCondition = TRUE;
            break;
        }
        case IF_MIN_TOUGHNESS:
        {
            u32 toughness = GetMonData(mon, MON_DATA_TOUGH, 0);
            if (toughness >= params[i].arg1)
                currentCondition = TRUE;
            break;
        }
        case IF_MIN_CUTENESS:
        {
            u32 cuteness = GetMonData(mon, MON_DATA_CUTE, 0);
            if (cuteness >= params[i].arg1)
                currentCondition = TRUE;
            break;
        }
        // Gen 4
        case IF_SPECIES_IN_PARTY:
            for (j = 0; j < PARTY_SIZE; j++)
            {
                if (GetMonData(&gPlayerParty[j], MON_DATA_SPECIES, NULL) == params[i].arg1)
                {
                    currentCondition = TRUE;
                    break;
                }
            }
            break;
        case IF_IN_MAP:
            if (params[i].arg1 == ((gSaveBlock1Ptr->location.mapGroup) << 8 | gSaveBlock1Ptr->location.mapNum))
                currentCondition = TRUE;
            break;
        case IF_IN_MAPSEC:
            if (gMapHeader.regionMapSectionId == params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_KNOWS_MOVE:
            if (MonKnowsMove(mon, params[i].arg1))
                currentCondition = TRUE;
            break;
        // Gen 5
        case IF_TRADE_PARTNER_SPECIES:
            if (params[i].arg1 == partnerSpecies && partnerHoldEffect != HOLD_EFFECT_PREVENT_EVOLVE)
                currentCondition = TRUE;
            break;
        // Gen 6
        case IF_TYPE_IN_PARTY:
            for (j = 0; j < PARTY_SIZE; j++)
            {
                u16 currSpecies = GetMonData(&gPlayerParty[j], MON_DATA_SPECIES, NULL);
                if (GetSpeciesType(currSpecies, 0) == params[i].arg1
                 || GetSpeciesType(currSpecies, 1) == params[i].arg1)
                {
                    currentCondition = TRUE;
                    break;
                }
            }
            break;
        case IF_WEATHER:
            if (params[i].arg1 == WEATHER_RAIN)
            {
                if (weather == WEATHER_RAIN || weather == WEATHER_RAIN_THUNDERSTORM || weather == WEATHER_DOWNPOUR)
                    currentCondition = TRUE;
            }
            else if (params[i].arg1 == WEATHER_FOG)
            {
                if (weather == WEATHER_FOG_DIAGONAL || weather == WEATHER_FOG_HORIZONTAL)
                    currentCondition = TRUE;
            }
            else if (weather == params[i].arg1)
            {
                currentCondition = TRUE;
            }
            break;
        case IF_KNOWS_MOVE_TYPE:
            for (j = 0; j < MAX_MON_MOVES; j++)
            {
                if (GetMoveType(GetMonData(mon, MON_DATA_MOVE1 + j, NULL)) == params[i].arg1)
                {
                    currentCondition = TRUE;
                    break;
                }
            }
            break;
        // Gen 8
        case IF_NATURE:
            if (nature == params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_AMPED_NATURE:
            switch (nature)
            {
            case NATURE_HARDY:
            case NATURE_BRAVE:
            case NATURE_ADAMANT:
            case NATURE_NAUGHTY:
            case NATURE_DOCILE:
            case NATURE_IMPISH:
            case NATURE_LAX:
            case NATURE_HASTY:
            case NATURE_JOLLY:
            case NATURE_NAIVE:
            case NATURE_RASH:
            case NATURE_SASSY:
            case NATURE_QUIRKY:
                currentCondition = TRUE;
                break;
            }
            break;
        case IF_LOW_KEY_NATURE:
            switch (nature)
            {
            case NATURE_LONELY:
            case NATURE_BOLD:
            case NATURE_RELAXED:
            case NATURE_TIMID:
            case NATURE_SERIOUS:
            case NATURE_MODEST:
            case NATURE_MILD:
            case NATURE_QUIET:
            case NATURE_BASHFUL:
            case NATURE_CALM:
            case NATURE_GENTLE:
            case NATURE_CAREFUL:
                currentCondition = TRUE;
                break;
            }
            break;
        case IF_RECOIL_DAMAGE_GE:
            if (evolutionTracker >= params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_CURRENT_DAMAGE_GE:
        {
            u32 currentHp = GetMonData(mon, MON_DATA_HP, NULL);
            if (currentHp != 0 && (GetMonData(mon, MON_DATA_MAX_HP, NULL) - currentHp >= params[i].arg1))
                currentCondition = TRUE;
            break;
        }
        case IF_CRITICAL_HITS_GE:
            if (partyId != PARTY_SIZE && gPartyCriticalHits[partyId] >= params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_USED_MOVE_X_TIMES:
            if (evolutionTracker >= params[i].arg2)
                currentCondition = TRUE;
            break;
        // Gen 9
        case IF_DEFEAT_X_WITH_ITEMS:
            if (evolutionTracker >= params[i].arg3)
                currentCondition = TRUE;
            break;
        case IF_PID_MODULO_100_GT:
            if ((personality % 100) > params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_PID_MODULO_100_EQ:
            if ((personality % 100) == params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_PID_MODULO_100_LT:
            if ((personality % 100) < params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_MIN_OVERWORLD_STEPS:
            if (mon == GetFirstLiveMon() && gFollowerSteps >= params[i].arg1)
                currentCondition = TRUE;
            break;
        case IF_BAG_ITEM_COUNT:
            if (CheckBagHasItem(params[i].arg1, params[i].arg2))
            {
                currentCondition = TRUE;
                removeBagItem = params[i].arg1;
                removeBagItemCount = params[i].arg2;
                if (canStopEvo != NULL)
                    *canStopEvo = FALSE;
            }
            break;
        case CONDITIONS_END:
            break;
        }

        // check if an evolution is about to happen and items should be removed
        if (evoState == DO_EVO)
        {
            if (removeHoldItem)
            {
                u32 heldItem = ITEM_NONE;
                SetMonData(mon, MON_DATA_HELD_ITEM, &heldItem);
            }

            if (removeBagItem != ITEM_NONE)
                RemoveBagItem(removeBagItem, removeBagItemCount);
        }

        if (currentCondition == FALSE)
            return FALSE;
    }

    return TRUE;
}

u32 GetEvolutionTargetSpecies(struct Pokemon *mon, enum EvolutionMode mode, u16 evolutionItem, struct Pokemon *tradePartner, bool32 *canStopEvo, enum EvoState evoState)
{
    int i;
    u32 targetSpecies = SPECIES_NONE;
    u32 species = GetMonData(mon, MON_DATA_SPECIES, 0);
    u32 heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, 0);
    u32 level = GetMonData(mon, MON_DATA_LEVEL, 0);
    u32 holdEffect;
    const struct Evolution *evolutions = GetSpeciesEvolutions(species);

    if (evolutions == NULL)
        return SPECIES_NONE;

    if (heldItem == ITEM_ENIGMA_BERRY_E_READER)
    #if FREE_ENIGMA_BERRY == FALSE
        holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
    #else
        holdEffect = 0;
    #endif //FREE_ENIGMA_BERRY
    else
        holdEffect = GetItemHoldEffect(heldItem);

    // Prevent evolution with Everstone, unless we're just viewing the party menu with an evolution item
    if (holdEffect == HOLD_EFFECT_PREVENT_EVOLVE
        && mode != EVO_MODE_ITEM_CHECK
        && (P_KADABRA_EVERSTONE < GEN_4 || species != SPECIES_KADABRA))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        return SPECIES_NONE;

    switch (mode)
    {
    case EVO_MODE_NORMAL:
<<<<<<< HEAD
        level = GetMonData(mon, MON_DATA_LEVEL, 0);
        friendship = GetMonData(mon, MON_DATA_FRIENDSHIP, 0);

        for (i = 0; i < EVOS_PER_MON; i++)
        {
            switch (gEvolutionTable[species][i].method)
            {
            case EVO_FRIENDSHIP:
                if (friendship >= FRIENDSHIP_EVO_THRESHOLD)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_FRIENDSHIP_DAY:
                UpdateTimeOfDay();
                if (gLocalTime.hours >= 7 && gLocalTime.hours < 20 && friendship >= FRIENDSHIP_EVO_THRESHOLD)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_FRIENDSHIP_NIGHT:
                UpdateTimeOfDay();
                if (gLocalTime.hours >= 0 && gLocalTime.hours < 7 && friendship >= FRIENDSHIP_EVO_THRESHOLD)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                if (gLocalTime.hours >= 20 && gLocalTime.hours < 24 && friendship >= FRIENDSHIP_EVO_THRESHOLD)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL:
                if (gEvolutionTable[species][i].param <= level)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_ATK_GT_DEF:
                if (gEvolutionTable[species][i].param <= level)
                    if (GetMonData(mon, MON_DATA_ATK, 0) > GetMonData(mon, MON_DATA_DEF, 0))
                        targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_ATK_EQ_DEF:
                if (gEvolutionTable[species][i].param <= level)
                    if (GetMonData(mon, MON_DATA_ATK, 0) == GetMonData(mon, MON_DATA_DEF, 0))
                        targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_ATK_LT_DEF:
                if (gEvolutionTable[species][i].param <= level)
                    if (GetMonData(mon, MON_DATA_ATK, 0) < GetMonData(mon, MON_DATA_DEF, 0))
                        targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_SILCOON:
                if (gEvolutionTable[species][i].param <= level && (upperPersonality % 10) <= 4)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_CASCOON:
                if (gEvolutionTable[species][i].param <= level && (upperPersonality % 10) > 4)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_NINJASK:
                if (gEvolutionTable[species][i].param <= level)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_BEAUTY:
                if (gEvolutionTable[species][i].param <= beauty)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_FEMALE:
                if (gEvolutionTable[species][i].param <= level && GetMonGender(mon) == MON_FEMALE)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_MALE:
                if (gEvolutionTable[species][i].param <= level && GetMonGender(mon) == MON_MALE)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_FEMALE_MORNING:
                UpdateTimeOfDay();
                if (gEvolutionTable[species][i].param <= level && GetMonGender(mon) == MON_FEMALE && gLocalTime.hours >= 6 && gLocalTime.hours < 9 && gEvolutionTable[species][i].param <= level)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_MALE_MORNING:
                UpdateTimeOfDay();
                if (gEvolutionTable[species][i].param <= level && GetMonGender(mon) == MON_MALE && gLocalTime.hours >= 6 && gLocalTime.hours < 9 && gEvolutionTable[species][i].param <= level)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_NIGHT:
                UpdateTimeOfDay();
                if (gLocalTime.hours >= 0 && gLocalTime.hours < 7 && gEvolutionTable[species][i].param <= level)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                if (gLocalTime.hours >= 20 && gLocalTime.hours < 24 && gEvolutionTable[species][i].param <= level)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_LEVEL_DAY:
                UpdateTimeOfDay();
                if (gLocalTime.hours >= 7 && gLocalTime.hours < 20 && gEvolutionTable[species][i].param <= level)
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_ITEM_HOLD_NIGHT:
                UpdateTimeOfDay();
                if (gLocalTime.hours >= 0 && gLocalTime.hours < 7 && heldItem == gEvolutionTable[species][i].param)
                {
                    heldItem = 0;
                    SetMonData(mon, MON_DATA_HELD_ITEM, &heldItem);
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                }
                if (gLocalTime.hours >= 20 && gLocalTime.hours < 24 && heldItem == gEvolutionTable[species][i].param)
                {
                    heldItem = 0;
                    SetMonData(mon, MON_DATA_HELD_ITEM, &heldItem);
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                }
                break;
            case EVO_ITEM_HOLD_DAY:
                UpdateTimeOfDay();
                if (gLocalTime.hours >= 7 && gLocalTime.hours < 20 && heldItem == gEvolutionTable[species][i].param)
                {
                    heldItem = 0;
                    SetMonData(mon, MON_DATA_HELD_ITEM, &heldItem);
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                }
                break;
            case EVO_MOVE:
                if (MonKnowsMove(mon, gEvolutionTable[species][i].param))
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_MOVE_TYPE:
                for (j = 0; j < 4; j++)
                {
                    if (gBattleMoves[GetMonData(mon, MON_DATA_MOVE1 + j, NULL)].type == gEvolutionTable[species][i].param)
                    {
                        targetSpecies = gEvolutionTable[species][i].targetSpecies;
                        break;
                    }
                }
                break;
            case EVO_LEVEL_LOCATION:
                {
                    u16 requiredMapsec = gEvolutionTable[species][i].param;
                    if (GetCurrentRegionMapSectionId() == requiredMapsec)
                        targetSpecies = gEvolutionTable[species][i].targetSpecies;
                }
                break;
            case EVO_ITEM_HOLD:
                if (heldItem == gEvolutionTable[species][i].param)
                {
                    heldItem = 0;
                    SetMonData(mon, MON_DATA_HELD_ITEM, &heldItem);
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                }
=======
    case EVO_MODE_BATTLE_ONLY:
        for (i = 0; evolutions[i].method != EVOLUTIONS_END; i++)
        {
            bool32 conditionsMet = FALSE;
            if (SanitizeSpeciesId(evolutions[i].targetSpecies) == SPECIES_NONE)
                continue;

            // Check main primary evolution method
            switch (evolutions[i].method)
            {
            case EVO_LEVEL:
                if (evolutions[i].param <= level)
                    conditionsMet = TRUE;
                break;
            case EVO_LEVEL_BATTLE_ONLY:
                if (mode == EVO_MODE_BATTLE_ONLY && evolutions[i].param <= level)
                    conditionsMet = TRUE;
                break;
            }

            if (conditionsMet && DoesMonMeetAdditionalConditions(mon, evolutions[i].params, NULL, PARTY_SIZE, canStopEvo, evoState))
            {
                // All checks passed, so stop checking the rest of the evolutions.
                // This is different from vanilla where the loop continues.
                // If you have overlapping evolutions, put the ones you want to happen first on top of the list.
                targetSpecies = evolutions[i].targetSpecies;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                break;
            }
        }
        break;
    case EVO_MODE_TRADE:
<<<<<<< HEAD
        for (i = 0; i < EVOS_PER_MON; i++)
        {
            switch (gEvolutionTable[species][i].method)
            {
            case EVO_TRADE:
                targetSpecies = gEvolutionTable[species][i].targetSpecies;
                break;
            case EVO_TRADE_ITEM:
                if (gEvolutionTable[species][i].param == heldItem)
                {
                    heldItem = ITEM_NONE;
                    SetMonData(mon, MON_DATA_HELD_ITEM, &heldItem);
                    targetSpecies = gEvolutionTable[species][i].targetSpecies;
                }
=======
        for (i = 0; evolutions[i].method != EVOLUTIONS_END; i++)
        {
            bool32 conditionsMet = FALSE;
            if (SanitizeSpeciesId(evolutions[i].targetSpecies) == SPECIES_NONE)
                continue;

            switch (evolutions[i].method)
            {
            case EVO_TRADE:
                conditionsMet = TRUE;
                break;
            }

            if (conditionsMet && DoesMonMeetAdditionalConditions(mon, evolutions[i].params, tradePartner, PARTY_SIZE, canStopEvo, evoState))
            {
                // All checks passed, so stop checking the rest of the evolutions.
                // This is different from vanilla where the loop continues.
                // If you have overlapping evolutions, put the ones you want to happen first on top of the list.
                targetSpecies = evolutions[i].targetSpecies;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                break;
            }
        }
        break;
    case EVO_MODE_ITEM_USE:
    case EVO_MODE_ITEM_CHECK:
<<<<<<< HEAD
        for (i = 0; i < EVOS_PER_MON; i++)
        {
            if (gEvolutionTable[species][i].method == EVO_ITEM
             && gEvolutionTable[species][i].param == evolutionItem)
            {
                targetSpecies = gEvolutionTable[species][i].targetSpecies;
=======
        for (i = 0; evolutions[i].method != EVOLUTIONS_END; i++)
        {
            bool32 conditionsMet = FALSE;
            if (SanitizeSpeciesId(evolutions[i].targetSpecies) == SPECIES_NONE)
                continue;

            switch (evolutions[i].method)
            {
            case EVO_ITEM:
                if (evolutions[i].param == evolutionItem)
                    conditionsMet = TRUE;
                break;
            }

            if (conditionsMet && DoesMonMeetAdditionalConditions(mon, evolutions[i].params, NULL, PARTY_SIZE, canStopEvo, evoState))
            {
                // All checks passed, so stop checking the rest of the evolutions.
                // This is different from vanilla where the loop continues.
                // If you have overlapping evolutions, put the ones you want to happen first on top of the list.
                targetSpecies = evolutions[i].targetSpecies;
                if (canStopEvo != NULL)
                    *canStopEvo = FALSE;
                break;
            }
        }
        break;
    // Battle evolution without leveling; party slot is being passed into the evolutionItem arg.
    case EVO_MODE_BATTLE_SPECIAL:
        for (i = 0; evolutions[i].method != EVOLUTIONS_END; i++)
        {
            bool32 conditionsMet = FALSE;
            if (SanitizeSpeciesId(evolutions[i].targetSpecies) == SPECIES_NONE)
                continue;

            switch (evolutions[i].method)
            {
            case EVO_BATTLE_END:
                conditionsMet = TRUE;
                break;
            }

            if (conditionsMet && DoesMonMeetAdditionalConditions(mon, evolutions[i].params, NULL, evolutionItem, canStopEvo, evoState))
            {
                // All checks passed, so stop checking the rest of the evolutions.
                // This is different from vanilla where the loop continues.
                // If you have overlapping evolutions, put the ones you want to happen first on top of the list.
                targetSpecies = evolutions[i].targetSpecies;
                break;
            }
        }
        break;
    // Overworld evolution without leveling; evolution method is being passed into the evolutionItem arg.
    case EVO_MODE_OVERWORLD_SPECIAL:
        for (i = 0; evolutions[i].method != EVOLUTIONS_END; i++)
        {
            bool32 conditionsMet = FALSE;
            if (SanitizeSpeciesId(evolutions[i].targetSpecies) == SPECIES_NONE)
                continue;

            switch (evolutions[i].method)
            {
            case EVO_SPIN:
                if (gSpecialVar_0x8000 == evolutions[i].param)
                    conditionsMet = TRUE;
                break;
            }

            if (conditionsMet && DoesMonMeetAdditionalConditions(mon, evolutions[i].params, NULL, PARTY_SIZE, canStopEvo, evoState))
            {
                // All checks passed, so stop checking the rest of the evolutions.
                // This is different from vanilla where the loop continues.
                // If you have overlapping evolutions, put the ones you want to happen first on top of the list.
                targetSpecies = evolutions[i].targetSpecies;
                break;
            }
        }
        break;
    case EVO_MODE_SCRIPT_TRIGGER:
        for (i = 0; evolutions[i].method != EVOLUTIONS_END; i++)
        {
            if (SanitizeSpeciesId(evolutions[i].targetSpecies) == SPECIES_NONE)
                continue;
            if (evolutions[i].method != EVO_SCRIPT_TRIGGER)
                continue;
            if (DoesMonMeetAdditionalConditions(mon, evolutions[i].params, NULL, PARTY_SIZE, canStopEvo, evoState))
            {
                // All checks passed, so stop checking the rest of the evolutions.
                // This is different from vanilla where the loop continues.
                // If you have overlapping evolutions, put the ones you want to happen first on top of the list.
                targetSpecies = evolutions[i].targetSpecies;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
                break;
            }
        }
        break;
    }

<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Random_Evolutions && targetSpecies != SPECIES_NONE) //tx_randomizer_and_challenges
        targetSpecies = GetSpeciesRandomSeeded(targetSpecies, TX_RANDOM_T_EVO, 0);
=======
    // Pikachu, Meowth, Eevee and Duraludon cannot evolve if they have the
    // Gigantamax Factor. We assume that is because their evolutions
    // do not have a Gigantamax Form.
    if (GetMonData(mon, MON_DATA_GIGANTAMAX_FACTOR, NULL)
     && GetGMaxTargetSpecies(species) != species
     && GetGMaxTargetSpecies(targetSpecies) == targetSpecies)
    {
        return SPECIES_NONE;
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    return targetSpecies;
}

<<<<<<< HEAD
u16 HoennPokedexNumToSpecies(u16 hoennNum)
{
    u16 species;

    if (!hoennNum)
        return 0;

    species = 0;

    while (species < (NUM_SPECIES - 1) && sSpeciesToHoennPokedexNum[species] != hoennNum)
        species++;

    if (species == NUM_SPECIES - 1)
        return 0;

    return species + 1;
}

u16 NationalPokedexNumToSpecies(u16 nationalNum)
=======
bool8 IsMonPastEvolutionLevel(struct Pokemon *mon)
{
    int i;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, 0);
    u8 level = GetMonData(mon, MON_DATA_LEVEL, 0);
    const struct Evolution *evolutions = GetSpeciesEvolutions(species);

    if (evolutions == NULL)
        return FALSE;

    for (i = 0; evolutions[i].method != EVOLUTIONS_END; i++)
    {
        if (SanitizeSpeciesId(evolutions[i].targetSpecies) == SPECIES_NONE)
            continue;

        switch (evolutions[i].method)
        {
        case EVO_LEVEL:
            if (evolutions[i].param <= level)
                return TRUE;
            break;
        }
    }

    return FALSE;
}

u16 NationalPokedexNumToSpecies(enum NationalDexOrder nationalNum)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u16 species;

    if (!nationalNum)
        return 0;

<<<<<<< HEAD
    species = 0;

    while (species < (NUM_SPECIES - 1) && sSpeciesToNationalPokedexNum[species] != nationalNum)
        species++;

    if (species == NUM_SPECIES - 1)
        return 0;

    return species + 1;
}

u16 NationalToHoennOrder(u16 nationalNum)
=======
    species = 1;

    while (species < (NUM_SPECIES) && gSpeciesInfo[species].natDexNum != nationalNum)
        species++;

    if (species == NUM_SPECIES)
        return NATIONAL_DEX_NONE;

    return GET_BASE_SPECIES_ID(species);
}

enum HoennDexOrder NationalToHoennOrder(enum NationalDexOrder nationalNum)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u16 hoennNum;

    if (!nationalNum)
        return 0;

    hoennNum = 0;

<<<<<<< HEAD
    while (hoennNum < (NUM_SPECIES - 1) && sHoennToNationalOrder[hoennNum] != nationalNum)
        hoennNum++;

    if (hoennNum == NUM_SPECIES - 1)
=======
    while (hoennNum < (HOENN_DEX_COUNT - 1) && sHoennToNationalOrder[hoennNum] != nationalNum)
        hoennNum++;

    if (hoennNum >= HOENN_DEX_COUNT - 1)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        return 0;

    return hoennNum + 1;
}

<<<<<<< HEAD
u16 SpeciesToNationalPokedexNum(u16 species)
{
    if (!species)
        return 0;

    return sSpeciesToNationalPokedexNum[species - 1];
}

u16 SpeciesToHoennPokedexNum(u16 species)
{
    if (!species)
        return 0;

    return sSpeciesToHoennPokedexNum[species - 1];
}

u16 HoennToNationalOrder(u16 hoennNum)
{
    if (!hoennNum)
=======
enum NationalDexOrder SpeciesToNationalPokedexNum(u16 species)
{
    species = SanitizeSpeciesId(species);
    if (!species)
        return NATIONAL_DEX_NONE;

    return gSpeciesInfo[species].natDexNum;
}

enum HoennDexOrder SpeciesToHoennPokedexNum(u16 species)
{
    if (!species)
        return 0;
    return NationalToHoennOrder(gSpeciesInfo[species].natDexNum);
}

enum NationalDexOrder HoennToNationalOrder(enum HoennDexOrder hoennNum)
{
    if (!hoennNum || hoennNum >= HOENN_DEX_COUNT)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        return 0;

    return sHoennToNationalOrder[hoennNum - 1];
}

<<<<<<< HEAD
u16 SpeciesToCryId(u16 species)
{
    if (species <= SPECIES_CELEBI - 1)
        return species;

    if (species < SPECIES_TREECKO - 1)
        return SPECIES_UNOWN - 1;

    return gSpeciesIdToCryId[species - (SPECIES_TREECKO - 1)];
}

=======
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
// Spots can be drawn on Spinda's color indexes 1, 2, or 3
#define FIRST_SPOT_COLOR 1
#define LAST_SPOT_COLOR  3

// To draw a spot pixel, add 4 to the color index
#define SPOT_COLOR_ADJUSTMENT 4
/*
<<<<<<< HEAD
    The macro below handles drawing the randomly-placed spots on Spinda's front sprite.
=======
    The function below handles drawing the randomly-placed spots on Spinda's front sprite.
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    Spinda has 4 spots, each with an entry in gSpindaSpotGraphics. Each entry contains
    a base x and y coordinate for the spot and a 16x16 binary image. Each bit in the image
    determines whether that pixel should be considered part of the spot.

    The position of each spot is randomized using the Spinda's personality. The entire 32 bit
    personality value is used, 4 bits for each coordinate of the 4 spots. If the personality
    value is 0x87654321, then 0x1 will be used for the 1st spot's x coord, 0x2 will be used for
    the 1st spot's y coord, 0x3 will be used for the 2nd spot's x coord, and so on. Each
    coordinate is calculated as (baseCoord + (given 4 bits of personality) - 8). In effect this
    means each spot can start at any position -8 to +7 off of its base coordinates (256 possibilities).

<<<<<<< HEAD
    The macro then loops over the 16x16 spot image. For each bit in the spot's binary image, if
    the bit is set then it's part of the spot; try to draw it. A pixel is drawn on Spinda if the
    pixel on Spinda satisfies the following formula: ((u8)(colorIndex - 1) <= 2). The -1 excludes
    transparent pixels, as these are index 0. Therefore only colors 1, 2, or 3 on Spinda will
    allow a spot to be drawn. These color indexes are Spinda's light brown body colors. To create
    the spot it adds 4 to the color index, so Spinda's spots will be colors 5, 6, and 7.

    The above is done two different ways in the macro: one with << 4, and one without. This
    is because Spinda's sprite is a 4 bits per pixel image, but the pointer to Spinda's pixels
    (destPixels) is an 8 bit pointer, so it addresses two pixels. Shifting by 4 accesses the 2nd
    of these pixels, so this is done every other time.
*/
#define DRAW_SPINDA_SPOTS(personality, dest)                                    \
{                                                                               \
    s32 i;                                                                      \
    for (i = 0; i < (s32)ARRAY_COUNT(gSpindaSpotGraphics); i++)                 \
    {                                                                           \
        s32 row;                                                                \
        u8 x = gSpindaSpotGraphics[i].x + ((personality & 0x0F) - 8);           \
        u8 y = gSpindaSpotGraphics[i].y + (((personality & 0xF0) >> 4) - 8);    \
                                                                                \
        for (row = 0; row < SPINDA_SPOT_HEIGHT; row++)                          \
        {                                                                       \
            s32 column;                                                         \
            s32 spotPixelRow = gSpindaSpotGraphics[i].image[row];               \
                                                                                \
            for (column = x; column < x + SPINDA_SPOT_WIDTH; column++)          \
            {                                                                   \
                /* Get target pixels on Spinda's sprite */                      \
                u8 *destPixels = dest + ((column / 8) * TILE_SIZE_4BPP) +       \
                                        ((column % 8) / 2) +                    \
                                             ((y / 8) * TILE_SIZE_4BPP * 8) +   \
                                             ((y % 8) * 4);                     \
                                                                                \
                /* Is this pixel in the 16x16 spot image part of the spot? */   \
                if (spotPixelRow & 1)                                           \
                {                                                               \
                    /* destPixels addressess two pixels, alternate which */     \
                    /* of the two pixels is being considered for drawing */     \
                    if (column & 1)                                             \
                    {                                                           \
                        /* Draw spot pixel if this is Spinda's body color */    \
                        if ((u8)((*destPixels & 0xF0) - (FIRST_SPOT_COLOR << 4))\
                                 <= ((LAST_SPOT_COLOR - FIRST_SPOT_COLOR) << 4))\
                            *destPixels += (SPOT_COLOR_ADJUSTMENT << 4);        \
                    }                                                           \
                    else                                                        \
                    {                                                           \
                        /* Draw spot pixel if this is Spinda's body color */    \
                        if ((u8)((*destPixels & 0xF) - FIRST_SPOT_COLOR)        \
                                 <= (LAST_SPOT_COLOR - FIRST_SPOT_COLOR))       \
                            *destPixels += SPOT_COLOR_ADJUSTMENT;               \
                    }                                                           \
                }                                                               \
                                                                                \
                spotPixelRow >>= 1;                                             \
            }                                                                   \
                                                                                \
            y++;                                                                \
        }                                                                       \
                                                                                \
        personality >>= 8;                                                      \
    }                                                                           \
}

// Same as DrawSpindaSpots but attempts to discern for itself whether or
// not it's the front pic.
static void UNUSED DrawSpindaSpotsUnused(u16 species, u32 personality, u8 *dest)
{
    if (species == SPECIES_SPINDA
        && dest != gMonSpritesGfxPtr->sprites.ptr[B_POSITION_PLAYER_LEFT]
        && dest != gMonSpritesGfxPtr->sprites.ptr[B_POSITION_PLAYER_RIGHT])
        DRAW_SPINDA_SPOTS(personality, dest);
}

void DrawSpindaSpots(u16 species, u32 personality, u8 *dest, bool8 isFrontPic)
{
    if (species == SPECIES_SPINDA && isFrontPic)
        DRAW_SPINDA_SPOTS(personality, dest);
=======
    The function then loops over the 16x16 spot image. For each bit in the spot's binary image, if
    the bit is set then it's part of the spot; try to draw it. A pixel is drawn on Spinda if the
    pixel is between FIRST_SPOT_COLOR and LAST_SPOT_COLOR (so only colors 1, 2, or 3 on Spinda will
    allow a spot to be drawn). These color indexes are Spinda's light brown body colors. To create
    the spot it adds 4 to the color index, so Spinda's spots will be colors 5, 6, and 7.

    The above is done in TRY_DRAW_SPOT_PIXEL two different ways: one with << 4, and one without.
    This is because Spinda's sprite is a 4 bits per pixel image, but the pointer to Spinda's pixels
    (destPixels) is an 8 bit pointer, so it addresses two pixels. Shifting by 4 accesses the 2nd
    of these pixels, so this is done every other time.
*/

// Draw spot pixel if this is Spinda's body color
#define TRY_DRAW_SPOT_PIXEL(pixels, shift) \
    if (((*(pixels) & (0xF << (shift))) >= (FIRST_SPOT_COLOR << (shift))) \
     && ((*(pixels) & (0xF << (shift))) <= (LAST_SPOT_COLOR << (shift)))) \
    { \
        *(pixels) += (SPOT_COLOR_ADJUSTMENT << (shift)); \
    }


void DrawSpindaSpots(u32 personality, u8 *dest, bool32 isSecondFrame)
{
    s32 i;
    for (i = 0; i < (s32)ARRAY_COUNT(gSpindaSpotGraphics); i++)
    {
        s32 row;
        u8 x = gSpindaSpotGraphics[i].x + (personality & 0x0F);
        u8 y = gSpindaSpotGraphics[i].y + ((personality & 0xF0) >> 4);

        if (isSecondFrame)
        {
            x -= 12;
            y += 56;
        }
        else
        {
            x -= 8;
            y -= 8;
        }

        for (row = 0; row < SPINDA_SPOT_HEIGHT; row++)
        {
            s32 column;
            s32 spotPixelRow = gSpindaSpotGraphics[i].image[row];

            for (column = x; column < x + SPINDA_SPOT_WIDTH; column++)
            {
                /* Get target pixels on Spinda's sprite */
                u8 *destPixels = dest + ((column / 8) * TILE_SIZE_4BPP) +
                    ((column % 8) / 2) +
                    ((y / 8) * TILE_SIZE_4BPP * 8) +
                    ((y % 8) * 4);

                /* Is this pixel in the 16x16 spot image part of the spot? */
                if (spotPixelRow & 1)
                {
                    /* destPixels addressess two pixels, alternate which */
                    /* of the two pixels is being considered for drawing */
                    if (column & 1)
                    {
                        /* Draw spot pixel if this is Spinda's body color */
                        TRY_DRAW_SPOT_PIXEL(destPixels, 4);
                    }
                    else
                    {
                        /* Draw spot pixel if this is Spinda's body color */
                        TRY_DRAW_SPOT_PIXEL(destPixels, 0);
                    }
                }

                spotPixelRow >>= 1;
            }

            y++;
        }

        personality >>= 8;
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void EvolutionRenameMon(struct Pokemon *mon, u16 oldSpecies, u16 newSpecies)
{
    u8 language;
    GetMonData(mon, MON_DATA_NICKNAME, gStringVar1);
    language = GetMonData(mon, MON_DATA_LANGUAGE, &language);
<<<<<<< HEAD
    if (language == GAME_LANGUAGE && !StringCompare(gSpeciesNames[oldSpecies], gStringVar1))
        SetMonData(mon, MON_DATA_NICKNAME, gSpeciesNames[newSpecies]);
=======
    if (language == GAME_LANGUAGE && !StringCompare(GetSpeciesName(oldSpecies), gStringVar1))
        SetMonData(mon, MON_DATA_NICKNAME, GetSpeciesName(newSpecies));
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

// The below two functions determine which side of a multi battle the trainer battles on
// 0 is the left (top in  party menu), 1 is right (bottom in party menu)
u8 GetPlayerFlankId(void)
{
    u8 flankId = 0;
    switch (gLinkPlayers[GetMultiplayerId()].id)
    {
    case 0:
    case 3:
        flankId = 0;
        break;
    case 1:
    case 2:
        flankId = 1;
        break;
    }
    return flankId;
}

u16 GetLinkTrainerFlankId(u8 linkPlayerId)
{
    u16 flankId = 0;
    switch (gLinkPlayers[linkPlayerId].id)
    {
    case 0:
    case 3:
        flankId = 0;
        break;
    case 1:
    case 2:
        flankId = 1;
        break;
    }
    return flankId;
}

s32 GetBattlerMultiplayerId(u16 id)
{
    s32 multiplayerId;
    for (multiplayerId = 0; multiplayerId < MAX_LINK_PLAYERS; multiplayerId++)
        if (gLinkPlayers[multiplayerId].id == id)
            break;
    return multiplayerId;
}

u8 GetTrainerEncounterMusicId(u16 trainerOpponentId)
{
<<<<<<< HEAD
    if (InBattlePyramid())
=======
    u32 sanitizedTrainerId = SanitizeTrainerId(trainerOpponentId);
    enum DifficultyLevel difficulty = GetTrainerDifficultyLevel(sanitizedTrainerId);

    if (CurrentBattlePyramidLocation() != PYRAMID_LOCATION_NONE)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        return GetTrainerEncounterMusicIdInBattlePyramid(trainerOpponentId);
    else if (InTrainerHillChallenge())
        return GetTrainerEncounterMusicIdInTrainerHill(trainerOpponentId);
    else
<<<<<<< HEAD
        return TRAINER_ENCOUNTER_MUSIC(trainerOpponentId);
=======
        return gTrainers[difficulty][sanitizedTrainerId].encounterMusic_gender & (F_TRAINER_FEMALE - 1);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

u16 ModifyStatByNature(u8 nature, u16 stat, u8 statIndex)
{
<<<<<<< HEAD
// Because this is a u16 it will be unable to store the
// result of the multiplication for any stat > 595 for a
// positive nature and > 728 for a negative nature.
// Neither occur in the base game, but this can happen if
// any Nature-affected base stat is increased to a value
// above 248. The closest by default is Shuckle at 230.
#ifdef BUGFIX
    u32 retVal;
#else
    u16 retVal;
#endif

    // Don't modify HP, Accuracy, or Evasion by nature
    if (statIndex <= STAT_HP || statIndex > NUM_NATURE_STATS)
        return stat;

    switch (gNatureStatTable[nature][statIndex - 1])
    {
    case 1:
        retVal = stat * 110;
        retVal /= 100;
        break;
    case -1:
        retVal = stat * 90;
        retVal /= 100;
        break;
    default:
        retVal = stat;
        break;
    }

    return retVal;
}

#define IS_LEAGUE_BATTLE                                                                \
    ((gBattleTypeFlags & BATTLE_TYPE_TRAINER)                                           \
    && (gTrainers[gTrainerBattleOpponent_A].trainerClass == TRAINER_CLASS_ELITE_FOUR    \
     || gTrainers[gTrainerBattleOpponent_A].trainerClass == TRAINER_CLASS_LEADER        \
     || gTrainers[gTrainerBattleOpponent_A].trainerClass == TRAINER_CLASS_CHAMPION))    \

=======
    // Don't modify HP, Accuracy, or Evasion by nature
    if (statIndex <= STAT_HP || statIndex > NUM_NATURE_STATS || gNaturesInfo[nature].statUp == gNaturesInfo[nature].statDown)
        return stat;
    else if (statIndex == gNaturesInfo[nature].statUp)
        return stat * 110 / 100;
    else if (statIndex == gNaturesInfo[nature].statDown)
        return stat * 90 / 100;
    else
        return stat;
}

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
void AdjustFriendship(struct Pokemon *mon, u8 event)
{
    u16 species, heldItem;
    u8 holdEffect;
<<<<<<< HEAD
=======
    s8 mod;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    if (ShouldSkipFriendshipChange())
        return;

    species = GetMonData(mon, MON_DATA_SPECIES_OR_EGG, 0);
    heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, 0);

<<<<<<< HEAD
    if (heldItem == ITEM_ENIGMA_BERRY)
=======
    if (heldItem == ITEM_ENIGMA_BERRY_E_READER)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        if (gMain.inBattle)
            holdEffect = gEnigmaBerries[0].holdEffect;
        else
<<<<<<< HEAD
            holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
    }
    else
    {
        holdEffect = ItemId_GetHoldEffect(heldItem);
=======
        #if FREE_ENIGMA_BERRY == FALSE
            holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
        #else
            holdEffect = 0;
        #endif //FREE_ENIGMA_BERRY
    }
    else
    {
        holdEffect = GetItemHoldEffect(heldItem);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }

    if (species && species != SPECIES_EGG)
    {
        u8 friendshipLevel = 0;
        s16 friendship = GetMonData(mon, MON_DATA_FRIENDSHIP, 0);
<<<<<<< HEAD
=======
        enum TrainerClassID opponentTrainerClass = GetTrainerClassFromId(TRAINER_BATTLE_PARAM.opponentA);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

        if (friendship > 99)
            friendshipLevel++;
        if (friendship > 199)
            friendshipLevel++;

<<<<<<< HEAD
        if ((event != FRIENDSHIP_EVENT_WALKING || !(Random() & 1))
         && (event != FRIENDSHIP_EVENT_LEAGUE_BATTLE || IS_LEAGUE_BATTLE))
        {
            s16 mod = sFriendshipEventModifiers[event][friendshipLevel];
            if (mod > 0 && holdEffect == HOLD_EFFECT_FRIENDSHIP_UP)
                mod = (150 * mod) / 100;
            friendship += mod;
            if (mod > 0)
            {
                if (GetMonData(mon, MON_DATA_POKEBALL, 0) == ITEM_LUXURY_BALL)
                    friendship++;
                if (GetMonData(mon, MON_DATA_MET_LOCATION, 0) == GetCurrentRegionMapSectionId())
                    friendship++;
            }
            if (friendship < 0)
                friendship = 0;
            if (friendship > MAX_FRIENDSHIP)
                friendship = MAX_FRIENDSHIP;
            SetMonData(mon, MON_DATA_FRIENDSHIP, &friendship);
        }
=======
        if (event == FRIENDSHIP_EVENT_WALKING)
        {
            // 50% chance every 128 steps
            if (Random() & 1)
                return;
        }
        if (event == FRIENDSHIP_EVENT_LEAGUE_BATTLE)
        {
            // Only if it's a trainer battle with league progression significance
            if (!(gBattleTypeFlags & BATTLE_TYPE_TRAINER))
                return;
            if (!(opponentTrainerClass == TRAINER_CLASS_LEADER
                || opponentTrainerClass == TRAINER_CLASS_ELITE_FOUR
                || opponentTrainerClass == TRAINER_CLASS_CHAMPION))
                return;
        }

        mod = sFriendshipEventModifiers[event][friendshipLevel];
        if (mod > 0 && holdEffect == HOLD_EFFECT_FRIENDSHIP_UP)
            // 50% increase, rounding down
            mod = (150 * mod) / 100;

        friendship += mod;
        if (mod > 0)
        {
            if (GetMonData(mon, MON_DATA_POKEBALL, NULL) == ITEM_LUXURY_BALL)
                friendship++;
            if (GetMonData(mon, MON_DATA_MET_LOCATION, NULL) == GetCurrentRegionMapSectionId())
                friendship++;
        }

        if (friendship < 0)
            friendship = 0;
        if (friendship > MAX_FRIENDSHIP)
            friendship = MAX_FRIENDSHIP;

        SetMonData(mon, MON_DATA_FRIENDSHIP, &friendship);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }
}

void MonGainEVs(struct Pokemon *mon, u16 defeatedSpecies)
{
    u8 evs[NUM_STATS];
    u16 evIncrease = 0;
    u16 totalEVs = 0;
    u16 heldItem;
    u8 holdEffect;
    int i, multiplier;
<<<<<<< HEAD

    if (gSaveBlock1Ptr->tx_Challenges_NoEVs && !FlagGet(FLAG_IS_CHAMPION))
        return;
=======
    u8 stat;
    u8 bonus;
    u32 currentEVCap = GetCurrentEVCap();

    heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, 0);
    if (heldItem == ITEM_ENIGMA_BERRY_E_READER)
    {
        if (gMain.inBattle)
            holdEffect = gEnigmaBerries[0].holdEffect;
        else
        #if FREE_ENIGMA_BERRY == FALSE
            holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
        #else
            holdEffect = 0;
        #endif //FREE_ENIGMA_BERRY
    }
    else
    {
        holdEffect = GetItemHoldEffect(heldItem);
    }

    stat = GetItemSecondaryId(heldItem);
    bonus = GetItemHoldEffectParam(heldItem);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    for (i = 0; i < NUM_STATS; i++)
    {
        evs[i] = GetMonData(mon, MON_DATA_HP_EV + i, 0);
        totalEVs += evs[i];
    }

    for (i = 0; i < NUM_STATS; i++)
    {
<<<<<<< HEAD
        if (totalEVs >= MAX_TOTAL_EVS)
=======
        if (totalEVs >= currentEVCap)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            break;

        if (CheckPartyHasHadPokerus(mon, 0))
            multiplier = 2;
        else
            multiplier = 1;

        switch (i)
        {
        case STAT_HP:
<<<<<<< HEAD
            evIncrease = gSpeciesInfo[defeatedSpecies].evYield_HP * multiplier;
            break;
        case STAT_ATK:
            evIncrease = gSpeciesInfo[defeatedSpecies].evYield_Attack * multiplier;
            break;
        case STAT_DEF:
            evIncrease = gSpeciesInfo[defeatedSpecies].evYield_Defense * multiplier;
            break;
        case STAT_SPEED:
            evIncrease = gSpeciesInfo[defeatedSpecies].evYield_Speed * multiplier;
            break;
        case STAT_SPATK:
            evIncrease = gSpeciesInfo[defeatedSpecies].evYield_SpAttack * multiplier;
            break;
        case STAT_SPDEF:
            evIncrease = gSpeciesInfo[defeatedSpecies].evYield_SpDefense * multiplier;
            break;
        }

        heldItem = GetMonData(mon, MON_DATA_HELD_ITEM, 0);
        if (heldItem == ITEM_ENIGMA_BERRY)
        {
            if (gMain.inBattle)
                holdEffect = gEnigmaBerries[0].holdEffect;
            else
                holdEffect = gSaveBlock1Ptr->enigmaBerry.holdEffect;
        }
        else
        {
            holdEffect = ItemId_GetHoldEffect(heldItem);
        }

        if (holdEffect == HOLD_EFFECT_MACHO_BRACE)
            evIncrease *= 5;

        if (totalEVs + (s16)evIncrease > MAX_TOTAL_EVS)
            evIncrease = ((s16)evIncrease + MAX_TOTAL_EVS) - (totalEVs + evIncrease);
=======
            if (holdEffect == HOLD_EFFECT_POWER_ITEM && stat == STAT_HP)
                evIncrease = (gSpeciesInfo[defeatedSpecies].evYield_HP + bonus) * multiplier;
            else
                evIncrease = gSpeciesInfo[defeatedSpecies].evYield_HP * multiplier;
            break;
        case STAT_ATK:
            if (holdEffect == HOLD_EFFECT_POWER_ITEM && stat == STAT_ATK)
                evIncrease = (gSpeciesInfo[defeatedSpecies].evYield_Attack + bonus) * multiplier;
            else
                evIncrease = gSpeciesInfo[defeatedSpecies].evYield_Attack * multiplier;
            break;
        case STAT_DEF:
            if (holdEffect == HOLD_EFFECT_POWER_ITEM && stat == STAT_DEF)
                evIncrease = (gSpeciesInfo[defeatedSpecies].evYield_Defense + bonus) * multiplier;
            else
                evIncrease = gSpeciesInfo[defeatedSpecies].evYield_Defense * multiplier;
            break;
        case STAT_SPEED:
            if (holdEffect == HOLD_EFFECT_POWER_ITEM && stat == STAT_SPEED)
                evIncrease = (gSpeciesInfo[defeatedSpecies].evYield_Speed + bonus) * multiplier;
            else
                evIncrease = gSpeciesInfo[defeatedSpecies].evYield_Speed * multiplier;
            break;
        case STAT_SPATK:
            if (holdEffect == HOLD_EFFECT_POWER_ITEM && stat == STAT_SPATK)
                evIncrease = (gSpeciesInfo[defeatedSpecies].evYield_SpAttack + bonus) * multiplier;
            else
                evIncrease = gSpeciesInfo[defeatedSpecies].evYield_SpAttack * multiplier;
            break;
        case STAT_SPDEF:
            if (holdEffect == HOLD_EFFECT_POWER_ITEM && stat == STAT_SPDEF)
                evIncrease = (gSpeciesInfo[defeatedSpecies].evYield_SpDefense + bonus) * multiplier;
            else
                evIncrease = gSpeciesInfo[defeatedSpecies].evYield_SpDefense * multiplier;
            break;
        }

        if (holdEffect == HOLD_EFFECT_MACHO_BRACE)
            evIncrease *= 2;

        if (totalEVs + (s16)evIncrease > currentEVCap)
            evIncrease = ((s16)evIncrease + currentEVCap) - (totalEVs + evIncrease);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

        if (evs[i] + (s16)evIncrease > MAX_PER_STAT_EVS)
        {
            int val1 = (s16)evIncrease + MAX_PER_STAT_EVS;
            int val2 = evs[i] + evIncrease;
            evIncrease = val1 - val2;
        }

        evs[i] += evIncrease;
        totalEVs += evIncrease;
        SetMonData(mon, MON_DATA_HP_EV + i, &evs[i]);
    }
}

u16 GetMonEVCount(struct Pokemon *mon)
{
    int i;
    u16 count = 0;

    for (i = 0; i < NUM_STATS; i++)
        count += GetMonData(mon, MON_DATA_HP_EV + i, 0);

    return count;
}

void RandomlyGivePartyPokerus(struct Pokemon *party)
{
    u16 rnd = Random();
    if (rnd == 0x4000 || rnd == 0x8000 || rnd == 0xC000)
    {
        struct Pokemon *mon;

        do
        {
<<<<<<< HEAD
            do
            {
                rnd = Random() % PARTY_SIZE;
                mon = &party[rnd];
            }
            while (!GetMonData(mon, MON_DATA_SPECIES, 0));
        }
        while (GetMonData(mon, MON_DATA_IS_EGG, 0));

        if (!(CheckPartyHasHadPokerus(party, gBitTable[rnd])))
=======
            rnd = Random() % PARTY_SIZE;
            mon = &party[rnd];
        }
        while (!GetMonData(mon, MON_DATA_SPECIES, 0) || GetMonData(mon, MON_DATA_IS_EGG, 0));

        if (!(CheckPartyHasHadPokerus(party, 1u << rnd)))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        {
            u8 rnd2;

            do
            {
                rnd2 = Random();
            }
            while ((rnd2 & 0x7) == 0);

            if (rnd2 & 0xF0)
                rnd2 &= 0x7;

            rnd2 |= (rnd2 << 4);
            rnd2 &= 0xF3;
            rnd2++;

            SetMonData(&party[rnd], MON_DATA_POKERUS, &rnd2);
        }
    }
}

u8 CheckPartyPokerus(struct Pokemon *party, u8 selection)
{
    u8 retVal;

    int partyIndex = 0;
    unsigned curBit = 1;
    retVal = 0;

    if (selection)
    {
        do
        {
            if ((selection & 1) && (GetMonData(&party[partyIndex], MON_DATA_POKERUS, 0) & 0xF))
                retVal |= curBit;
            partyIndex++;
            curBit <<= 1;
            selection >>= 1;
        }
        while (selection);
    }
    else if (GetMonData(&party[0], MON_DATA_POKERUS, 0) & 0xF)
    {
        retVal = 1;
    }

    return retVal;
}

u8 CheckPartyHasHadPokerus(struct Pokemon *party, u8 selection)
{
    u8 retVal;

    int partyIndex = 0;
    unsigned curBit = 1;
    retVal = 0;

    if (selection)
    {
        do
        {
            if ((selection & 1) && GetMonData(&party[partyIndex], MON_DATA_POKERUS, 0))
                retVal |= curBit;
            partyIndex++;
            curBit <<= 1;
            selection >>= 1;
        }
        while (selection);
    }
    else if (GetMonData(&party[0], MON_DATA_POKERUS, 0))
    {
        retVal = 1;
    }

    return retVal;
}

void UpdatePartyPokerusTime(u16 days)
{
    int i;
    for (i = 0; i < PARTY_SIZE; i++)
    {
        if (GetMonData(&gPlayerParty[i], MON_DATA_SPECIES, 0))
        {
            u8 pokerus = GetMonData(&gPlayerParty[i], MON_DATA_POKERUS, 0);
            if (pokerus & 0xF)
            {
                if ((pokerus & 0xF) < days || days > 4)
                    pokerus &= 0xF0;
                else
                    pokerus -= days;

                if (pokerus == 0)
                    pokerus = 0x10;

                SetMonData(&gPlayerParty[i], MON_DATA_POKERUS, &pokerus);
            }
        }
    }
}

void PartySpreadPokerus(struct Pokemon *party)
{
    if ((Random() % 3) == 0)
    {
        int i;
        for (i = 0; i < PARTY_SIZE; i++)
        {
            if (GetMonData(&party[i], MON_DATA_SPECIES, 0))
            {
                u8 pokerus = GetMonData(&party[i], MON_DATA_POKERUS, 0);
                u8 curPokerus = pokerus;
                if (pokerus)
                {
                    if (pokerus & 0xF)
                    {
                        // Spread to adjacent party members.
                        if (i != 0 && !(GetMonData(&party[i - 1], MON_DATA_POKERUS, 0) & 0xF0))
                            SetMonData(&party[i - 1], MON_DATA_POKERUS, &curPokerus);
                        if (i != (PARTY_SIZE - 1) && !(GetMonData(&party[i + 1], MON_DATA_POKERUS, 0) & 0xF0))
                        {
                            SetMonData(&party[i + 1], MON_DATA_POKERUS, &curPokerus);
                            i++;
                        }
                    }
                }
            }
        }
    }
}

bool8 TryIncrementMonLevel(struct Pokemon *mon)
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES, 0);
    u8 nextLevel = GetMonData(mon, MON_DATA_LEVEL, 0) + 1;
    u32 expPoints = GetMonData(mon, MON_DATA_EXP, 0);
<<<<<<< HEAD
    if (expPoints > gExperienceTables[gSpeciesInfo[species].growthRate][GetCurrentPartyLevelCap()])
    {
        expPoints = gExperienceTables[gSpeciesInfo[species].growthRate][GetCurrentPartyLevelCap()];
        SetMonData(mon, MON_DATA_EXP, &expPoints);
    }
    if (nextLevel > GetCurrentPartyLevelCap() || expPoints < gExperienceTables[gSpeciesInfo[species].growthRate][nextLevel])
=======
    if (expPoints > gExperienceTables[gSpeciesInfo[species].growthRate][MAX_LEVEL])
    {
        expPoints = gExperienceTables[gSpeciesInfo[species].growthRate][MAX_LEVEL];
        SetMonData(mon, MON_DATA_EXP, &expPoints);
    }
    if (nextLevel > GetCurrentLevelCap() || expPoints < gExperienceTables[gSpeciesInfo[species].growthRate][nextLevel])
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        return FALSE;
    }
    else
    {
        SetMonData(mon, MON_DATA_LEVEL, &nextLevel);
        return TRUE;
    }
}

<<<<<<< HEAD
u32 CanMonLearnTMHM(struct Pokemon *mon, u8 tm)
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES_OR_EGG, 0);
    //tx_randomizer_and_challenges
    if (gSaveBlock1Ptr->tx_Random_Moves)
        species = GetSpeciesRandomSeeded(species, TX_RANDOM_T_MOVES, 0);

    if (species == SPECIES_EGG)
    {
        return 0;
    }

    // Fewer than 64 moves, use GF's method (for matching).
    if (sizeof(struct TMHMLearnset) <= 8)
    {
        if (tm < 32)
        {
            u32 mask = 1 << tm;
            return gTMHMLearnsets[species].as_u32s[0] & mask;
        }
        else
        {
            u32 mask = 1 << (tm - 32);
            return gTMHMLearnsets[species].as_u32s[1] & mask;
=======
static const u16 sUniversalMoves[] =
{
    MOVE_BIDE,
    MOVE_FRUSTRATION,
    MOVE_HIDDEN_POWER,
    MOVE_MIMIC,
    MOVE_NATURAL_GIFT,
    MOVE_RAGE,
    MOVE_RETURN,
    MOVE_SECRET_POWER,
    MOVE_SUBSTITUTE,
    MOVE_TERA_BLAST,
};

u8 CanLearnTeachableMove(u16 species, u16 move)
{
    if (species == SPECIES_EGG)
    {
        return FALSE;
    }
    else if (species == SPECIES_MEW)
    {
        switch (move)
        {
        case MOVE_BADDY_BAD:
        case MOVE_BOUNCY_BUBBLE:
        case MOVE_BUZZY_BUZZ:
        case MOVE_DRAGON_ASCENT:
        case MOVE_FLOATY_FALL:
        case MOVE_FREEZY_FROST:
        case MOVE_GLITZY_GLOW:
        case MOVE_RELIC_SONG:
        case MOVE_SAPPY_SEED:
        case MOVE_SECRET_SWORD:
        case MOVE_SIZZLY_SLIDE:
        case MOVE_SPARKLY_SWIRL:
        case MOVE_SPLISHY_SPLASH:
        case MOVE_VOLT_TACKLE:
        case MOVE_ZIPPY_ZAP:
            return FALSE;
        default:
            return TRUE;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        }
    }
    else
    {
<<<<<<< HEAD
        u32 index = tm / 32;
        u32 mask = 1 << (tm % 32);
        return gTMHMLearnsets[species].as_u32s[index] & mask;
    }
}

u32 CanSpeciesLearnTMHM(u16 species, u8 tm)
{
    //tx_randomizer_and_challenges
    if (gSaveBlock1Ptr->tx_Random_Moves)
        species = GetSpeciesRandomSeeded(species, TX_RANDOM_T_MOVES, 0);

    if (species == SPECIES_EGG)
    {
        return 0;
    }
    // Fewer than 64 moves, use GF's method (for matching).
    if (sizeof(struct TMHMLearnset) <= 8)
    {
        if (tm < 32)
        {
            u32 mask = 1 << tm;
            return gTMHMLearnsets[species].as_u32s[0] & mask;
        }
        else
        {
            u32 mask = 1 << (tm - 32);
            return gTMHMLearnsets[species].as_u32s[1] & mask;
        }
    }
    else
    {
        u32 index = tm / 32;
        u32 mask = 1 << (tm % 32);
        return gTMHMLearnsets[species].as_u32s[index] & mask;
    }
}

static u16 GetPreEvolution(u16 species){
    int i, j;

    for (i = 1; i < NUM_SPECIES; i++)
    {
        for (j = 0; j < EVOS_PER_MON; j++)
        {
            if (gEvolutionTable[i][j].targetSpecies == species)
                return i;
        }
    }
    return SPECIES_NONE;
=======
        u32 i, j;
        const u16 *teachableLearnset = GetSpeciesTeachableLearnset(species);
        for (i = 0; i < ARRAY_COUNT(sUniversalMoves); i++)
        {
            if (sUniversalMoves[i] == move)
            {
                if (!gSpeciesInfo[species].tmIlliterate)
                {
                    if (move == MOVE_TERA_BLAST && GET_BASE_SPECIES_ID(species) == SPECIES_TERAPAGOS)
                        return FALSE;
                    if (GET_BASE_SPECIES_ID(species) == SPECIES_PYUKUMUKU && (move == MOVE_HIDDEN_POWER || move == MOVE_RETURN || move == MOVE_FRUSTRATION))
                        return FALSE;
                    return TRUE;
                }
                else
                {
                    const struct LevelUpMove *learnset = GetSpeciesLevelUpLearnset(species);

                    if (P_TM_LITERACY < GEN_6)
                        return FALSE;

                    for (j = 0; j < MAX_LEVEL_UP_MOVES && learnset[j].move != LEVEL_UP_MOVE_END; j++)
                    {
                        if (learnset[j].move == move)
                            return TRUE;
                    }
                    return FALSE;
                }
            }
        }
        for (i = 0; teachableLearnset[i] != MOVE_UNAVAILABLE; i++)
        {
            if (teachableLearnset[i] == move)
                return TRUE;
        }
        return FALSE;
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

u8 GetMoveRelearnerMoves(struct Pokemon *mon, u16 *moves)
{
<<<<<<< HEAD
    u16 learnedMoves[MAX_MON_MOVES];
    u8 numMoves = 0;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, 0);
    u8 level = GetMonData(mon, MON_DATA_LEVEL, 0);
    u8 preEvLvl = (level > MAX_LEVEL_DIFF_PRE_EV) ? (level - MAX_LEVEL_DIFF_PRE_EV) : 1;
    int i, j, k;
    u16 move;
=======
    u16 learnedMoves[4];
    u8 numMoves = 0;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, 0);
    u8 level = GetMonData(mon, MON_DATA_LEVEL, 0);
    const struct LevelUpMove *learnset = GetSpeciesLevelUpLearnset(species);
    int i, j, k;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

    for (i = 0; i < MAX_MON_MOVES; i++)
        learnedMoves[i] = GetMonData(mon, MON_DATA_MOVE1 + i, 0);

<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Mode_Modern_Moves == 0)
    {
        for (i = 0; i < MAX_LEVEL_UP_MOVES; i++)
        {
            u16 moveLevel;

            if (gLevelUpLearnsets_Original[species][i] == LEVEL_UP_END)
            {
                i = 0;
                level = preEvLvl;
                species = GetPreEvolution(species);
            }

            if (species == SPECIES_NONE)
                break;

            moveLevel = gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_LV;

            if (moveLevel <= (level << 9))
            {
                for (j = 0; j < MAX_MON_MOVES && learnedMoves[j] != (gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID); j++)
                    ;

                if (j == MAX_MON_MOVES)
                {
                    for (k = 0; k < numMoves && moves[k] != (gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID); k++)
                        ;

                    if (k == numMoves)
                    {
                        //tx_randomizer_and_challenges
                        move = gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID;
                        if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
                            move = GetRandomMove(move, species);
                        moves[numMoves++] = move;
                    }
                }
            }
        }
    }
    else
    {
        for (i = 0; i < MAX_LEVEL_UP_MOVES; i++)
        {
            u16 moveLevel;

            if (gLevelUpLearnsets[species][i] == LEVEL_UP_END)
            {
                i = 0;
                level = preEvLvl;
                species = GetPreEvolution(species);
            }

            if (species == SPECIES_NONE)
                break;

            moveLevel = gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_LV;

            if (moveLevel <= (level << 9))
            {
                for (j = 0; j < MAX_MON_MOVES && learnedMoves[j] != (gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID); j++)
                    ;

                if (j == MAX_MON_MOVES)
                {
                    for (k = 0; k < numMoves && moves[k] != (gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID); k++)
                        ;

                    if (k == numMoves)
                    {
                        //tx_randomizer_and_challenges
                        move = gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID;
                        if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
                            move = GetRandomMove(move, species);
                        moves[numMoves++] = move;
                    }
                }
=======
    for (i = 0; i < MAX_LEVEL_UP_MOVES; i++)
    {
        u16 moveLevel;

        if (learnset[i].move == LEVEL_UP_MOVE_END)
            break;

        moveLevel = learnset[i].level;

        if (moveLevel <= level)
        {
            for (j = 0; j < MAX_MON_MOVES && learnedMoves[j] != learnset[i].move; j++)
                ;

            if (j == MAX_MON_MOVES)
            {
                for (k = 0; k < numMoves && moves[k] != learnset[i].move; k++)
                    ;

                if (k == numMoves)
                    moves[numMoves++] = learnset[i].move;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            }
        }
    }

    return numMoves;
}

u8 GetLevelUpMovesBySpecies(u16 species, u16 *moves)
{
    u8 numMoves = 0;
    int i;
<<<<<<< HEAD
    u16 move; //tx_randomizer_and_challenges

    if (gSaveBlock1Ptr->tx_Mode_Modern_Moves == 0)
    {
        for (i = 0; i < MAX_LEVEL_UP_MOVES && gLevelUpLearnsets_Original[species][i] != LEVEL_UP_END; i++)
        { 
            //tx_randomizer_and_challenges
            move = gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID;
            if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
                move = GetRandomMove(move, species);
            moves[numMoves++] = move;
        }
    }
    else
    {
        for (i = 0; i < MAX_LEVEL_UP_MOVES && gLevelUpLearnsets[species][i] != LEVEL_UP_END; i++)
        { 
            //tx_randomizer_and_challenges
            move = gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID;
            if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
                move = GetRandomMove(move, species);
            moves[numMoves++] = move;
        }
    }
=======
    const struct LevelUpMove *learnset = GetSpeciesLevelUpLearnset(species);

    for (i = 0; i < MAX_LEVEL_UP_MOVES && learnset[i].move != LEVEL_UP_MOVE_END; i++)
         moves[numMoves++] = learnset[i].move;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

     return numMoves;
}

u8 GetNumberOfRelearnableMoves(struct Pokemon *mon)
{
    u16 learnedMoves[MAX_MON_MOVES];
    u16 moves[MAX_LEVEL_UP_MOVES];
    u8 numMoves = 0;
    u16 species = GetMonData(mon, MON_DATA_SPECIES_OR_EGG, 0);
    u8 level = GetMonData(mon, MON_DATA_LEVEL, 0);
<<<<<<< HEAD
    u8 preEvLvl = (level > MAX_LEVEL_DIFF_PRE_EV) ? (level - MAX_LEVEL_DIFF_PRE_EV) : 1;
    int i, j, k;

    if (gSaveBlock1Ptr->tx_Random_Moves) //tx_randomizer_and_challenges
        species = GetSpeciesRandomSeeded(species, TX_RANDOM_T_MOVES, 0);

=======
    const struct LevelUpMove *learnset = GetSpeciesLevelUpLearnset(species);
    int i, j, k;

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    if (species == SPECIES_EGG)
        return 0;

    for (i = 0; i < MAX_MON_MOVES; i++)
        learnedMoves[i] = GetMonData(mon, MON_DATA_MOVE1 + i, 0);

<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Mode_Modern_Moves == 0)
    {
        for (i = 0; i < MAX_LEVEL_UP_MOVES; i++)
        {
            u16 moveLevel;

            if (gLevelUpLearnsets_Original[species][i] == LEVEL_UP_END)
            {
                i = 0;
                level = preEvLvl;
                species = GetPreEvolution(species);
            }

            if (species == SPECIES_NONE)
                break;

            moveLevel = gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_LV;

            if (moveLevel <= (level << 9))
            {
                for (j = 0; j < MAX_MON_MOVES && learnedMoves[j] != (gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID); j++)
                    ;

                if (j == MAX_MON_MOVES)
                {
                    for (k = 0; k < numMoves && moves[k] != (gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID); k++)
                        ;

                    if (k == numMoves)
                        moves[numMoves++] = gLevelUpLearnsets_Original[species][i] & LEVEL_UP_MOVE_ID;
                }
            }
        }
    }
    else
    {
        for (i = 0; i < MAX_LEVEL_UP_MOVES; i++)
        {
            u16 moveLevel;

            if (gLevelUpLearnsets[species][i] == LEVEL_UP_END)
            {
                i = 0;
                level = preEvLvl;
                species = GetPreEvolution(species);
            }

            if (species == SPECIES_NONE)
                break;

            moveLevel = gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_LV;

            if (moveLevel <= (level << 9))
            {
                for (j = 0; j < MAX_MON_MOVES && learnedMoves[j] != (gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID); j++)
                    ;

                if (j == MAX_MON_MOVES)
                {
                    for (k = 0; k < numMoves && moves[k] != (gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID); k++)
                        ;

                    if (k == numMoves)
                        moves[numMoves++] = gLevelUpLearnsets[species][i] & LEVEL_UP_MOVE_ID;
                }
=======
    for (i = 0; i < MAX_LEVEL_UP_MOVES; i++)
    {
        u16 moveLevel;

        if (learnset[i].move == LEVEL_UP_MOVE_END)
            break;

        moveLevel = learnset[i].level;

        if (moveLevel <= level)
        {
            for (j = 0; j < MAX_MON_MOVES && learnedMoves[j] != learnset[i].move; j++)
                ;

            if (j == MAX_MON_MOVES)
            {
                for (k = 0; k < numMoves && moves[k] != learnset[i].move; k++)
                    ;

                if (k == numMoves)
                    moves[numMoves++] = learnset[i].move;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            }
        }
    }

    return numMoves;
}

u16 SpeciesToPokedexNum(u16 species)
{
    if (IsNationalPokedexEnabled())
    {
        return SpeciesToNationalPokedexNum(species);
    }
    else
    {
        species = SpeciesToHoennPokedexNum(species);
        if (species <= HOENN_DEX_COUNT)
            return species;
        return 0xFFFF;
    }
}

bool32 IsSpeciesInHoennDex(u16 species)
{
    if (SpeciesToHoennPokedexNum(species) > HOENN_DEX_COUNT)
        return FALSE;
    else
        return TRUE;
}

<<<<<<< HEAD
void ClearBattleMonForms(void)
{
    int i;
    for (i = 0; i < MAX_BATTLERS_COUNT; i++)
        gBattleMonForms[i] = 0;
}

u16 GetBattleBGM(void)
{
    if (FlagGet(FLAG_SYS_SET_BATTLE_BGM)){
        FlagClear(FLAG_SYS_SET_BATTLE_BGM);
        return VarGet(VAR_TEMP_F);
    }
    if (gBattleTypeFlags & BATTLE_TYPE_KYOGRE_GROUDON)
        return MUS_VS_KYOGRE_GROUDON;
    else if (gBattleTypeFlags & BATTLE_TYPE_REGI)
        return MUS_VS_REGI;
    else if (gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_RECORDED_LINK))
        return MUS_HG_VS_TRAINER;
    else if (gBattleTypeFlags & BATTLE_TYPE_ROAMER)
     {
         // Distinguish which roamer we just ran into.
         // Enemy party should already be populated for the encounter.
         u16 species = GetMonData(&gEnemyParty[0], MON_DATA_SPECIES);
         switch (species)
         {
         case SPECIES_RAIKOU:
             return MUS_HG_VS_RAIKOU;   // Raikou theme
         case SPECIES_ENTEI:
             return MUS_HG_VS_ENTEI;    // Entei theme
         default:
             // Fallback to existing behavior if species couldn't be read.
             return MUS_HG_VS_ENTEI;
         }
     }
    else if (gBattleTypeFlags & BATTLE_TYPE_TRAINER)
    {
        u8 trainerClass;

        if (gBattleTypeFlags & BATTLE_TYPE_FRONTIER)
            trainerClass = GetFrontierOpponentClass(gTrainerBattleOpponent_A);
        else if (gBattleTypeFlags & BATTLE_TYPE_TRAINER_HILL)
            trainerClass = TRAINER_CLASS_EXPERT;
        else
            trainerClass = gTrainers[gTrainerBattleOpponent_A].trainerClass;
=======
u16 GetBattleBGM(void)
{
    if (gBattleTypeFlags & BATTLE_TYPE_LEGENDARY)
    {
        switch (GetMonData(&gEnemyParty[0], MON_DATA_SPECIES, NULL))
        {
        case SPECIES_RAYQUAZA:
            return MUS_VS_RAYQUAZA;
        case SPECIES_KYOGRE:
        case SPECIES_GROUDON:
            return MUS_VS_KYOGRE_GROUDON;
        case SPECIES_REGIROCK:
        case SPECIES_REGICE:
        case SPECIES_REGISTEEL:
        case SPECIES_REGIGIGAS:
        case SPECIES_REGIELEKI:
        case SPECIES_REGIDRAGO:
            return MUS_VS_REGI;
        default:
            return MUS_RG_VS_LEGEND;
        }
    }
    else if (gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_RECORDED_LINK))
    {
        return MUS_VS_TRAINER;
    }
    else if (gBattleTypeFlags & BATTLE_TYPE_TRAINER)
    {
        enum TrainerClassID trainerClass;

        if (gBattleTypeFlags & BATTLE_TYPE_FRONTIER)
            trainerClass = GetFrontierOpponentClass(TRAINER_BATTLE_PARAM.opponentA);
        else if (gBattleTypeFlags & BATTLE_TYPE_TRAINER_HILL)
            trainerClass = TRAINER_CLASS_EXPERT;
        else
            trainerClass = GetTrainerClassFromId(TRAINER_BATTLE_PARAM.opponentA);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

        switch (trainerClass)
        {
        case TRAINER_CLASS_AQUA_LEADER:
        case TRAINER_CLASS_MAGMA_LEADER:
<<<<<<< HEAD
            if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                return MUS_VS_AQUA_MAGMA_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                return MUS_VS_AQUA_MAGMA_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                return MUS_DP_VS_GALACTIC_BOSS;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                return MUS_HG_VS_ROCKET;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                return MUS_HG_VS_ROCKET;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
            {
                if((Random() % 3) == 1)
                    return MUS_DP_VS_GALACTIC_BOSS;
                if((Random() % 3) == 2)
                    return MUS_HG_VS_ROCKET;
                else
                    return MUS_VS_AQUA_MAGMA_LEADER;
            }
            return MUS_VS_AQUA_MAGMA_LEADER;
        case TRAINER_CLASS_TEAM_AQUA:
        case TRAINER_CLASS_TEAM_MAGMA:
            if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                return MUS_HG_VS_ROCKET;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                return MUS_VS_AQUA_MAGMA;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                return MUS_DP_VS_GALACTIC;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                return MUS_HG_VS_ROCKET;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                return MUS_HG_VS_ROCKET;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
            {
                if((Random() % 3) == 1)
                    return MUS_DP_VS_GALACTIC;
                if((Random() % 3) == 2)
                    return MUS_HG_VS_ROCKET;
                else
                    return MUS_VS_AQUA_MAGMA;
            }
            return MUS_VS_AQUA_MAGMA;
        case TRAINER_CLASS_AQUA_ADMIN:
        case TRAINER_CLASS_MAGMA_ADMIN:
            if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                return MUS_VS_AQUA_MAGMA;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                return MUS_VS_AQUA_MAGMA;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                return MUS_DP_VS_GALACTIC_COMMANDER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                return MUS_HG_VS_ROCKET;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                return MUS_HG_VS_ROCKET;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
            {
                if((Random() % 3) == 1)
                    return MUS_DP_VS_GALACTIC_COMMANDER;
                if((Random() % 3) == 2)
                    return MUS_HG_VS_ROCKET;
                else
                    return MUS_VS_AQUA_MAGMA;
            }
            return MUS_VS_AQUA_MAGMA;
        case TRAINER_CLASS_LEADER:
            if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                return MUS_HG_VS_GYM_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                return  MUS_RG_VS_GYM_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                return MUS_DP_VS_GYM_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                return MUS_HG_VS_GYM_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                return MUS_HG_VS_GYM_LEADER_KANTO;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
            {
                if((Random() % 5) == 1)
                    return MUS_RG_VS_GYM_LEADER;
                if((Random() % 5) == 2)
                    return MUS_DP_VS_GYM_LEADER;
                if((Random() % 5) == 3)
                    return MUS_HG_VS_GYM_LEADER;
                if((Random() % 5) == 4)
                    return MUS_HG_VS_GYM_LEADER_KANTO;
                else
                    return MUS_HG_VS_GYM_LEADER;
            }
            return MUS_HG_VS_GYM_LEADER;
        case TRAINER_CLASS_CHAMPION:
            if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                return MUS_VS_CHAMPION;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                return MUS_RG_VS_CHAMPION;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                return MUS_DP_VS_CHAMPION;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                return MUS_HG_VS_CHAMPION;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                return MUS_HG_VS_CHAMPION;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
            {
                if((Random() % 4) == 1)
                    return MUS_RG_VS_CHAMPION;
                if((Random() % 4) == 2)
                    return MUS_DP_VS_CHAMPION;
                if((Random() % 4) == 3)
                    return MUS_HG_VS_CHAMPION;
                else
                    return MUS_VS_CHAMPION;
            }
            return MUS_VS_CHAMPION;
        case TRAINER_CLASS_RIVAL:
            //if ((gBattleTypeFlags & BATTLE_TYPE_FRONTIER) || (!StringCompare(gTrainers[gTrainerBattleOpponent_A].trainerName, gText_BattleWallyName)))
            {
                if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                    return MUS_VS_RIVAL;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                    return MUS_VS_RIVAL;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                    return MUS_DP_VS_RIVAL;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                    return MUS_HG_VS_RIVAL;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                    return MUS_HG_VS_RIVAL;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
                {
                    if((Random() % 3) == 1)
                        return MUS_DP_VS_RIVAL;
                    if((Random() % 3) == 2)
                        return MUS_HG_VS_RIVAL;
                    else
                        return MUS_VS_RIVAL;
                }
            }
            return MUS_VS_RIVAL;
        case TRAINER_CLASS_PKMN_TRAINER_1:
            return MUS_HG_VS_CHAMPION;
        case TRAINER_CLASS_ELITE_FOUR:
            if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                return MUS_VS_ELITE_FOUR;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                return MUS_RG_VS_GYM_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                return MUS_DP_VS_ELITE_FOUR;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                return MUS_HG_VS_GYM_LEADER;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                return MUS_HG_VS_GYM_LEADER_KANTO;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
            {
                if((Random() % 5) == 1)
                    return MUS_DP_VS_ELITE_FOUR;
                if((Random() % 5) == 2)
                    return MUS_RG_VS_GYM_LEADER;
                if((Random() % 5) == 3)
                    return MUS_HG_VS_GYM_LEADER;
                if((Random() % 5) == 4)
                    return MUS_HG_VS_GYM_LEADER_KANTO;
                else
                    return MUS_VS_ELITE_FOUR;
            }
=======
            return MUS_VS_AQUA_MAGMA_LEADER;
        case TRAINER_CLASS_TEAM_AQUA:
        case TRAINER_CLASS_TEAM_MAGMA:
        case TRAINER_CLASS_AQUA_ADMIN:
        case TRAINER_CLASS_MAGMA_ADMIN:
            return MUS_VS_AQUA_MAGMA;
        case TRAINER_CLASS_LEADER:
            return MUS_VS_GYM_LEADER;
        case TRAINER_CLASS_CHAMPION:
            return MUS_VS_CHAMPION;
        case TRAINER_CLASS_RIVAL:
            if (gBattleTypeFlags & BATTLE_TYPE_FRONTIER)
                return MUS_VS_RIVAL;
            if (!StringCompare(GetTrainerNameFromId(TRAINER_BATTLE_PARAM.opponentA), gText_BattleWallyName))
                return MUS_VS_TRAINER;
            return MUS_VS_RIVAL;
        case TRAINER_CLASS_ELITE_FOUR:
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            return MUS_VS_ELITE_FOUR;
        case TRAINER_CLASS_SALON_MAIDEN:
        case TRAINER_CLASS_DOME_ACE:
        case TRAINER_CLASS_PALACE_MAVEN:
        case TRAINER_CLASS_ARENA_TYCOON:
        case TRAINER_CLASS_FACTORY_HEAD:
        case TRAINER_CLASS_PIKE_QUEEN:
        case TRAINER_CLASS_PYRAMID_KING:
<<<<<<< HEAD
            if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                return MUS_VS_FRONTIER_BRAIN;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                return MUS_VS_FRONTIER_BRAIN;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                return MUS_PL_VS_FRONTIER_BRAIN;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                return MUS_HG_VS_FRONTIER_BRAIN;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                return MUS_HG_VS_FRONTIER_BRAIN;
            else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
            {
                if((Random() % 3) == 1)
                    return MUS_PL_VS_FRONTIER_BRAIN;
                if((Random() % 3) == 2)
                    return MUS_HG_VS_FRONTIER_BRAIN;
                else
                    return MUS_VS_FRONTIER_BRAIN;
            }
            return MUS_VS_FRONTIER_BRAIN;
        case TRAINER_CLASS_TEAM_ROCKET:
            return MUS_HG_VS_ROCKET;
        case TRAINER_CLASS_ROCKET_ADMIN:
            return MUS_HG_VS_ROCKET;
        default:
            if (gMapHeader.regionMapSectionId == MAPSEC_BATTLE_FRONTIER) //BGM by map
            {
                if (gSaveBlock2Ptr->optionsFrontierTrainerBattleMusic == 0)
                    return MUS_HG_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsFrontierTrainerBattleMusic == 1)
                    return MUS_RG_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsFrontierTrainerBattleMusic == 2)
                    return MUS_DP_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsFrontierTrainerBattleMusic == 3)
                    return MUS_HG_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsFrontierTrainerBattleMusic == 4)
                    return MUS_HG_VS_TRAINER_KANTO;
                else if (gSaveBlock2Ptr->optionsFrontierTrainerBattleMusic == 5)
                {
                    if((Random() % 5) == 1)
                        return MUS_DP_VS_TRAINER;
                    if((Random() % 5) == 2)
                        return MUS_RG_VS_TRAINER;
                    if((Random() % 5) == 3)
                        return MUS_HG_VS_TRAINER;
                    if((Random() % 5) == 4)
                        return MUS_HG_VS_TRAINER_KANTO;
                    else
                        return MUS_VS_TRAINER;
                }
                return MUS_HG_VS_TRAINER;
            }
            else
            {
                if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 0)
                    return MUS_HG_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 1)
                    return MUS_RG_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 2)
                    return MUS_DP_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 3)
                    return MUS_HG_VS_TRAINER;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 4)
                    return MUS_HG_VS_TRAINER_KANTO;
                else if (gSaveBlock2Ptr->optionsTrainerBattleMusic == 5)
                {
                    if((Random() % 5) == 1)
                        return MUS_DP_VS_TRAINER;
                    if((Random() % 5) == 2)
                        return MUS_RG_VS_TRAINER;
                    if((Random() % 5) == 3)
                        return MUS_HG_VS_TRAINER;
                    if((Random() % 5) == 4)
                        return MUS_HG_VS_TRAINER_KANTO;
                    else
                        return MUS_VS_TRAINER;
                }
                return MUS_HG_VS_TRAINER;
            }
        }
    }
    else
        if (gSaveBlock2Ptr->optionsWildBattleMusic == 0)
            return MUS_HG_VS_WILD;
        else if (gSaveBlock2Ptr->optionsWildBattleMusic == 1)
            return MUS_RG_VS_WILD;
        else if (gSaveBlock2Ptr->optionsWildBattleMusic == 2)
            return MUS_DP_VS_WILD;
        else if (gSaveBlock2Ptr->optionsWildBattleMusic == 3)
            return MUS_HG_VS_WILD;
        else if (gSaveBlock2Ptr->optionsWildBattleMusic == 4)
            return MUS_HG_VS_WILD_KANTO;
        else if (gSaveBlock2Ptr->optionsWildBattleMusic == 5)
        {
            if((Random() % 5) == 1)
                return MUS_HG_VS_WILD_KANTO;
            if((Random() % 5) == 2)
                return MUS_RG_VS_WILD;
            if((Random() % 5) == 3)
                return MUS_DP_VS_WILD;
            if((Random() % 5) == 4)
                return MUS_HG_VS_WILD;
            else
                return MUS_VS_WILD;
        }
        return MUS_HG_VS_WILD;
=======
            return MUS_VS_FRONTIER_BRAIN;
        default:
            return MUS_VS_TRAINER;
        }
    }
    else
    {
        return MUS_VS_WILD;
    }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void PlayBattleBGM(void)
{
    ResetMapMusic();
    m4aMPlayAllStop();
    PlayBGM(GetBattleBGM());
}

void PlayMapChosenOrBattleBGM(u16 songId)
{
    ResetMapMusic();
    m4aMPlayAllStop();
    if (songId)
        PlayNewMapMusic(songId);
    else
        PlayNewMapMusic(GetBattleBGM());
}

// Identical to PlayMapChosenOrBattleBGM, but uses a task instead
// Only used by Battle Dome
#define tSongId data[0]
void CreateTask_PlayMapChosenOrBattleBGM(u16 songId)
{
    u8 taskId;

    ResetMapMusic();
    m4aMPlayAllStop();

    taskId = CreateTask(Task_PlayMapChosenOrBattleBGM, 0);
    gTasks[taskId].tSongId = songId;
}

static void Task_PlayMapChosenOrBattleBGM(u8 taskId)
{
    if (gTasks[taskId].tSongId)
        PlayNewMapMusic(gTasks[taskId].tSongId);
    else
        PlayNewMapMusic(GetBattleBGM());
    DestroyTask(taskId);
}

#undef tSongId

<<<<<<< HEAD
const u32 *GetMonFrontSpritePal(struct Pokemon *mon)
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES_OR_EGG, 0);
    u32 otId = GetMonData(mon, MON_DATA_OT_ID, 0);
    u32 personality = GetMonData(mon, MON_DATA_PERSONALITY, 0);
    return GetMonSpritePalFromSpeciesAndPersonality(species, otId, personality);
}

const u32 *GetMonSpritePalFromSpeciesAndPersonality(u16 species, u32 otId, u32 personality)
{
    u32 shinyValue;
    struct Pokemon *mon;

    if (species > NUM_SPECIES)
        return gMonPaletteTable[SPECIES_NONE].data;

    shinyValue = GET_SHINY_VALUE(otId, personality);

    if (gSaveBlock1Ptr->tx_Features_ShinyChance == 0) // 1/8192
    {
        if (shinyValue < SHINY_ODDS)
            return gMonShinyPaletteTable[species].data;
        else
        {
            return gMonPaletteTable[species].data;
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 1) // 1/4096
    {
        if (shinyValue < 16 && personality !=0)
            return gMonShinyPaletteTable[species].data;
        else
        {
            return gMonPaletteTable[species].data;
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 2) // 1/2048
    {
        if (shinyValue < 32 && personality !=0)
            return gMonShinyPaletteTable[species].data;
        else
        {
            return gMonPaletteTable[species].data;
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 3) // 1/1024
    {
        if (shinyValue < 64 && personality !=0)
            return gMonShinyPaletteTable[species].data;
        else
        {
            return gMonPaletteTable[species].data;
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 4) // 1/512
    {
        if (shinyValue < 128 && personality !=0)
            return gMonShinyPaletteTable[species].data;
        else
        {
            return gMonPaletteTable[species].data;
        }
    }
}
const struct CompressedSpritePalette *GetMonSpritePalStruct(struct Pokemon *mon)
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES_OR_EGG, 0);
    u32 otId = GetMonData(mon, MON_DATA_OT_ID, 0);
    u32 personality = GetMonData(mon, MON_DATA_PERSONALITY, 0);
    return GetMonSpritePalStructFromOtIdPersonality(species, otId, personality);
}

const struct CompressedSpritePalette *GetMonSpritePalStructFromOtIdPersonality(u16 species, u32 otId , u32 personality)
{
    u32 shinyValue;

    shinyValue = GET_SHINY_VALUE(otId, personality);

    if (gSaveBlock1Ptr->tx_Features_ShinyChance == 0) // 1/8192
    {
        if (shinyValue < SHINY_ODDS)
            return &gMonShinyPaletteTable[species];
        else
        {
            return &gMonPaletteTable[species];
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 1) // 1/4096
    {
        if (shinyValue < 16)
            return &gMonShinyPaletteTable[species];
        else
        {
            return &gMonPaletteTable[species];
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 2) // 1/2048
    {
        if (shinyValue < 32)
            return &gMonShinyPaletteTable[species];
        else
        {
            return &gMonPaletteTable[species];
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 3) // 1/1024
    {
        if (shinyValue < 64)
            return &gMonShinyPaletteTable[species];
        else
        {
            return &gMonPaletteTable[species];
        }
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 4) // 1/512
    {
        if (shinyValue < 128)
            return &gMonShinyPaletteTable[species];
        else
        {
            return &gMonPaletteTable[species];
        }
    }      
}

bool32 IsHMMove2(u16 move)
{
    int i = 0;
    while (sHMMoves[i] != HM_MOVES_END)
    {
        if (sHMMoves[i++] == move)
            return TRUE;
    }
    return FALSE;
=======
const u16 *GetMonFrontSpritePal(struct Pokemon *mon)
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES_OR_EGG, NULL);
    bool32 isShiny = GetMonData(mon, MON_DATA_IS_SHINY, NULL);
    u32 personality = GetMonData(mon, MON_DATA_PERSONALITY, NULL);
    return GetMonSpritePalFromSpeciesAndPersonality(species, isShiny, personality);
}

const u16 *GetMonSpritePalFromSpeciesAndPersonality(u16 species, bool32 isShiny, u32 personality)
{
    return GetMonSpritePalFromSpecies(species, isShiny, IsPersonalityFemale(species, personality));
}

const u16 *GetMonSpritePalFromSpecies(u16 species, bool32 isShiny, bool32 isFemale)
{
    species = SanitizeSpeciesId(species);

    if (isShiny)
    {
    #if P_GENDER_DIFFERENCES
        if (gSpeciesInfo[species].shinyPaletteFemale != NULL && isFemale)
            return gSpeciesInfo[species].shinyPaletteFemale;
        else
    #endif
        if (gSpeciesInfo[species].shinyPalette != NULL)
            return gSpeciesInfo[species].shinyPalette;
        else
            return gSpeciesInfo[SPECIES_NONE].shinyPalette;
    }
    else
    {
    #if P_GENDER_DIFFERENCES
        if (gSpeciesInfo[species].paletteFemale != NULL && isFemale)
            return gSpeciesInfo[species].paletteFemale;
        else
    #endif
        if (gSpeciesInfo[species].palette != NULL)
            return gSpeciesInfo[species].palette;
        else
            return gSpeciesInfo[SPECIES_NONE].palette;
    }
}

#define OR_MOVE_IS_HM(_hm) || (move == MOVE_##_hm)

bool32 IsMoveHM(u16 move)
{
    return FALSE FOREACH_HM(OR_MOVE_IS_HM);
}

#undef OR_MOVE_IS_HM

bool32 CannotForgetMove(u16 move)
{
    if (P_CAN_FORGET_HIDDEN_MOVE)
        return FALSE;

    return IsMoveHM(move);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

bool8 IsMonSpriteNotFlipped(u16 species)
{
    return gSpeciesInfo[species].noFlip;
}

s8 GetMonFlavorRelation(struct Pokemon *mon, u8 flavor)
{
<<<<<<< HEAD
    u8 nature = GetNature(mon, FALSE);
=======
    u8 nature = GetNature(mon);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    return gPokeblockFlavorCompatibilityTable[nature * FLAVOR_COUNT + flavor];
}

s8 GetFlavorRelationByPersonality(u32 personality, u8 flavor)
{
    u8 nature = GetNatureFromPersonality(personality);
    return gPokeblockFlavorCompatibilityTable[nature * FLAVOR_COUNT + flavor];
}

bool8 IsTradedMon(struct Pokemon *mon)
{
    u8 otName[PLAYER_NAME_LENGTH + 1];
    u32 otId;
    GetMonData(mon, MON_DATA_OT_NAME, otName);
    otId = GetMonData(mon, MON_DATA_OT_ID, 0);
    return IsOtherTrainer(otId, otName);
}

bool8 IsOtherTrainer(u32 otId, u8 *otName)
{
    if (otId ==
        (gSaveBlock2Ptr->playerTrainerId[0]
      | (gSaveBlock2Ptr->playerTrainerId[1] << 8)
      | (gSaveBlock2Ptr->playerTrainerId[2] << 16)
      | (gSaveBlock2Ptr->playerTrainerId[3] << 24)))
    {
        int i;
        for (i = 0; otName[i] != EOS; i++)
            if (otName[i] != gSaveBlock2Ptr->playerName[i])
                return TRUE;
        return FALSE;
    }

    return TRUE;
}

void MonRestorePP(struct Pokemon *mon)
{
    BoxMonRestorePP(&mon->box);
}

void BoxMonRestorePP(struct BoxPokemon *boxMon)
{
    int i;

    for (i = 0; i < MAX_MON_MOVES; i++)
    {
        if (GetBoxMonData(boxMon, MON_DATA_MOVE1 + i, 0))
        {
            u16 move = GetBoxMonData(boxMon, MON_DATA_MOVE1 + i, 0);
            u16 bonus = GetBoxMonData(boxMon, MON_DATA_PP_BONUSES, 0);
            u8 pp = CalculatePPWithBonus(move, bonus, i);
            SetBoxMonData(boxMon, MON_DATA_PP1 + i, &pp);
        }
    }
}

void SetMonPreventsSwitchingString(void)
{
    gLastUsedAbility = gBattleStruct->abilityPreventingSwitchout;

    gBattleTextBuff1[0] = B_BUFF_PLACEHOLDER_BEGIN;
    gBattleTextBuff1[1] = B_BUFF_MON_NICK_WITH_PREFIX;
    gBattleTextBuff1[2] = gBattleStruct->battlerPreventingSwitchout;
    gBattleTextBuff1[4] = B_BUFF_EOS;

<<<<<<< HEAD
    if (GetBattlerSide(gBattleStruct->battlerPreventingSwitchout) == B_SIDE_PLAYER)
=======
    if (IsOnPlayerSide(gBattleStruct->battlerPreventingSwitchout))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        gBattleTextBuff1[3] = GetPartyIdFromBattlePartyId(gBattlerPartyIndexes[gBattleStruct->battlerPreventingSwitchout]);
    else
        gBattleTextBuff1[3] = gBattlerPartyIndexes[gBattleStruct->battlerPreventingSwitchout];

    PREPARE_MON_NICK_WITH_PREFIX_BUFFER(gBattleTextBuff2, gBattlerInMenuId, GetPartyIdFromBattlePartyId(gBattlerPartyIndexes[gBattlerInMenuId]))

<<<<<<< HEAD
    BattleStringExpandPlaceholders(gText_PkmnsXPreventsSwitching, gStringVar4);
=======
    BattleStringExpandPlaceholders(gText_PkmnsXPreventsSwitching, gStringVar4, sizeof(gStringVar4));
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

static s32 GetWildMonTableIdInAlteringCave(u16 species)
{
    s32 i;
    for (i = 0; i < (s32) ARRAY_COUNT(sAlteringCaveWildMonHeldItems); i++)
        if (sAlteringCaveWildMonHeldItems[i].species == species)
            return i;
    return 0;
}

<<<<<<< HEAD
=======
static inline bool32 CanFirstMonBoostHeldItemRarity(void)
{
    u32 ability;
    if (GetMonData(&gPlayerParty[0], MON_DATA_SANITY_IS_EGG))
        return FALSE;

    ability = GetMonAbility(&gPlayerParty[0]);
    if (ability == ABILITY_COMPOUND_EYES)
        return TRUE;
    else if ((OW_SUPER_LUCK >= GEN_8) && ability == ABILITY_SUPER_LUCK)
        return TRUE;
    return FALSE;
}

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
void SetWildMonHeldItem(void)
{
    if (!(gBattleTypeFlags & (BATTLE_TYPE_LEGENDARY | BATTLE_TYPE_TRAINER | BATTLE_TYPE_PYRAMID | BATTLE_TYPE_PIKE)))
    {
<<<<<<< HEAD
        u16 rnd = Random() % 100;
        u16 species = GetMonData(&gEnemyParty[0], MON_DATA_SPECIES, 0);
        u16 chanceNoItem = 45;
        u16 chanceNotRare = 90;
        if (!GetMonData(&gPlayerParty[0], MON_DATA_SANITY_IS_EGG, 0)
            && GetMonAbility(&gPlayerParty[0]) == ABILITY_COMPOUND_EYES)
        {
            chanceNoItem = 20;
            chanceNotRare = 80;
        }
        if (gMapHeader.mapLayoutId == LAYOUT_ALTERING_CAVE)
        {
            s32 alteringCaveId = GetWildMonTableIdInAlteringCave(species);
            if (alteringCaveId != 0)
            {
                // In active Altering Cave, use special item list
                if (rnd < chanceNotRare)
                    return;
                SetMonData(&gEnemyParty[0], MON_DATA_HELD_ITEM, &sAlteringCaveWildMonHeldItems[alteringCaveId].item);
            }
            else
            {
                // In inactive Altering Cave, use normal items
                if (rnd < chanceNoItem)
                    return;
                if (rnd < chanceNotRare)
                    SetMonData(&gEnemyParty[0], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemCommon);
                else
                    SetMonData(&gEnemyParty[0], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemRare);
            }
        }
        else
        {
            if (gSpeciesInfo[species].itemCommon == gSpeciesInfo[species].itemRare && gSpeciesInfo[species].itemCommon != ITEM_NONE)
            {
                // Both held items are the same, 100% chance to hold item
                SetMonData(&gEnemyParty[0], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemCommon);
            }
            else
            {
                if (rnd < chanceNoItem)
                    return;
                if (rnd < chanceNotRare)
                    SetMonData(&gEnemyParty[0], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemCommon);
                else
                    SetMonData(&gEnemyParty[0], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemRare);
=======
        u16 rnd;
        u16 species;
        u16 count = (WILD_DOUBLE_BATTLE) ? 2 : 1;
        u16 i;
        bool32 itemHeldBoost = CanFirstMonBoostHeldItemRarity();
        u16 chanceNoItem = itemHeldBoost ? 20 : 45;
        u16 chanceNotRare = itemHeldBoost ? 80 : 95;

        for (i = 0; i < count; i++)
        {
            if (GetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, NULL) != ITEM_NONE)
                continue; // prevent overwriting previously set item

            rnd = Random() % 100;
            species = GetMonData(&gEnemyParty[i], MON_DATA_SPECIES, 0);
            if (gMapHeader.mapLayoutId == LAYOUT_ALTERING_CAVE)
            {
                s32 alteringCaveId = GetWildMonTableIdInAlteringCave(species);
                if (alteringCaveId != 0)
                {
                    // In active Altering Cave, use special item list
                    if (rnd < chanceNotRare)
                        continue;
                    SetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, &sAlteringCaveWildMonHeldItems[alteringCaveId].item);
                }
                else
                {
                    // In inactive Altering Cave, use normal items
                    if (rnd < chanceNoItem)
                        continue;
                    if (rnd < chanceNotRare)
                        SetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemCommon);
                    else
                        SetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemRare);
                }
            }
            else
            {
                if (gSpeciesInfo[species].itemCommon == gSpeciesInfo[species].itemRare && gSpeciesInfo[species].itemCommon != ITEM_NONE)
                {
                    // Both held items are the same, 100% chance to hold item
                    SetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemCommon);
                }
                else
                {
                    if (rnd < chanceNoItem)
                        continue;
                    if (rnd < chanceNotRare)
                        SetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemCommon);
                    else
                        SetMonData(&gEnemyParty[i], MON_DATA_HELD_ITEM, &gSpeciesInfo[species].itemRare);
                }
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            }
        }
    }
}

bool8 IsMonShiny(struct Pokemon *mon)
{
<<<<<<< HEAD
    u32 otId = GetMonData(mon, MON_DATA_OT_ID, 0);
    u32 personality = GetMonData(mon, MON_DATA_PERSONALITY, 0);
    return IsShinyOtIdPersonality(otId, personality);
}

bool8 IsShinyOtIdPersonality(u32 otId, u32 personality)
{
    bool8 retVal = FALSE;
    u32 shinyValue = GET_SHINY_VALUE(otId, personality);

    if (gSaveBlock1Ptr->tx_Features_ShinyChance == 0) // 1/8192
    {
        if (shinyValue < SHINY_ODDS)
            retVal = TRUE;
        return retVal;
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 1) // 1/4096
    {
        if (shinyValue < 16)
            retVal = TRUE;
        return retVal;
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 2) // 1/2048
    {
        if (shinyValue < 32)
            retVal = TRUE;
        return retVal;
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 3) // 1/1024
    {
        if (shinyValue < 64)
            retVal = TRUE;
        return retVal;
    }
    else if (gSaveBlock1Ptr->tx_Features_ShinyChance == 4) // 1/512
    {
        if (shinyValue < 128)
            retVal = TRUE;
        return retVal;
    }
=======
    return GetMonData(mon, MON_DATA_IS_SHINY, NULL);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

const u8 *GetTrainerPartnerName(void)
{
    if (gBattleTypeFlags & BATTLE_TYPE_INGAME_PARTNER)
    {
<<<<<<< HEAD
        if (gPartnerTrainerId == TRAINER_STEVEN_PARTNER)
        {
            return gTrainers[TRAINER_LANCE_1].trainerName;
        }
        else
        {
            GetFrontierTrainerName(gStringVar1, gPartnerTrainerId);
            return gStringVar1;
        }
=======
        GetFrontierTrainerName(gStringVar1, gPartnerTrainerId);
        return gStringVar1;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }
    else
    {
        u8 id = GetMultiplayerId();
        return gLinkPlayers[GetBattlerMultiplayerId(gLinkPlayers[id].id ^ 2)].name;
    }
}

#define READ_PTR_FROM_TASK(taskId, dataId)                      \
    (void *)(                                                   \
    ((u16)(gTasks[taskId].data[dataId]) |                       \
    ((u16)(gTasks[taskId].data[dataId + 1]) << 16)))

#define STORE_PTR_IN_TASK(ptr, taskId, dataId)                 \
{                                                              \
    gTasks[taskId].data[dataId] = (u32)(ptr);                  \
    gTasks[taskId].data[dataId + 1] = (u32)(ptr) >> 16;        \
}

#define sAnimId    data[2]
#define sAnimDelay data[3]

static void Task_AnimateAfterDelay(u8 taskId)
{
    if (--gTasks[taskId].sAnimDelay == 0)
    {
        LaunchAnimationTaskForFrontSprite(READ_PTR_FROM_TASK(taskId, 0), gTasks[taskId].sAnimId);
        DestroyTask(taskId);
    }
}

static void Task_PokemonSummaryAnimateAfterDelay(u8 taskId)
{
    if (--gTasks[taskId].sAnimDelay == 0)
    {
        StartMonSummaryAnimation(READ_PTR_FROM_TASK(taskId, 0), gTasks[taskId].sAnimId);
        SummaryScreen_SetAnimDelayTaskId(TASK_NONE);
        DestroyTask(taskId);
    }
}

void BattleAnimateFrontSprite(struct Sprite *sprite, u16 species, bool8 noCry, u8 panMode)
{
<<<<<<< HEAD
    if (gSaveBlock2Ptr->optionsBattleSceneOff == 1)
    {
        DoMonFrontSpriteAnimation(sprite, species, noCry, panMode | 0x80);    
    }
    else
    {
        if (gHitMarker & HITMARKER_NO_ANIMATIONS && !(gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_RECORDED_LINK)))
                DoMonFrontSpriteAnimation(sprite, species, noCry, panMode | SKIP_FRONT_ANIM);
        else
            DoMonFrontSpriteAnimation(sprite, species, noCry, panMode);
    }
=======
    if (gHitMarker & HITMARKER_NO_ANIMATIONS && !(gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_RECORDED_LINK)))
        DoMonFrontSpriteAnimation(sprite, species, noCry, panMode | SKIP_FRONT_ANIM);
    else
        DoMonFrontSpriteAnimation(sprite, species, noCry, panMode);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

void DoMonFrontSpriteAnimation(struct Sprite *sprite, u16 species, bool8 noCry, u8 panModeAnimFlag)
{
    s8 pan;
    switch (panModeAnimFlag & (u8)~SKIP_FRONT_ANIM) // Exclude anim flag to get pan mode
    {
    case 0:
        pan = -25;
        break;
    case 1:
        pan = 25;
        break;
    default:
        pan = 0;
        break;
    }
    if (panModeAnimFlag & SKIP_FRONT_ANIM)
    {
        // No animation, only check if cry needs to be played
        if (!noCry)
            PlayCry_Normal(species, pan);
        sprite->callback = SpriteCallbackDummy;
    }
    else
    {
        if (!noCry)
        {
            PlayCry_Normal(species, pan);
            if (HasTwoFramesAnimation(species))
                StartSpriteAnim(sprite, 1);
        }
<<<<<<< HEAD
        if (sMonAnimationDelayTable[species - 1] != 0)
=======
        if (gSpeciesInfo[species].frontAnimDelay != 0)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        {
            // Animation has delay, start delay task
            u8 taskId = CreateTask(Task_AnimateAfterDelay, 0);
            STORE_PTR_IN_TASK(sprite, taskId, 0);
<<<<<<< HEAD
            gTasks[taskId].sAnimId = sMonFrontAnimIdsTable[species - 1];
            gTasks[taskId].sAnimDelay = sMonAnimationDelayTable[species - 1];
=======
            gTasks[taskId].sAnimId = gSpeciesInfo[species].frontAnimId;
            gTasks[taskId].sAnimDelay = gSpeciesInfo[species].frontAnimDelay;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        }
        else
        {
            // No delay, start animation
<<<<<<< HEAD
            LaunchAnimationTaskForFrontSprite(sprite, sMonFrontAnimIdsTable[species - 1]);
=======
            LaunchAnimationTaskForFrontSprite(sprite, gSpeciesInfo[species].frontAnimId);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        }
        sprite->callback = SpriteCallbackDummy_2;
    }
}

void PokemonSummaryDoMonAnimation(struct Sprite *sprite, u16 species, bool8 oneFrame)
{
<<<<<<< HEAD
    if (gSaveBlock2Ptr->optionsBattleSceneOff == 1)
    {
        sprite->callback = SpriteCallbackDummy;
    }
    else
    {
        if (!oneFrame && HasTwoFramesAnimation(species))
            StartSpriteAnim(sprite, 1);
        if (sMonAnimationDelayTable[species - 1] != 0)
        {
            // Animation has delay, start delay task
            u8 taskId = CreateTask(Task_PokemonSummaryAnimateAfterDelay, 0);
            STORE_PTR_IN_TASK(sprite, taskId, 0);
            gTasks[taskId].sAnimId = sMonFrontAnimIdsTable[species - 1];
            gTasks[taskId].sAnimDelay = sMonAnimationDelayTable[species - 1];
            SummaryScreen_SetAnimDelayTaskId(taskId);
            SetSpriteCB_MonAnimDummy(sprite);
        }
        else
        {
            // No delay, start animation
            StartMonSummaryAnimation(sprite, sMonFrontAnimIdsTable[species - 1]);
        }
=======
    if (!oneFrame && HasTwoFramesAnimation(species))
        StartSpriteAnim(sprite, 1);
    if (gSpeciesInfo[species].frontAnimDelay != 0)
    {
        // Animation has delay, start delay task
        u8 taskId = CreateTask(Task_PokemonSummaryAnimateAfterDelay, 0);
        STORE_PTR_IN_TASK(sprite, taskId, 0);
        gTasks[taskId].sAnimId = gSpeciesInfo[species].frontAnimId;
        gTasks[taskId].sAnimDelay = gSpeciesInfo[species].frontAnimDelay;
        SummaryScreen_SetAnimDelayTaskId(taskId);
        SetSpriteCB_MonAnimDummy(sprite);
    }
    else
    {
        // No delay, start animation
        StartMonSummaryAnimation(sprite, gSpeciesInfo[species].frontAnimId);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    }
}

void StopPokemonAnimationDelayTask(void)
{
    u8 delayTaskId = FindTaskIdByFunc(Task_PokemonSummaryAnimateAfterDelay);
    if (delayTaskId != TASK_NONE)
        DestroyTask(delayTaskId);
}

void BattleAnimateBackSprite(struct Sprite *sprite, u16 species)
{
<<<<<<< HEAD
    if (gSaveBlock2Ptr->optionsBattleSceneOff == 1)
=======
    if (gHitMarker & HITMARKER_NO_ANIMATIONS && !(gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_RECORDED_LINK)))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    {
        sprite->callback = SpriteCallbackDummy;
    }
    else
    {
<<<<<<< HEAD
        if (gHitMarker & HITMARKER_NO_ANIMATIONS && !(gBattleTypeFlags & (BATTLE_TYPE_LINK | BATTLE_TYPE_RECORDED_LINK)))
        {
            sprite->callback = SpriteCallbackDummy;
        }
        else
        {
            LaunchAnimationTaskForBackSprite(sprite, GetSpeciesBackAnimSet(species));
            sprite->callback = SpriteCallbackDummy_2;
        }
    }
    }
=======
        LaunchAnimationTaskForBackSprite(sprite, GetSpeciesBackAnimSet(species));
        sprite->callback = SpriteCallbackDummy_2;
    }
}
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc

// Identical to GetOpposingLinkMultiBattlerId but for the player
// "rightSide" from that team's perspective, i.e. B_POSITION_*_RIGHT
static u8 UNUSED GetOwnOpposingLinkMultiBattlerId(bool8 rightSide)
{
    s32 i;
<<<<<<< HEAD
    s32 battlerId = 0;
=======
    s32 battler = 0;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    u8 multiplayerId = GetMultiplayerId();
    switch (gLinkPlayers[multiplayerId].id)
    {
    case 0:
    case 2:
<<<<<<< HEAD
        battlerId = rightSide ? 1 : 3;
        break;
    case 1:
    case 3:
        battlerId = rightSide ? 2 : 0;
=======
        battler = rightSide ? 1 : 3;
        break;
    case 1:
    case 3:
        battler = rightSide ? 2 : 0;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        break;
    }
    for (i = 0; i < MAX_LINK_PLAYERS; i++)
    {
<<<<<<< HEAD
        if (gLinkPlayers[i].id == (s16)battlerId)
=======
        if (gLinkPlayers[i].id == (s16)battler)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            break;
    }
    return i;
}

u8 GetOpposingLinkMultiBattlerId(bool8 rightSide, u8 multiplayerId)
{
    s32 i;
<<<<<<< HEAD
    s32 battlerId = 0;
=======
    s32 battler = 0;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    switch (gLinkPlayers[multiplayerId].id)
    {
    case 0:
    case 2:
<<<<<<< HEAD
        battlerId = rightSide ? 1 : 3;
        break;
    case 1:
    case 3:
        battlerId = rightSide ? 2 : 0;
=======
        battler = rightSide ? 1 : 3;
        break;
    case 1:
    case 3:
        battler = rightSide ? 2 : 0;
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        break;
    }
    for (i = 0; i < MAX_LINK_PLAYERS; i++)
    {
<<<<<<< HEAD
        if (gLinkPlayers[i].id == (s16)battlerId)
=======
        if (gLinkPlayers[i].id == (s16)battler)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
            break;
    }
    return i;
}

u16 FacilityClassToPicIndex(u16 facilityClass)
{
    return gFacilityClassToPicIndex[facilityClass];
}

u16 PlayerGenderToFrontTrainerPicId(u8 playerGender)
{
    if (playerGender != MALE)
        return FacilityClassToPicIndex(FACILITY_CLASS_MAY);
    else
        return FacilityClassToPicIndex(FACILITY_CLASS_BRENDAN);
}

<<<<<<< HEAD
void HandleSetPokedexFlag(u16 nationalNum, u8 caseId, u32 personality)
=======
void HandleSetPokedexFlag(enum NationalDexOrder nationalNum, u8 caseId, u32 personality)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u8 getFlagCaseId = (caseId == FLAG_SET_SEEN) ? FLAG_GET_SEEN : FLAG_GET_CAUGHT;
    if (!GetSetPokedexFlag(nationalNum, getFlagCaseId)) // don't set if it's already set
    {
        GetSetPokedexFlag(nationalNum, caseId);
        if (NationalPokedexNumToSpecies(nationalNum) == SPECIES_UNOWN)
            gSaveBlock2Ptr->pokedex.unownPersonality = personality;
        if (NationalPokedexNumToSpecies(nationalNum) == SPECIES_SPINDA)
            gSaveBlock2Ptr->pokedex.spindaPersonality = personality;
    }
}

<<<<<<< HEAD
const u8 *GetTrainerClassNameFromId(u16 trainerId)
{
    if (trainerId >= TRAINERS_COUNT)
        trainerId = TRAINER_NONE;
    return gTrainerClassNames[gTrainers[trainerId].trainerClass];
}

const u8 *GetTrainerNameFromId(u16 trainerId)
{
    if (trainerId >= TRAINERS_COUNT)
        trainerId = TRAINER_NONE;
    return gTrainers[trainerId].trainerName;
=======
void HandleSetPokedexFlagFromMon(struct Pokemon *mon, u32 caseId)
{
    u32 personality = GetMonData(mon, MON_DATA_PERSONALITY);
    enum NationalDexOrder nationalNum = SpeciesToNationalPokedexNum(GetMonData(mon, MON_DATA_SPECIES));

    HandleSetPokedexFlag(nationalNum, caseId, personality);
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
}

bool8 HasTwoFramesAnimation(u16 species)
{
<<<<<<< HEAD
    return (species != SPECIES_CASTFORM
         && species != SPECIES_SPINDA
         && species != SPECIES_UNOWN);
}

static bool8 ShouldSkipFriendshipChange(void)
{
    if (gMain.inBattle && gBattleTypeFlags & (BATTLE_TYPE_FRONTIER))
        return TRUE;
    if (!gMain.inBattle && (InBattlePike() || InBattlePyramid()))
=======
    return P_TWO_FRAME_FRONT_SPRITES
        && gSpeciesInfo[species].frontAnimFrames != sAnims_SingleFramePlaceHolder
        && species != SPECIES_UNOWN
        && !gTestRunnerHeadless;
}

bool8 ShouldSkipFriendshipChange(void)
{
    if (gMain.inBattle && gBattleTypeFlags & (BATTLE_TYPE_FRONTIER))
        return TRUE;
    if (!gMain.inBattle && (InBattlePike() || CurrentBattlePyramidLocation() != PYRAMID_LOCATION_NONE))
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
        return TRUE;
    return FALSE;
}

// The below functions are for the 'MonSpritesGfxManager', a method of allocating
// space for PokÃ©mon sprites. These are only used for the summary screen PokÃ©mon
// sprites (unless gMonSpritesGfxPtr is in use), but were set up for more general use.
// Only the 'default' mode (MON_SPR_GFX_MODE_NORMAL) is used, which is set
// up to allocate 4 sprites using the battler sprite templates (gBattlerSpriteTemplates).
// MON_SPR_GFX_MODE_BATTLE is identical but never used.
// MON_SPR_GFX_MODE_FULL_PARTY is set up to allocate 7 sprites (party + trainer?)
// using a generic 64x64 template, and is also never used.

// Between the unnecessarily large sizes below, a mistake allocating the spritePointers
// field, and the fact that ultimately only 1 of the 4 sprite positions is used, this
// system wastes a good deal of memory.

#define ALLOC_FAIL_BUFFER (1 << 0)
#define ALLOC_FAIL_STRUCT (1 << 1)
#define GFX_MANAGER_ACTIVE 0xA3 // Arbitrary value

<<<<<<< HEAD
static void InitMonSpritesGfx_Battle(struct MonSpritesGfxManager* gfx)
=======
static void InitMonSpritesGfx_Battle(struct MonSpritesGfxManager *gfx)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u16 i, j;
    for (i = 0; i < gfx->numSprites; i++)
    {
        gfx->templates[i] = gBattlerSpriteTemplates[i];
        for (j = 0; j < gfx->numFrames; j++)
            gfx->frameImages[i * gfx->numFrames + j].data = &gfx->spritePointers[i][j * MON_PIC_SIZE];

        gfx->templates[i].images = &gfx->frameImages[i * gfx->numFrames];
    }
}

<<<<<<< HEAD
static void InitMonSpritesGfx_FullParty(struct MonSpritesGfxManager* gfx)
=======
static void InitMonSpritesGfx_FullParty(struct MonSpritesGfxManager *gfx)
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
{
    u16 i, j;
    for (i = 0; i < gfx->numSprites; i++)
    {
        gfx->templates[i] = sSpriteTemplate_64x64;
        for (j = 0; j < gfx->numFrames; j++)
            gfx->frameImages[i * gfx->numSprites + j].data = &gfx->spritePointers[i][j * MON_PIC_SIZE];

        gfx->templates[i].images = &gfx->frameImages[i * gfx->numSprites];
        gfx->templates[i].anims = gAnims_MonPic;
        gfx->templates[i].paletteTag = i;
    }
}

struct MonSpritesGfxManager *CreateMonSpritesGfxManager(u8 managerId, u8 mode)
{
    u8 i;
    u8 failureFlags;
    struct MonSpritesGfxManager *gfx;

    failureFlags = 0;
    managerId %= MON_SPR_GFX_MANAGERS_COUNT;
    gfx = AllocZeroed(sizeof(*gfx));
    if (gfx == NULL)
        return NULL;

    switch (mode)
    {
    case MON_SPR_GFX_MODE_FULL_PARTY:
        gfx->numSprites = PARTY_SIZE + 1;
        gfx->numSprites2 = PARTY_SIZE + 1;
        gfx->numFrames = MAX_MON_PIC_FRAMES;
        gfx->dataSize = 1;
        gfx->mode = MON_SPR_GFX_MODE_FULL_PARTY;
        break;
 // case MON_SPR_GFX_MODE_BATTLE:
    case MON_SPR_GFX_MODE_NORMAL:
    default:
        gfx->numSprites = MAX_BATTLERS_COUNT;
        gfx->numSprites2 = MAX_BATTLERS_COUNT;
        gfx->numFrames = MAX_MON_PIC_FRAMES;
        gfx->dataSize = 1;
        gfx->mode = MON_SPR_GFX_MODE_NORMAL;
        break;
    }

    // Set up sprite / sprite pointer buffers
    gfx->spriteBuffer = AllocZeroed(gfx->dataSize * MON_PIC_SIZE * MAX_MON_PIC_FRAMES * gfx->numSprites);
    gfx->spritePointers = AllocZeroed(gfx->numSprites * 32); // ? Only * 4 is necessary, perhaps they were thinking bits.
    if (gfx->spriteBuffer == NULL || gfx->spritePointers == NULL)
    {
        failureFlags |= ALLOC_FAIL_BUFFER;
    }
    else
    {
        for (i = 0; i < gfx->numSprites; i++)
            gfx->spritePointers[i] = gfx->spriteBuffer + (gfx->dataSize * MON_PIC_SIZE * MAX_MON_PIC_FRAMES * i);
    }

    // Set up sprite structs
    gfx->templates = AllocZeroed(sizeof(struct SpriteTemplate) * gfx->numSprites);
    gfx->frameImages = AllocZeroed(sizeof(struct SpriteFrameImage) * gfx->numSprites * gfx->numFrames);
    if (gfx->templates == NULL || gfx->frameImages == NULL)
    {
        failureFlags |= ALLOC_FAIL_STRUCT;
    }
    else
    {
        for (i = 0; i < gfx->numFrames * gfx->numSprites; i++)
            gfx->frameImages[i].size = MON_PIC_SIZE;

        switch (gfx->mode)
        {
        case MON_SPR_GFX_MODE_FULL_PARTY:
            InitMonSpritesGfx_FullParty(gfx);
            break;
        case MON_SPR_GFX_MODE_NORMAL:
        case MON_SPR_GFX_MODE_BATTLE:
        default:
            InitMonSpritesGfx_Battle(gfx);
            break;
        }
    }

    // If either of the allocations failed free their respective members
    if (failureFlags & ALLOC_FAIL_STRUCT)
    {
        TRY_FREE_AND_SET_NULL(gfx->frameImages);
        TRY_FREE_AND_SET_NULL(gfx->templates);
    }
    if (failureFlags & ALLOC_FAIL_BUFFER)
    {
        TRY_FREE_AND_SET_NULL(gfx->spritePointers);
        TRY_FREE_AND_SET_NULL(gfx->spriteBuffer);
    }

    if (failureFlags)
    {
        // Clear, something failed to allocate
        memset(gfx, 0, sizeof(*gfx));
        Free(gfx);
    }
    else
    {
        gfx->active = GFX_MANAGER_ACTIVE;
        sMonSpritesGfxManagers[managerId] = gfx;
    }

    return sMonSpritesGfxManagers[managerId];
}

void DestroyMonSpritesGfxManager(u8 managerId)
{
    struct MonSpritesGfxManager *gfx;

    managerId %= MON_SPR_GFX_MANAGERS_COUNT;
    gfx = sMonSpritesGfxManagers[managerId];
    if (gfx == NULL)
        return;

    if (gfx->active != GFX_MANAGER_ACTIVE)
    {
        memset(gfx, 0, sizeof(*gfx));
    }
    else
    {
        TRY_FREE_AND_SET_NULL(gfx->frameImages);
        TRY_FREE_AND_SET_NULL(gfx->templates);
        TRY_FREE_AND_SET_NULL(gfx->spritePointers);
        TRY_FREE_AND_SET_NULL(gfx->spriteBuffer);
        memset(gfx, 0, sizeof(*gfx));
        Free(gfx);
    }
}

u8 *MonSpritesGfxManager_GetSpritePtr(u8 managerId, u8 spriteNum)
{
    struct MonSpritesGfxManager *gfx = sMonSpritesGfxManagers[managerId % MON_SPR_GFX_MANAGERS_COUNT];
    if (gfx->active != GFX_MANAGER_ACTIVE)
    {
        return NULL;
    }
    else
    {
        if (spriteNum >= gfx->numSprites)
            spriteNum = 0;

        return gfx->spritePointers[spriteNum];
    }
}

<<<<<<< HEAD
//******************* tx_randomizer_and_challenges
void RandomizeTypeEffectivenessListEWRAM(u16 seed)
{
    u8 i;
    u8 stemp[RANDOM_TYPE_COUNT];

    memcpy(stemp, sOneTypeChallengeValidTypes, sizeof(sOneTypeChallengeValidTypes));
    ShuffleListU8(stemp, NELEMS(sOneTypeChallengeValidTypes), seed);

    sTypeEffectivenessList[TYPE_MYSTERY] = TYPE_MYSTERY;
    for (i=0; i<NUMBER_OF_MON_TYPES; i++)
    {
        if (i != TYPE_MYSTERY)
            sTypeEffectivenessList[i] = stemp[i];

    }
}
u8 GetTypeEffectivenessRandom(u8 type)
{
    if (type == TYPE_NONE)
        return TYPE_NONE;

    if (!gSaveBlock1Ptr->tx_Random_TypeEffectiveness)
        return type;

    return sTypeEffectivenessList[type];
}
u16 PickRandomStarterForOneTypeChallenge(u16 *speciesList, u8 starterId)
{
    u16 i, species;
    u8 typeChallenge = gSaveBlock1Ptr->tx_Challenges_OneTypeChallenge;

    #ifndef NDEBUG
        MgbaPrintf(MGBA_LOG_DEBUG, "PickRandomStarterForOneTypeChallenge(starterId=%d)", starterId);
    #endif

    if ((IsRandomizerActivated() && gSaveBlock1Ptr->tx_Random_Similar) || !IsRandomizerActivated())
    {
        u16 *stemp = Alloc(sizeof(sRandomSpeciesEvo0));
        DmaCopy16(3, sRandomSpeciesEvo0, stemp, sizeof(sRandomSpeciesEvo0));
        ShuffleListU16(stemp, RANDOM_SPECIES_EVO_0_COUNT, (starterId+13)*12289);
        for (i=0; i<RANDOM_SPECIES_EVO_0_COUNT; i++)
        {
            species = stemp[i];
            if ((GetTypeBySpecies(species, 1) == typeChallenge || GetTypeBySpecies(species, 2) == typeChallenge) 
                && species != speciesList[0] && species != speciesList[1] && species != speciesList[2])
                break;
        }

        if (i == RANDOM_SPECIES_EVO_0_COUNT)
            species = speciesList[1];

        Free(stemp);
    }
    else if (gSaveBlock1Ptr->tx_Random_IncludeLegendaries)
    {
        u16 *stemp = Alloc(sizeof(sRandomSpeciesLegendary));
        DmaCopy16(3, sRandomSpeciesLegendary, stemp, sizeof(sRandomSpeciesLegendary));
        ShuffleListU16(stemp, RANDOM_SPECIES_COUNT_LEGENDARY, (starterId+13)*12289);
        for (i=0; i<RANDOM_SPECIES_COUNT_LEGENDARY; i++)
        {
            species = stemp[i];
            if ((GetTypeBySpecies(species, 1) == typeChallenge || GetTypeBySpecies(species, 2) == typeChallenge) 
                && species != speciesList[0] && species != speciesList[1] && species != speciesList[2])
                break;
        }

        if (i == RANDOM_SPECIES_COUNT_LEGENDARY)
            species = speciesList[1];

        Free(stemp);
    }
    else
    {
        u16 *stemp = Alloc(sizeof(sRandomSpecies));
        DmaCopy16(3, sRandomSpecies, stemp, sizeof(sRandomSpecies));
        ShuffleListU16(stemp, RANDOM_SPECIES_COUNT, (starterId+13)*12289);
        for (i=0; i<RANDOM_SPECIES_COUNT; i++)
        {
            species = stemp[i];
            if ((GetTypeBySpecies(species, 1) == typeChallenge || GetTypeBySpecies(species, 2) == typeChallenge) 
                && species != speciesList[0] && species != speciesList[1] && species != speciesList[2])
                break;
        }

        if (i == RANDOM_SPECIES_COUNT)
            species = speciesList[1];

        Free(stemp);
    }

    #ifndef NDEBUG
        MgbaPrintf(MGBA_LOG_DEBUG, "starterId=%d; species=%d; iterations=%d", starterId, species, i);
    #endif

    return species;
}

//******* non EWRAM functions
u16 PickRandomStarter(u16 *speciesList, u8 starterId)
{
    u16 species;
    if (gSaveBlock1Ptr->tx_Random_Chaos)
        return sRandomSpeciesLegendary[RandomSeededModulo(species, RANDOM_SPECIES_COUNT_LEGENDARY)];

    if (gSaveBlock1Ptr->tx_Random_Similar)
    {
        u16 *stemp = Alloc(sizeof(sRandomSpeciesEvo0));
        DmaCopy16(3, sRandomSpeciesEvo0, stemp, sizeof(sRandomSpeciesEvo0));
        ShuffleListU16(stemp, RANDOM_SPECIES_EVO_0_COUNT, 12289);
        species = stemp[starterId*27];
        Free(stemp);
        return species;
    }
    else if (gSaveBlock1Ptr->tx_Random_IncludeLegendaries)
    {
        u16 *stemp = Alloc(sizeof(sRandomSpeciesLegendary));
        DmaCopy16(3, sRandomSpeciesLegendary, stemp, sizeof(sRandomSpeciesLegendary));
        ShuffleListU16(stemp, RANDOM_SPECIES_COUNT_LEGENDARY, 12289);
        species = stemp[starterId*27];
        Free(stemp);
        return species;
    }
    else
    {
        u16 *stemp = Alloc(sizeof(sRandomSpecies));
        DmaCopy16(3, sRandomSpecies, stemp, sizeof(sRandomSpecies));
        ShuffleListU16(stemp, RANDOM_SPECIES_COUNT, 12289);
        species = stemp[starterId*27];
        Free(stemp);
        return species;  
    } 
}

u8 GetTypeBySpecies(u16 species, u8 typeNum)
{
    u8 type;

    if ((gSaveBlock1Ptr->tx_Mode_Modern_Types == 0) 
    && (species == SPECIES_ARBOK 
    || species == SPECIES_PARASECT 
    || species == SPECIES_GOLDUCK
    || species == SPECIES_KINGLER
    || species == SPECIES_MEGANIUM
    || species == SPECIES_TYPHLOSION
    || species == SPECIES_FERALIGATR
    || species == SPECIES_NOCTOWL
    || species == SPECIES_SUNFLORA
    || species == SPECIES_STANTLER
    || species == SPECIES_GROVYLE
    || species == SPECIES_SCEPTILE
    || species == SPECIES_MASQUERAIN
    || species == SPECIES_DELCATTY
    || species == SPECIES_GULPIN
    || species == SPECIES_SWALOT
    || species == SPECIES_LUVDISC))
    {
        if (typeNum == 1)
            type = gSpeciesInfo[species].types_old[0];
        else
            type = gSpeciesInfo[species].types_old[1];
    }
    else if ((gSaveBlock1Ptr->tx_Mode_Fairy_Types == 0) 
    && (species == SPECIES_JIGGLYPUFF 
    || species == SPECIES_WIGGLYTUFF
    || species == SPECIES_CLEFAIRY
    || species == SPECIES_CLEFABLE
    || species == SPECIES_MR_MIME
    || species == SPECIES_CLEFFA
    || species == SPECIES_IGGLYBUFF
    || species == SPECIES_TOGEPI
    || species == SPECIES_TOGETIC
    || species == SPECIES_MARILL
    || species == SPECIES_AZUMARILL
    || species == SPECIES_SNUBBULL
    || species == SPECIES_GRANBULL
    || species == SPECIES_RALTS
    || species == SPECIES_KIRLIA
    || species == SPECIES_GARDEVOIR
    || species == SPECIES_AZURILL
    || species == SPECIES_MAWILE
    || species == SPECIES_MIME_JR
    || species == SPECIES_TOGEKISS))
    {
        if (typeNum == 1)
            type = gSpeciesInfo[species].types_old[0];
        else
            type = gSpeciesInfo[species].types_old[1];
    }
    else if ((gSaveBlock1Ptr->tx_Mode_Modern_Types == 1) 
    && (species == SPECIES_SNUBBULL
    || species == SPECIES_GRANBULL))
    {
        if (typeNum == 1)
            type = gSpeciesInfo[species].types_new[0];
        else
            type = gSpeciesInfo[species].types_new[1];
    }
    else
    {
        if (typeNum == 1)
            type = gSpeciesInfo[species].types[0];
        else
            type = gSpeciesInfo[species].types[1];
    }

    if (!gSaveBlock1Ptr->tx_Random_Type)
        return type;

    type = sOneTypeChallengeValidTypes[RandomSeededModulo(type + typeNum + species, NUMBER_OF_MON_TYPES-1)];

    #ifndef NDEBUG
    if (gSaveBlock1Ptr->tx_Random_Type)
        MgbaPrintf(MGBA_LOG_DEBUG, "TX RANDOM TYPE%d: species=%d=%S; type=%d=%S", typeNum, species, gSpeciesNames[species], type, gTypeNames[type]);
    #endif

    return type;
}

static u16 GetRandomSpecies(u16 species, u8 mapBased, u8 type, u16 additionalOffset) //INTERNAL use only!
{
    u8 slot, slotNew;
    u16 mapOffset = 0; //12289, 49157
    if (mapBased)
        mapOffset = NuzlockeGetCurrentRegionMapSectionId();


    if (gSaveBlock1Ptr->tx_Random_Similar)
    {
        u16 speciesResult;
        slot = gSpeciesMapping[species];

        switch (slot)
        {
        case EVO_TYPE_0:
            speciesResult = sRandomSpeciesEvo0[RandomSeededModulo(species + mapOffset + additionalOffset, RANDOM_SPECIES_EVO_0_COUNT)];
            break;
        case EVO_TYPE_1:
            speciesResult = sRandomSpeciesEvo1[RandomSeededModulo(species + mapOffset + additionalOffset, RANDOM_SPECIES_EVO_1_COUNT)];
            break;
        case EVO_TYPE_2:
            speciesResult = sRandomSpeciesEvo2[RandomSeededModulo(species + mapOffset + additionalOffset, RANDOM_SPECIES_EVO_2_COUNT)];
            break;
        case EVO_TYPE_LEGENDARY:
            speciesResult = sRandomSpeciesEvoLegendary[RandomSeededModulo(species + mapOffset + additionalOffset, RANDOM_SPECIES_EVO_LEGENDARY_COUNT)];
            break;
        }

        #ifndef NDEBUG
        slotNew = gSpeciesMapping[speciesResult];
        MgbaPrintf(MGBA_LOG_DEBUG, "%S: species=%d=%S; mapBased=%d; speciesResult=%d=%S; %S-->>%S", gRandomizationTypes[type], species, gSpeciesNames[species], mapBased, speciesResult, gSpeciesNames[speciesResult], gEvoStages[slot], gEvoStages[slotNew]);
        #endif

        return speciesResult;
    }

    if (gSaveBlock1Ptr->tx_Random_IncludeLegendaries)
        return sRandomSpeciesLegendary[RandomSeededModulo(species + mapOffset + additionalOffset, RANDOM_SPECIES_COUNT_LEGENDARY)];

    return sRandomSpecies[RandomSeededModulo(species + mapOffset + additionalOffset, RANDOM_SPECIES_COUNT)];
}
u16 GetSpeciesRandomSeeded(u16 species, u8 type, u16 additionalOffset)
{
    u8 slot, slotNew;
    u16 speciesResult = species;
    u8 mapBased = FALSE;

    //CHAOS
    if (gSaveBlock1Ptr->tx_Random_Chaos)
        return sRandomSpeciesLegendary[RandomSeededModulo(species, RANDOM_SPECIES_COUNT_LEGENDARY)];

    //if EVO_TYPE is SELF or LEGENDARY and !tx_Random_IncludeLegendaries
    slot = gSpeciesMapping[species];
    if (slot == EVO_TYPE_SELF || (slot == EVO_TYPE_LEGENDARY && !gSaveBlock1Ptr->tx_Random_IncludeLegendaries))
        return species;

    //generate species based on the type
    //different types have different parameters, e.g. abilities are never mapBased
    switch(type)
    {
    case TX_RANDOM_T_WILD_POKEMON:
        mapBased = gSaveBlock1Ptr->tx_Random_MapBased;
        speciesResult = GetRandomSpecies(species, mapBased, type, additionalOffset);
        break;
    case TX_RANDOM_T_TRAINER:
        mapBased = gSaveBlock1Ptr->tx_Random_MapBased;
        speciesResult = GetRandomSpecies(species, mapBased, type, additionalOffset);
        break;
    case TX_RANDOM_T_MOVES:
        speciesResult = sRandomSpeciesLegendary[RandomSeededModulo(species, RANDOM_SPECIES_COUNT_LEGENDARY)];
        break;
    case TX_RANDOM_T_ABILITY:
        speciesResult = GetRandomSpecies(species, mapBased, type, additionalOffset);
        break;
    case TX_RANDOM_T_EVO:
        speciesResult = GetRandomSpecies(species, mapBased, type, additionalOffset);
        break;
    case TX_RANDOM_T_EVO_METH:
        speciesResult = GetRandomSpecies(species, mapBased, type, additionalOffset);
        break;
    case TX_RANDOM_T_STATIC:
        speciesResult = GetRandomSpecies(species, mapBased, type, additionalOffset);
        break;
    }

    return speciesResult;
}

u16 GetRandomMove(u16 move, u16 species)
{
    u16 val = RandomSeededModulo(move + species, RANDOM_MOVES_COUNT);
    u16 final = sRandomValidMoves[val];

    #ifndef NDEBUG
        MgbaPrintf(MGBA_LOG_DEBUG, "TX RANDOM MOVE     : GetRandomMove: move=%d=%S, species=%d; combined=%d; val=%d; final=%d=%S", move,  gMoveNames[move], species, move + species, val, final, gMoveNames[final]);
    #endif

    return final;
}

u8 GetRandomType(void)
{
    return sOneTypeChallengeValidTypes[RandomSeededModulo(12289, NUMBER_OF_MON_TYPES-1)];
}

// Challenges
u8 EvolutionBlockedByEvoLimit(u16 species)
{
    u8 slot = gSpeciesMapping[species];
    if (slot == EVO_TYPE_1 && gSaveBlock1Ptr->tx_Challenges_EvoLimit == 1) //No Evos already previously checked
        return TRUE;

    return FALSE;
}

void FixSavePokemon1(struct BoxPokemon *boxMon)
{

    struct PokemonSubstruct0 *substruct0 = NULL;
    struct PokemonSubstruct1 *substruct1 = NULL;
    struct PokemonSubstruct2 *substruct2 = NULL;
    struct PokemonSubstruct3 *substruct3 = NULL;

    substruct0 = &(GetSubstruct(boxMon, boxMon->personality, 0)->type0);
    substruct1 = &(GetSubstruct(boxMon, boxMon->personality, 1)->type1);
    substruct2 = &(GetSubstruct(boxMon, boxMon->personality, 2)->type2);
    substruct3 = &(GetSubstruct(boxMon, boxMon->personality, 3)->type3);

    DecryptBoxMon(boxMon);

    if (substruct0->species != SPECIES_NONE)
    {    
        uint32_t b0 = ((uint32_t*)substruct3)[0];
        uint32_t b1 = ((uint32_t*)substruct3)[1];
        uint32_t b2 = ((uint32_t*)substruct3)[2];
        
        /* u32 b2 95:64 */
        // Identify bits to remain unchanged - 95:93
            // bit 91 (worldRibbon) will overwrite bit 92 (unusedRibbons)
        uint32_t hiMask = 0b11100000000000000000000000000000;
        uint32_t hiKeep = b2 & hiMask;
        
        // Identify bits to be shifted - 91:64
        hiMask = 0b11110000000000000000000000000000; // exclude bit 92
        hiMask = ~hiMask; // flip mask
        uint32_t hiShift = b2 & hiMask;
        
        /* u32 b1 63:32 */
        // Identify bits to be shifted - 63:32 (all of them)
        uint32_t mdMask = 0b11111111111111111111111111111111;
        uint32_t mdShift = b1 & mdMask;
        
        // Retrieve the leftmost bit of mdShift, which will become the rightmost of hiShift
        uint32_t lastHiBit = mdShift >> 31;
        
        /* u32 b0 31:0 */
        // Identify bits to remain unchanged - 30:0
        uint32_t loMask = 0b01111111111111111111111111111111;
        uint32_t loKeep = b0 & loMask;
        
        // Identify bits to be shifted - 63:31
        loMask = ~loMask;
        uint32_t loShift = b0 & loMask;
        
        // Retrieve the leftmost bit of loShift, which will become the rightmost of mdShift
        uint32_t lastMdBit = (uint32_t)(loShift >> 31);
        
        // Shift the relevant bits, and recombine with the unchanged bits
        b2 = hiKeep | ((hiShift << 1) | lastHiBit);
        b1 = (mdShift << 1) | lastMdBit;
        b0 = loKeep | (loShift << 1);
    
        ((uint32_t*)substruct3)[0] = b0;
        ((uint32_t*)substruct3)[1] = b1;
        ((uint32_t*)substruct3)[2] = b2;

        boxMon->checksum = CalculateBoxMonChecksum(boxMon);
    }
    
    EncryptBoxMon(boxMon);
}

=======
u16 GetFormSpeciesId(u16 speciesId, u8 formId)
{
    if (GetSpeciesFormTable(speciesId) != NULL)
        return GetSpeciesFormTable(speciesId)[formId];
    else
        return speciesId;
}

u8 GetFormIdFromFormSpeciesId(u16 formSpeciesId)
{
    u8 targetFormId = 0;

    if (GetSpeciesFormTable(formSpeciesId) != NULL)
    {
        for (targetFormId = 0; GetSpeciesFormTable(formSpeciesId)[targetFormId] != FORM_SPECIES_END; targetFormId++)
        {
            if (formSpeciesId == GetSpeciesFormTable(formSpeciesId)[targetFormId])
                break;
        }
    }
    return targetFormId;
}

// Returns the current species if no form change is possible
u32 GetFormChangeTargetSpecies(struct Pokemon *mon, enum FormChanges method, u32 arg)
{
    return GetFormChangeTargetSpeciesBoxMon(&mon->box, method, arg);
}

// Returns the current species if no form change is possible
u32 GetFormChangeTargetSpeciesBoxMon(struct BoxPokemon *boxMon, enum FormChanges method, u32 arg)
{
    u32 i;
    u32 species = GetBoxMonData(boxMon, MON_DATA_SPECIES, NULL);
    u32 targetSpecies = species;
    const struct FormChange *formChanges = GetSpeciesFormChanges(species);
    u16 heldItem;
    u32 ability;

    if (formChanges != NULL)
    {
        heldItem = GetBoxMonData(boxMon, MON_DATA_HELD_ITEM, NULL);
        ability = GetAbilityBySpecies(species, GetBoxMonData(boxMon, MON_DATA_ABILITY_NUM, NULL));

        for (i = 0; formChanges[i].method != FORM_CHANGE_TERMINATOR; i++)
        {
            if (method == formChanges[i].method && species != formChanges[i].targetSpecies)
            {
                switch (method)
                {
                case FORM_CHANGE_ITEM_HOLD:
                    if ((heldItem == formChanges[i].param1 || formChanges[i].param1 == ITEM_NONE)
                     && (ability == formChanges[i].param2 || formChanges[i].param2 == ABILITY_NONE))
                    {
                        // This is to prevent reverting to base form when giving the item to the corresponding form.
                        // Eg. Giving a Zap Plate to an Electric Arceus without an item (most likely to happen when using givemon)
                        bool32 currentItemForm = FALSE;
                        for (u32 j = 0; formChanges[j].method != FORM_CHANGE_TERMINATOR; j++)
                        {
                            if (species == formChanges[j].targetSpecies
                                && formChanges[j].param1 == heldItem
                                && formChanges[j].param1 != ITEM_NONE)
                            {
                                currentItemForm = TRUE;
                                break;
                            }
                        }
                        if (!currentItemForm)
                            targetSpecies = formChanges[i].targetSpecies;
                    }
                    break;
                case FORM_CHANGE_ITEM_USE:
                    if (arg == formChanges[i].param1)
                    {
                        bool32 pass = TRUE;
                        switch (formChanges[i].param2)
                        {
                        case DAY:
                            if (GetTimeOfDay() == TIME_NIGHT)
                                pass = FALSE;
                            break;
                        case NIGHT:
                            if (GetTimeOfDay() != TIME_NIGHT)
                                pass = FALSE;
                            break;
                        }

                        if (formChanges[i].param3 != STATUS1_NONE && GetBoxMonData(boxMon, MON_DATA_STATUS, NULL) & formChanges[i].param3)
                            pass = FALSE;

                        if (pass)
                            targetSpecies = formChanges[i].targetSpecies;
                    }
                    break;
                case FORM_CHANGE_ITEM_USE_MULTICHOICE:
                    if (arg == formChanges[i].param1)
                    {
                        if (formChanges[i].param2 == gSpecialVar_Result)
                            targetSpecies = formChanges[i].targetSpecies;
                    }
                    break;
                case FORM_CHANGE_MOVE:
                    if (BoxMonKnowsMove(boxMon, formChanges[i].param1) != formChanges[i].param2)
                        targetSpecies = formChanges[i].targetSpecies;
                    break;
                case FORM_CHANGE_BEGIN_BATTLE:
                case FORM_CHANGE_END_BATTLE:
                    if (heldItem == formChanges[i].param1 || formChanges[i].param1 == ITEM_NONE)
                        targetSpecies = formChanges[i].targetSpecies;
                    break;
                case FORM_CHANGE_END_BATTLE_ENVIRONMENT:
                    if (gBattleEnvironment == formChanges[i].param1)
                        targetSpecies = formChanges[i].targetSpecies;
                    break;
                case FORM_CHANGE_WITHDRAW:
                case FORM_CHANGE_DEPOSIT:
                case FORM_CHANGE_FAINT:
                case FORM_CHANGE_DAYS_PASSED:
                    targetSpecies = formChanges[i].targetSpecies;
                    break;
                case FORM_CHANGE_STATUS:
                    if (GetBoxMonData(boxMon, MON_DATA_STATUS, NULL) & formChanges[i].param1)
                        targetSpecies = formChanges[i].targetSpecies;
                    break;
                case FORM_CHANGE_TIME_OF_DAY:
                    switch (formChanges[i].param1)
                    {
                    case DAY:
                        if (GetTimeOfDay() != TIME_NIGHT)
                            targetSpecies = formChanges[i].targetSpecies;
                        break;
                    case NIGHT:
                        if (GetTimeOfDay() == TIME_NIGHT)
                            targetSpecies = formChanges[i].targetSpecies;
                        break;
                    }
                    break;
                default:
                    break;
                }
            }
        }
    }

    return targetSpecies;
}

void TrySetDayLimitToFormChange(struct Pokemon *mon)
{
    u32 i;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    const struct FormChange *formChanges = GetSpeciesFormChanges(species);

    for (i = 0; formChanges != NULL && formChanges[i].method != FORM_CHANGE_TERMINATOR; i++)
    {
        if (formChanges[i].method == FORM_CHANGE_DAYS_PASSED && species != formChanges[i].targetSpecies)
        {
            SetMonData(mon, MON_DATA_DAYS_SINCE_FORM_CHANGE, &formChanges[i].param1);
            break;
        }
    }
}

bool32 DoesSpeciesHaveFormChangeMethod(u16 species, enum FormChanges method)
{
    u32 i;
    const struct FormChange *formChanges = GetSpeciesFormChanges(species);

    for (i = 0; formChanges != NULL && formChanges[i].method != FORM_CHANGE_TERMINATOR; i++)
    {
        if (method == formChanges[i].method && species != formChanges[i].targetSpecies)
            return TRUE;
    }

    return FALSE;
}

>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
u16 MonTryLearningNewMoveEvolution(struct Pokemon *mon, bool8 firstMove)
{
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    u8 level = GetMonData(mon, MON_DATA_LEVEL, NULL);
<<<<<<< HEAD

    // since you can learn more than one move per level
    // the game needs to know whether you decided to
    // learn it or keep the old set to avoid asking
    // you to learn the same move over and over again
    if (gSaveBlock1Ptr->tx_Mode_Modern_Moves == 0) //If using the original movepool, just skip the code and return
        return 0;
=======
    const struct LevelUpMove *learnset = GetSpeciesLevelUpLearnset(species);

    // Since you can learn more than one move per level,
    // the game needs to know whether you decided to
    // learn it or keep the old set to avoid asking
    // you to learn the same move over and over again.
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
    if (firstMove)
    {
        sLearningMoveTableID = 0;
    }
<<<<<<< HEAD
    if (gSaveBlock1Ptr->tx_Mode_Modern_Moves == 1)
    {
        while(gLevelUpLearnsets[species][sLearningMoveTableID] != LEVEL_UP_END)
        {
            u16 moveLevel;
            moveLevel = (gLevelUpLearnsets[species][sLearningMoveTableID] & LEVEL_UP_MOVE_LV);
            while (moveLevel == 0 || moveLevel == (level << 9))
            {
                gMoveToLearn = (gLevelUpLearnsets[species][sLearningMoveTableID] & LEVEL_UP_MOVE_ID);
                sLearningMoveTableID++;
                return GiveMoveToMon(mon, gMoveToLearn);
            }
            sLearningMoveTableID++;
        }
    }
    return 0;
}
=======
    while(learnset[sLearningMoveTableID].move != LEVEL_UP_MOVE_END)
    {
        while ((learnset[sLearningMoveTableID].level == 0 || learnset[sLearningMoveTableID].level == level)
             && !(P_EVOLUTION_LEVEL_1_LEARN >= GEN_8 && learnset[sLearningMoveTableID].level == 1))
        {
            gMoveToLearn = learnset[sLearningMoveTableID].move;
            sLearningMoveTableID++;
            return GiveMoveToMon(mon, gMoveToLearn);
        }
        sLearningMoveTableID++;
    }
    return 0;
}

// Removes the selected index from the given IV list and shifts the remaining
// elements to the left.
void RemoveIVIndexFromList(u8 *ivs, u8 selectedIv)
{
    s32 i, j;
    u8 temp[NUM_STATS];

    ivs[selectedIv] = 0xFF;
    for (i = 0; i < NUM_STATS; i++)
    {
        temp[i] = ivs[i];
    }

    j = 0;
    for (i = 0; i < NUM_STATS; i++)
    {
        if (temp[i] != 0xFF)
            ivs[j++] = temp[i];
    }
}

// Attempts to perform non-level/item related overworld evolutions; called by tryspecialevo command.
void TryScriptEvolution(void)
{
    u8 i;
    bool32 canStopEvo = gSpecialVar_0x8001;
    u16 tryMultiple = gSpecialVar_0x8002;

    for (i = 0; i < PARTY_SIZE; i++)
    {
        u32 targetSpecies = GetEvolutionTargetSpecies(&gPlayerParty[i], EVO_MODE_SCRIPT_TRIGGER, 0, NULL, &canStopEvo, CHECK_EVO);

        if (targetSpecies != SPECIES_NONE && !(sTriedEvolving & (1u << i)))
        {
            GetEvolutionTargetSpecies(&gPlayerParty[i], EVO_MODE_SCRIPT_TRIGGER, 0, NULL, &canStopEvo, DO_EVO);
            sTriedEvolving |= 1u << i;
            if(gMain.callback2 == TryScriptEvolution) // This fixes small graphics glitches.
                EvolutionScene(&gPlayerParty[i], targetSpecies, canStopEvo, i);
            else
                BeginEvolutionScene(&gPlayerParty[i], targetSpecies, canStopEvo, i);

            if (tryMultiple)
                gCB2_AfterEvolution = TryScriptEvolution;
            else
                gCB2_AfterEvolution = CB2_ReturnToField;
            return;
        }
    }

    sTriedEvolving = 0;
    SetMainCallback2(CB2_ReturnToField);
}

void TrySpecialOverworldEvo(void)
{
    u8 i;
    bool32 canStopEvo = gSpecialVar_0x8001;
    u16 tryMultiple = gSpecialVar_0x8002;

    for (i = 0; i < PARTY_SIZE; i++)
    {
        u32 targetSpecies = GetEvolutionTargetSpecies(&gPlayerParty[i], EVO_MODE_OVERWORLD_SPECIAL, 0, NULL, &canStopEvo, CHECK_EVO);

        if (targetSpecies != SPECIES_NONE && !(sTriedEvolving & (1u << i)))
        {
            GetEvolutionTargetSpecies(&gPlayerParty[i], EVO_MODE_OVERWORLD_SPECIAL, 0, NULL, &canStopEvo, DO_EVO);
            sTriedEvolving |= 1u << i;
            if(gMain.callback2 == TrySpecialOverworldEvo) // This fixes small graphics glitches.
                EvolutionScene(&gPlayerParty[i], targetSpecies, canStopEvo, i);
            else
                BeginEvolutionScene(&gPlayerParty[i], targetSpecies, canStopEvo, i);

            if (tryMultiple)
                gCB2_AfterEvolution = TrySpecialOverworldEvo;
            else
                gCB2_AfterEvolution = CB2_ReturnToField;
            return;
        }
    }

    sTriedEvolving = 0;
    SetMainCallback2(CB2_ReturnToField);
}

bool32 SpeciesHasGenderDifferences(u16 species)
{
#if P_GENDER_DIFFERENCES
    if (gSpeciesInfo[species].frontPicFemale != NULL
     || gSpeciesInfo[species].backPicFemale != NULL
     || gSpeciesInfo[species].paletteFemale != NULL
     || gSpeciesInfo[species].shinyPaletteFemale != NULL
     || gSpeciesInfo[species].iconSpriteFemale != NULL)
        return TRUE;
#endif

    return FALSE;
}

bool32 TryFormChange(u32 monId, u32 side, enum FormChanges method)
{
    struct Pokemon *party = (side == B_SIDE_PLAYER) ? gPlayerParty : gEnemyParty;

    if (GetMonData(&party[monId], MON_DATA_SPECIES_OR_EGG, 0) == SPECIES_NONE
     || GetMonData(&party[monId], MON_DATA_SPECIES_OR_EGG, 0) == SPECIES_EGG)
        return FALSE;

    u32 currentSpecies = GetMonData(&party[monId], MON_DATA_SPECIES);
    u32 targetSpecies = GetFormChangeTargetSpecies(&party[monId], method, 0);

    if (targetSpecies == currentSpecies && gBattleStruct != NULL && gBattleStruct->partyState[side][monId].changedSpecies != SPECIES_NONE)
        targetSpecies = gBattleStruct->partyState[side][monId].changedSpecies;

    if (targetSpecies != currentSpecies)
    {
        TryToSetBattleFormChangeMoves(&party[monId], method);
        SetMonData(&party[monId], MON_DATA_SPECIES, &targetSpecies);
        CalculateMonStats(&party[monId]);
        return TRUE;
    }

    return FALSE;
}

u16 SanitizeSpeciesId(u16 species)
{
    if (species > NUM_SPECIES || !IsSpeciesEnabled(species))
        return SPECIES_NONE;
    else
        return species;
}

bool32 IsSpeciesEnabled(u16 species)
{
    // This function should not use the GetSpeciesBaseHP function, as the included sanitation will result in an infinite loop
    return gSpeciesInfo[species].baseHP > 0 || species == SPECIES_EGG;
}

void TryToSetBattleFormChangeMoves(struct Pokemon *mon, enum FormChanges method)
{
    int i, j;
    u16 species = GetMonData(mon, MON_DATA_SPECIES, NULL);
    const struct FormChange *formChanges = GetSpeciesFormChanges(species);

    if (formChanges == NULL
        || (method != FORM_CHANGE_BEGIN_BATTLE && method != FORM_CHANGE_END_BATTLE))
        return;

    for (i = 0; formChanges[i].method != FORM_CHANGE_TERMINATOR; i++)
    {
        if (formChanges[i].method == method
            && formChanges[i].param2
            && formChanges[i].param3
            && formChanges[i].targetSpecies != species)
        {
            u16 originalMove = formChanges[i].param2;
            u16 newMove = formChanges[i].param3;

            for (j = 0; j < MAX_MON_MOVES; j++)
            {
                u16 currMove = GetMonData(mon, MON_DATA_MOVE1 + j, NULL);
                if (currMove == originalMove)
                    SetMonMoveSlot_KeepPP(mon, newMove, j);
            }
            break;
        }
    }
}

u32 GetMonFriendshipScore(struct Pokemon *pokemon)
{
    u32 friendshipScore = GetMonData(pokemon, MON_DATA_FRIENDSHIP, NULL);

    if (friendshipScore == MAX_FRIENDSHIP)
        return FRIENDSHIP_MAX;
    if (friendshipScore >= 200)
        return FRIENDSHIP_200_TO_254;
    if (friendshipScore >= 150)
        return FRIENDSHIP_150_TO_199;
    if (friendshipScore >= 100)
        return FRIENDSHIP_100_TO_149;
    if (friendshipScore >= 50)
        return FRIENDSHIP_50_TO_99;
    if (friendshipScore >= 1)
        return FRIENDSHIP_1_TO_49;

    return FRIENDSHIP_NONE;
}

u32 GetMonAffectionHearts(struct Pokemon *pokemon)
{
    u32 friendship = GetMonData(pokemon, MON_DATA_FRIENDSHIP, NULL);

    if (friendship == MAX_FRIENDSHIP)
        return AFFECTION_FIVE_HEARTS;
    if (friendship >= 220)
        return AFFECTION_FOUR_HEARTS;
    if (friendship >= 180)
        return AFFECTION_THREE_HEARTS;
    if (friendship >= 130)
        return AFFECTION_TWO_HEARTS;
    if (friendship >= 80)
        return AFFECTION_ONE_HEART;

    return AFFECTION_NO_HEARTS;
}

void UpdateMonPersonality(struct BoxPokemon *boxMon, u32 personality)
{
    struct PokemonSubstruct0 *old0, *new0;
    struct PokemonSubstruct1 *old1, *new1;
    struct PokemonSubstruct2 *old2, *new2;
    struct PokemonSubstruct3 *old3, *new3;
    struct BoxPokemon old;

    bool32 isShiny = GetBoxMonData(boxMon, MON_DATA_IS_SHINY, NULL);
    u32 hiddenNature = GetBoxMonData(boxMon, MON_DATA_HIDDEN_NATURE, NULL);
    u32 teraType = GetBoxMonData(boxMon, MON_DATA_TERA_TYPE, NULL);

    old = *boxMon;
    old0 = &(GetSubstruct(&old, old.personality, SUBSTRUCT_TYPE_0)->type0);
    old1 = &(GetSubstruct(&old, old.personality, SUBSTRUCT_TYPE_1)->type1);
    old2 = &(GetSubstruct(&old, old.personality, SUBSTRUCT_TYPE_2)->type2);
    old3 = &(GetSubstruct(&old, old.personality, SUBSTRUCT_TYPE_3)->type3);

    new0 = &(GetSubstruct(boxMon, personality, SUBSTRUCT_TYPE_0)->type0);
    new1 = &(GetSubstruct(boxMon, personality, SUBSTRUCT_TYPE_1)->type1);
    new2 = &(GetSubstruct(boxMon, personality, SUBSTRUCT_TYPE_2)->type2);
    new3 = &(GetSubstruct(boxMon, personality, SUBSTRUCT_TYPE_3)->type3);

    DecryptBoxMon(&old);
    boxMon->personality = personality;
    *new0 = *old0;
    *new1 = *old1;
    *new2 = *old2;
    *new3 = *old3;
    boxMon->checksum = CalculateBoxMonChecksumReencrypt(boxMon);

    SetBoxMonData(boxMon, MON_DATA_IS_SHINY, &isShiny);
    SetBoxMonData(boxMon, MON_DATA_HIDDEN_NATURE, &hiddenNature);
    SetBoxMonData(boxMon, MON_DATA_TERA_TYPE, &teraType);
}

void HealPokemon(struct Pokemon *mon)
{
    u32 data;

    data = GetMonData(mon, MON_DATA_MAX_HP);
    SetMonData(mon, MON_DATA_HP, &data);

    data = STATUS1_NONE;
    SetMonData(mon, MON_DATA_STATUS, &data);

    MonRestorePP(mon);
}

void HealBoxPokemon(struct BoxPokemon *boxMon)
{
    u32 data;

    data = 0;
    SetBoxMonData(boxMon, MON_DATA_HP_LOST, &data);

    data = STATUS1_NONE;
    SetBoxMonData(boxMon, MON_DATA_STATUS, &data);

    BoxMonRestorePP(boxMon);
}

enum PokemonCry GetCryIdBySpecies(u16 species)
{
    species = SanitizeSpeciesId(species);
    if (P_CRIES_ENABLED == FALSE || gSpeciesInfo[species].cryId >= CRY_COUNT || gTestRunnerHeadless)
        return CRY_NONE;
    return gSpeciesInfo[species].cryId;
}

u16 GetSpeciesPreEvolution(u16 species)
{
    int i, j;

    for (i = SPECIES_BULBASAUR; i < NUM_SPECIES; i++)
    {
        const struct Evolution *evolutions = GetSpeciesEvolutions(i);
        if (evolutions == NULL)
            continue;
        for (j = 0; evolutions[j].method != EVOLUTIONS_END; j++)
        {
            if (SanitizeSpeciesId(evolutions[j].targetSpecies) == species)
                return i;
        }
    }

    return SPECIES_NONE;
}

void UpdateDaysPassedSinceFormChange(u16 days)
{
    u32 i;
    for (i = 0; i < PARTY_SIZE; i++)
    {
        struct Pokemon *mon = &gPlayerParty[i];
        u32 currentSpecies = GetMonData(mon, MON_DATA_SPECIES);
        u8 daysSinceFormChange;

        if (currentSpecies == SPECIES_NONE)
            continue;

        daysSinceFormChange = GetMonData(mon, MON_DATA_DAYS_SINCE_FORM_CHANGE, 0);
        if (daysSinceFormChange == 0)
            continue;

        if (daysSinceFormChange > days)
            daysSinceFormChange -= days;
        else
            daysSinceFormChange = 0;

        SetMonData(mon, MON_DATA_DAYS_SINCE_FORM_CHANGE, &daysSinceFormChange);

        if (daysSinceFormChange == 0)
        {
            u32 targetSpecies = GetFormChangeTargetSpecies(mon, FORM_CHANGE_DAYS_PASSED, 0);

            if (targetSpecies != currentSpecies)
            {
                SetMonData(mon, MON_DATA_SPECIES, &targetSpecies);
                CalculateMonStats(mon);
            }
        }
    }
}

u32 CheckDynamicMoveType(struct Pokemon *mon, u32 move, u32 battler, enum MonState state)
{
    u32 moveType = GetDynamicMoveType(mon, move, battler, state);
    if (moveType != TYPE_NONE)
        return moveType;
    return GetMoveType(move);
}

uq4_12_t GetDynamaxLevelHPMultiplier(u32 dynamaxLevel, bool32 inverseMultiplier)
{
    if (inverseMultiplier)
        return UQ_4_12(1.0/(1.5 + 0.05 * dynamaxLevel));
    return UQ_4_12(1.5 + 0.05 * dynamaxLevel);
}

bool32 IsSpeciesRegionalForm(u32 species)
{
    return gSpeciesInfo[species].isAlolanForm
        || gSpeciesInfo[species].isGalarianForm
        || gSpeciesInfo[species].isHisuianForm
        || gSpeciesInfo[species].isPaldeanForm;
}

bool32 IsSpeciesRegionalFormFromRegion(u32 species, u32 region)
{
    switch (region)
    {
    case REGION_ALOLA:  return gSpeciesInfo[species].isAlolanForm;
    case REGION_GALAR:  return gSpeciesInfo[species].isGalarianForm;
    case REGION_HISUI:  return gSpeciesInfo[species].isHisuianForm;
    case REGION_PALDEA: return gSpeciesInfo[species].isPaldeanForm;
    default:            return FALSE;
    }
}

bool32 SpeciesHasRegionalForm(u32 species)
{
    u32 formId;
    const u16 *formTable = GetSpeciesFormTable(species);
    for (formId = 0; formTable != NULL && formTable[formId] != FORM_SPECIES_END; formId++)
    {
        if (IsSpeciesRegionalForm(formTable[formId]))
            return TRUE;
    }
    return FALSE;
}

u32 GetRegionalFormByRegion(u32 species, u32 region)
{
    u32 formId = 0;
    u32 firstFoundSpecies = 0;
    const u16 *formTable = GetSpeciesFormTable(species);

    if (formTable != NULL)
    {
        for (formId = 0; formTable[formId] != FORM_SPECIES_END; formId++)
        {
            if (firstFoundSpecies == 0)
                firstFoundSpecies = formTable[formId];

            if (IsSpeciesRegionalFormFromRegion(formTable[formId], region))
                return formTable[formId];
        }
        if (firstFoundSpecies != 0)
            return firstFoundSpecies;
    }
    return species;
}

bool32 IsSpeciesForeignRegionalForm(u32 species, u32 currentRegion)
{
    u32 i;
    for (i = 0; i < REGIONS_COUNT; i++)
    {
        if (currentRegion != i && IsSpeciesRegionalFormFromRegion(species, i))
            return TRUE;
        else if (currentRegion == i && SpeciesHasRegionalForm(species) && !IsSpeciesRegionalFormFromRegion(species, i))
            return TRUE;
    }
    return FALSE;
}

u32 GetTeraTypeFromPersonality(struct Pokemon *mon)
{
    const u8 *types = gSpeciesInfo[GetMonData(mon, MON_DATA_SPECIES)].types;
    return (GetMonData(mon, MON_DATA_PERSONALITY) & 0x1) == 0 ? types[0] : types[1];
}

struct Pokemon *GetSavedPlayerPartyMon(u32 index)
{
    return &gSaveBlock1Ptr->playerParty[index];
}

u8 *GetSavedPlayerPartyCount(void)
{
    return &gSaveBlock1Ptr->playerPartyCount;
}

void SavePlayerPartyMon(u32 index, struct Pokemon *mon)
{
    gSaveBlock1Ptr->playerParty[index] = *mon;
}

u32 IsSpeciesOfType(u32 species, u32 type)
{
    if (gSpeciesInfo[species].types[0] == type
     || gSpeciesInfo[species].types[1] == type)
        return TRUE;
    return FALSE;
}
>>>>>>> 8eea132406f53e5857d1eec72181867b469bddfc
